BASH=/bin/bash
BASHOPTS=cmdhist:expand_aliases:extglob:extquote:force_fignore:interactive_comments:progcomp:promptvars:sourcepath
BASH_ALIASES=()
BASH_ARGC=()
BASH_ARGV=()
BASH_CMDS=()
BASH_COMPLETION=/etc/bash_completion
BASH_COMPLETION_COMPAT_DIR=/etc/bash_completion.d
BASH_COMPLETION_DIR=/etc/bash_completion.d
BASH_LINENO=()
BASH_SOURCE=()
BASH_VERSINFO=([0]="4" [1]="1" [2]="9" [3]="2" [4]="release" [5]="i686-pc-linux-gnu")
BASH_VERSION='4.1.9(2)-release'
BROWSER=swiftfox
COLORTERM=Terminal
COLUMNS=80
COMP_WORDBREAKS=$' \t\n"\'><=;|&(:'
DBUS_SESSION_BUS_ADDRESS=unix:abstract=/tmp/dbus-a4yVeldA2T,guid=938c99695a5342804043b3db00000022
DESKTOP_SESSION=xfce
DIRSTACK=()
DISPLAY=:0.0
EDITOR=/usr/bin/nano
EUID=1000
GLADE_CATALOG_PATH=:
GLADE_MODULE_PATH=:
GLADE_PIXMAP_PATH=:
GPG_AGENT_INFO=/tmp/gpg-ROzOVf/S.gpg-agent:1648:1
GREP_COLOR='1;33'
GROUPS=()
GTK_PATH=:/usr/lib/gtk-2.0
G_BROKEN_FILENAMES=1
HISTCONTROL=ignoredups
HISTFILE=/home/francois/.bash_history
HISTFILESIZE=500
HISTSIZE=500
HOME=/home/francois
HOSTNAME=portable
HOSTTYPE=i686
HUSHLOGIN=FALSE
IFS=$' \t\n'
J2REDIR=/usr/lib/jvm/java-6-openjdk/jre
J2SDKDIR=/usr/lib/jvm/java-6-openjdk
JAVA_HOME=/usr/lib/jvm/java-6-openjdk
LANG=fr_FR.UTF-8
LESSCHARSET=UTF-8
LIBGLADE_MODULE_PATH=:
LINES=24
LOGNAME=francois
MACHTYPE=i686-pc-linux-gnu
MAIL=/var/spool/mail/francois
MAILCHECK=60
MOZ_PLUGIN_PATH=/usr/lib/mozilla/plugins
OLDPWD=/home/francois
OPTERR=1
OPTIND=1
OSTYPE=linux-gnu
PATH=/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/sbin:/usr/bin/core_perl:/opt/qt/bin
PIPESTATUS=([0]="0" [1]="0")
PKG_CONFIG_PATH=:/opt/qt/lib/pkgconfig
PPID=2447
PROMPT_COMMAND=bash_prompt_cmd
PS1='\[\e[1;34m\].:[ \[\e[1;36m\]francois@portable \[\e[1;34m\]: \[\e[1;36m\]\t \[\e[1;34m\]:\[\e[1;36m\] ~/django/grisbi/gsb \[\e[1;34m\]]:.\n\[\e[1;36m\]$ \[\e[0m\]'
PS2='> '
PS3='> '
PS4='+ '
PWD=/home/francois/django/grisbi/gsb
QTDIR=/opt/qt
QT_XFT=true
SESSION_MANAGER=local/portable:@/tmp/.ICE-unix/1658,unix/portable:/tmp/.ICE-unix/1658
SHELL=/bin/bash
SHELLOPTS=braceexpand:emacs:hashall:histexpand:history:interactive-comments:monitor
SHLVL=5
SSH_AGENT_PID=1648
SSH_AUTH_SOCK=/tmp/gpg-ZQBZcT/S.gpg-agent.ssh
TERM=xterm
UID=1000
USER=francois
WINDOWID=50342775
WINDOWPATH=7
XAUTHORITY=/home/francois/.Xauthority
XDG_CACHE_HOME=/home/francois/.cache
XDG_CONFIG_DIRS=/etc/xdg:/etc/xdg
XDG_CONFIG_HOME=/home/francois/.config
XDG_DATA_DIRS=/usr/share/:/usr/local/share/:/usr/share
XDG_DATA_HOME=/home/francois/.local/share
XDG_MENU_PREFIX=xfce-
XDG_SESSION_COOKIE=d390a1d85dcd6f46b10b31e200000320-1299397463.663100-647949378
_=
__git_all_commands=
__git_diff_common_options=$'--stat --numstat --shortstat --summary\n\t\t\t--patch-with-stat --name-only --name-status --color\n\t\t\t--no-color --color-words --no-renames --check\n\t\t\t--full-index --binary --abbrev --diff-filter=\n\t\t\t--find-copies-harder\n\t\t\t--text --ignore-space-at-eol --ignore-space-change\n\t\t\t--ignore-all-space --exit-code --quiet --ext-diff\n\t\t\t--no-ext-diff\n\t\t\t--no-prefix --src-prefix= --dst-prefix=\n\t\t\t--inter-hunk-context=\n\t\t\t--patience\n\t\t\t--raw\n\t\t\t--dirstat --dirstat= --dirstat-by-file\n\t\t\t--dirstat-by-file= --cumulative\n'
__git_fetch_options=$'\n\t--quiet --verbose --append --upload-pack --force --keep --depth=\n\t--tags --no-tags --all --prune --dry-run\n'
__git_log_common_options=$'\n\t--not --all\n\t--branches --tags --remotes\n\t--first-parent --merges --no-merges\n\t--max-count=\n\t--max-age= --since= --after=\n\t--min-age= --until= --before=\n'
__git_log_date_formats='relative iso8601 rfc2822 short local default raw'
__git_log_gitk_options=$'\n\t--dense --sparse --full-history\n\t--simplify-merges --simplify-by-decoration\n\t--left-right\n'
__git_log_pretty_formats='oneline short medium full fuller email raw format:'
__git_log_shortlog_options=$'\n\t--author= --committer= --grep=\n\t--all-match\n'
__git_merge_options=$'\n\t--no-commit --no-stat --log --no-log --squash --strategy\n\t--commit --stat --no-squash --ff --no-ff --ff-only\n'
__git_merge_strategies=
__git_mergetools_common=$'diffuse ecmerge emerge kdiff3 meld opendiff\n\t\t\ttkdiff vimdiff gvimdiff xxdiff araxis p4merge\n'
__git_porcelain_commands=
__git_send_email_confirm_options='always never auto cc compose'
__git_send_email_suppresscc_options='author self cc bodycc sob cccmd body all'
__git_whitespacelist='nowarn warn error error-all fix'
_scp_path_esc='[][(){}<>",:;^&!$=?`|\\'\''[:space:]]'
python=/usr/include/python3.2mu
python_interpreters='/usr/bin/python2.7 /usr/bin/python3.2 /usr/bin/python3.2-config /usr/bin/python3.2mu /usr/bin/python3.2mu-config /usr/bin/python2.7-config /usr/bin/python /usr/lib/python2.7 /usr/lib/python3.2 /usr/lib/python3.1 /usr/include/python2.7 /usr/include/python3.2mu'
pythons='python python2.7 python2.7-config python3.1 python3.2 python3.2-config python3.2mu python3.2mu-config '
_ImageMagick () 
{ 
    local cur prev;
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -channel)
            COMPREPLY=($( compgen -W 'Red Green Blue Opacity \
                Matte Cyan Magenta Yellow Black' -- "$cur" ));
            return 0
        ;;
        -colormap)
            COMPREPLY=($( compgen -W 'shared private' -- "$cur" ));
            return 0
        ;;
        -colorspace)
            COMPREPLY=($( compgen -W 'GRAY OHTA RGB Transparent \
                XYZ YCbCr YIQ YPbPr YUV CMYK' -- "$cur" ));
            return 0
        ;;
        -compose)
            COMPREPLY=($( compgen -W 'Over In Out Atop Xor Plus \
                Minus Add Subtract Difference Multiply Bumpmap\
                Copy CopyRed CopyGreen CopyBlue CopyOpacity' -- "$cur" ));
            return 0
        ;;
        -compress)
            COMPREPLY=($( compgen -W 'None BZip Fax Group4 JPEG \
                Lossless LZW RLE Zip' -- "$cur" ));
            return 0
        ;;
        -dispose)
            COMPREPLY=($( compgen -W 'Undefined None Background Previous'                 -- "$cur" ));
            return 0
        ;;
        -encoding)
            COMPREPLY=($( compgen -W 'AdobeCustom AdobeExpert \
                AdobeStandard AppleRoman BIG5 GB2312 Latin2 \
                None SJIScode Symbol Unicode Wansung' -- "$cur"));
            return 0
        ;;
        -endian)
            COMPREPLY=($( compgen -W 'MSB LSB' -- "$cur" ));
            return 0
        ;;
        -filter)
            COMPREPLY=($( compgen -W 'Point Box Triangle Hermite \
                Hanning Hamming Blackman Gaussian Quadratic \
                Cubic Catrom Mitchell Lanczos Bessel Sinc' -- "$cur" ));
            return 0
        ;;
        -format)
            COMPREPLY=($( compgen -W "$( convert -list format |                 awk '/ [r-][w-][+-] / {print $1}' |                 tr -d '*' | tr [:upper:] [:lower:] )" -- "$cur" ));
            return 0
        ;;
        -gravity)
            COMPREPLY=($( compgen -W 'Northwest North NorthEast \
                West Center East SouthWest South SouthEast' -- "$cur" ));
            return 0
        ;;
        -intent)
            COMPREPLY=($( compgen -W 'Absolute Perceptual \
                Relative Saturation' -- "$cur" ));
            return 0
        ;;
        -interlace)
            COMPREPLY=($( compgen -W 'None Line Plane Partition' -- "$cur" ));
            return 0
        ;;
        -limit)
            COMPREPLY=($( compgen -W 'Disk File Map Memory' -- "$cur" ));
            return 0
        ;;
        -list)
            COMPREPLY=($( compgen -W 'Delegate Format Magic Module Resource \
                Type' -- "$cur" ));
            return 0
        ;;
        -map)
            COMPREPLY=($( compgen -W 'best default gray red green blue'                 -- "$cur" ));
            _filedir;
            return 0
        ;;
        -noise)
            COMPREPLY=($( compgen -W 'Uniform Gaussian Multiplicative \
                Impulse Laplacian Poisson' -- "$cur" ));
            return 0
        ;;
        -preview)
            COMPREPLY=($( compgen -W 'Rotate Shear Roll Hue \
                Saturation Brightness Gamma Spiff \
                Dull Grayscale Quantize Despeckle \
                ReduceNoise AddNoise Sharpen Blur \
                Treshold EdgeDetect Spread Shade \
                Raise Segment Solarize Swirl Implode \
                Wave OilPaint CharcoalDrawing JPEG' -- "$cur" ));
            return 0
        ;;
        -mask | -profile | -texture | -tile | -write)
            _filedir;
            return 0
        ;;
        -type)
            COMPREPLY=($( compgen -W 'Bilevel Grayscale Palette PaletteMatte \
                TrueColor TrueColorMatte ColorSeparation ColorSeparationlMatte \
                Optimize' -- "$cur" ));
            return 0
        ;;
        -units)
            COMPREPLY=($( compgen -W 'Undefined PixelsPerInch \
                PixelsPerCentimeter' -- "$cur" ));
            return 0
        ;;
        -virtual-pixel)
            COMPREPLY=($( compgen -W 'Constant Edge mirror tile' -- "$cur" ));
            return 0
        ;;
        -visual)
            COMPREPLY=($( compgen -W 'StaticGray GrayScale StaticColor \
                PseudoColor TrueColor DirectColor defaut visualid' -- "$cur" ));
            return 0
        ;;
    esac
}
__escape_strings_stdin () 
{ 
    sed "s/\([><()\";\`' ]\)/\\\\\\1/g"
}
__expand_tilde_by_ref () 
{ 
    if [ "${!1:0:1}" = "~" ]; then
        if [ "${!1}" != "${!1//\/}" ]; then
            eval $1="${!1/%\/*}"/'${!1#*/}';
        else
            eval $1="${!1}";
        fi;
    fi
}
__gdbus () 
{ 
    local IFS='
';
    local cur=`_get_cword :`;
    local suggestions=$(gdbus complete "${COMP_LINE}" ${COMP_POINT});
    COMPREPLY=($(compgen -W "$suggestions" -- "$cur"));
    case "$cur" in 
        *:*)
            case "$COMP_WORDBREAKS" in 
                *:*)
                    local colon_word=${cur%${cur##*:}};
                    local i=${#COMPREPLY[*]};
                    while [ $((--i)) -ge 0 ]; do
                        COMPREPLY[$i]=${COMPREPLY[$i]#"$colon_word"};
                    done
                ;;
            esac
        ;;
    esac
}
__get_cword_at_cursor_by_ref () 
{ 
    local cword words=();
    __reassemble_comp_words_by_ref "$1" words cword;
    local i cur2;
    local cur="$COMP_LINE";
    local index="$COMP_POINT";
    for ((i = 0; i <= cword; ++i ))
    do
        while [[ "${#cur}" -ge ${#words[i]} && "${cur:0:${#words[i]}}" != "${words[i]}" ]]; do
            cur="${cur:1}";
            ((index--));
        done;
        if [[ "$i" -lt "$cword" ]]; then
            local old_size="${#cur}";
            cur="${cur#${words[i]}}";
            local new_size="${#cur}";
            index=$(( index - old_size + new_size ));
        fi;
    done;
    if [[ "${words[cword]:0:${#cur}}" != "$cur" ]]; then
        cur2=${words[cword]};
    else
        cur2=${cur:0:$index};
    fi;
    local "$2" "$3" "$4" && _upvars -a${#words[@]} $2 "${words[@]}" -v $3 "$cword" -v $4 "$cur2"
}
__get_long_cur () 
{ 
    cur="$(echo "${COMP_LINE#*$command}" | sed 's/^ *//')"
}
__git_aliased_command () 
{ 
    local word cmdline=$(git --git-dir="$(__gitdir)" 		config --get "alias.$1");
    for word in $cmdline;
    do
        case "$word" in 
            \!gitk | gitk)
                echo "gitk";
                return
            ;;
            \!*)
                : shell command alias
            ;;
            -*)
                : option
            ;;
            *=*)
                : setting env
            ;;
            git)
                : git itself
            ;;
            *)
                echo "$word";
                return
            ;;
        esac;
    done
}
__git_aliases () 
{ 
    local i IFS='
';
    for i in $(git --git-dir="$(__gitdir)" config --get-regexp "alias\..*" 2>/dev/null);
    do
        case "$i" in 
            alias.*)
                i="${i#alias.}";
                echo "${i/ */}"
            ;;
        esac;
    done
}
__git_complete_file () 
{ 
    local pfx ls ref cur;
    _get_comp_words_by_ref -n =: cur;
    case "$cur" in 
        ?*:*)
            ref="${cur%%:*}";
            cur="${cur#*:}";
            case "$cur" in 
                ?*/*)
                    pfx="${cur%/*}";
                    cur="${cur##*/}";
                    ls="$ref:$pfx";
                    pfx="$pfx/"
                ;;
                *)
                    ls="$ref"
                ;;
            esac;
            case "$COMP_WORDBREAKS" in 
                *:*)
                    : great
                ;;
                *)
                    pfx="$ref:$pfx"
                ;;
            esac;
            local IFS='
';
            COMPREPLY=($(compgen -P "$pfx" 			-W "$(git --git-dir="$(__gitdir)" ls-tree "$ls" 				| sed '/^100... blob /{
				           s,^.*	,,
				           s,$, ,
				       }
				       /^120000 blob /{
				           s,^.*	,,
				           s,$, ,
				       }
				       /^040000 tree /{
				           s,^.*	,,
				           s,$,/,
				       }
				       s/^.*	//')" 			-- "$cur"))
        ;;
        *)
            __gitcomp "$(__git_refs)"
        ;;
    esac
}
__git_complete_remote_or_refspec () 
{ 
    local cur words cword;
    _get_comp_words_by_ref -n =: cur words cword;
    local cmd="${words[1]}";
    local i c=2 remote="" pfx="" lhs=1 no_complete_refspec=0;
    while [ $c -lt $cword ]; do
        i="${words[c]}";
        case "$i" in 
            --mirror)
                [ "$cmd" = "push" ] && no_complete_refspec=1
            ;;
            --all)
                case "$cmd" in 
                    push)
                        no_complete_refspec=1
                    ;;
                    fetch)
                        COMPREPLY=();
                        return
                    ;;
                    *)

                    ;;
                esac
            ;;
            -*)

            ;;
            *)
                remote="$i";
                break
            ;;
        esac;
        c=$((++c));
    done;
    if [ -z "$remote" ]; then
        __gitcomp "$(__git_remotes)";
        return;
    fi;
    if [ $no_complete_refspec = 1 ]; then
        COMPREPLY=();
        return;
    fi;
    [ "$remote" = "." ] && remote=;
    case "$cur" in 
        *:*)
            case "$COMP_WORDBREAKS" in 
                *:*)
                    : great
                ;;
                *)
                    pfx="${cur%%:*}:"
                ;;
            esac;
            cur="${cur#*:}";
            lhs=0
        ;;
        +*)
            pfx="+";
            cur="${cur#+}"
        ;;
    esac;
    case "$cmd" in 
        fetch)
            if [ $lhs = 1 ]; then
                __gitcomp "$(__git_refs2 "$remote")" "$pfx" "$cur";
            else
                __gitcomp "$(__git_refs)" "$pfx" "$cur";
            fi
        ;;
        pull)
            if [ $lhs = 1 ]; then
                __gitcomp "$(__git_refs "$remote")" "$pfx" "$cur";
            else
                __gitcomp "$(__git_refs)" "$pfx" "$cur";
            fi
        ;;
        push)
            if [ $lhs = 1 ]; then
                __gitcomp "$(__git_refs)" "$pfx" "$cur";
            else
                __gitcomp "$(__git_refs "$remote")" "$pfx" "$cur";
            fi
        ;;
    esac
}
__git_complete_revlist () 
{ 
    local pfx cur;
    _get_comp_words_by_ref -n =: cur;
    case "$cur" in 
        *...*)
            pfx="${cur%...*}...";
            cur="${cur#*...}";
            __gitcomp "$(__git_refs)" "$pfx" "$cur"
        ;;
        *..*)
            pfx="${cur%..*}..";
            cur="${cur#*..}";
            __gitcomp "$(__git_refs)" "$pfx" "$cur"
        ;;
        *)
            __gitcomp "$(__git_refs)"
        ;;
    esac
}
__git_complete_strategy () 
{ 
    local cur prev;
    _get_comp_words_by_ref -n =: cur prev;
    __git_compute_merge_strategies;
    case "$prev" in 
        -s | --strategy)
            __gitcomp "$__git_merge_strategies";
            return 0
        ;;
    esac;
    case "$cur" in 
        --strategy=*)
            __gitcomp "$__git_merge_strategies" "" "${cur##--strategy=}";
            return 0
        ;;
    esac;
    return 1
}
__git_compute_all_commands () 
{ 
    : ${__git_all_commands:=$(__git_list_all_commands)}
}
__git_compute_merge_strategies () 
{ 
    : ${__git_merge_strategies:=$(__git_list_merge_strategies)}
}
__git_compute_porcelain_commands () 
{ 
    __git_compute_all_commands;
    : ${__git_porcelain_commands:=$(__git_list_porcelain_commands)}
}
__git_config_get_set_variables () 
{ 
    local words cword;
    _get_comp_words_by_ref -n =: words cword;
    local prevword word config_file= c=$cword;
    while [ $c -gt 1 ]; do
        word="${words[c]}";
        case "$word" in 
            --global | --system | --file=*)
                config_file="$word";
                break
            ;;
            -f | --file)
                config_file="$word $prevword";
                break
            ;;
        esac;
        prevword=$word;
        c=$((--c));
    done;
    git --git-dir="$(__gitdir)" config $config_file --list 2> /dev/null | while read line; do
        case "$line" in 
            *.*=*)
                echo "${line/=*/}"
            ;;
        esac;
    done
}
__git_find_on_cmdline () 
{ 
    local word subcommand c=1 words cword;
    _get_comp_words_by_ref -n =: words cword;
    while [ $c -lt $cword ]; do
        word="${words[c]}";
        for subcommand in $1;
        do
            if [ "$subcommand" = "$word" ]; then
                echo "$subcommand";
                return;
            fi;
        done;
        c=$((++c));
    done
}
__git_has_doubledash () 
{ 
    local c=1 words cword;
    _get_comp_words_by_ref -n =: words cword;
    while [ $c -lt $cword ]; do
        if [ "--" = "${words[c]}" ]; then
            return 0;
        fi;
        c=$((++c));
    done;
    return 1
}
__git_heads () 
{ 
    local cmd i is_hash=y dir="$(__gitdir "${1-}")";
    if [ -d "$dir" ]; then
        git --git-dir="$dir" for-each-ref --format='%(refname:short)' refs/heads;
        return;
    fi;
    for i in $(git ls-remote "${1-}" 2>/dev/null);
    do
        case "$is_hash,$i" in 
            y,*)
                is_hash=n
            ;;
            n,*^{})
                is_hash=y
            ;;
            n,refs/heads/*)
                is_hash=y;
                echo "${i#refs/heads/}"
            ;;
            n,*)
                is_hash=y;
                echo "$i"
            ;;
        esac;
    done
}
__git_list_all_commands () 
{ 
    local i IFS=" "'
';
    for i in $(git help -a|egrep '^  [a-zA-Z0-9]');
    do
        case $i in 
            *--*)
                : helper pattern
            ;;
            *)
                echo $i
            ;;
        esac;
    done
}
__git_list_merge_strategies () 
{ 
    git merge -s help 2>&1 | sed -n -e '/[Aa]vailable strategies are: /,/^$/{
		s/\.$//
		s/.*://
		s/^[ 	]*//
		s/[ 	]*$//
		p
	}'
}
__git_list_porcelain_commands () 
{ 
    local i IFS=" "'
';
    __git_compute_all_commands;
    for i in "help" $__git_all_commands;
    do
        case $i in 
            *--*)
                : helper pattern
            ;;
            applymbox)
                : ask gittus
            ;;
            applypatch)
                : ask gittus
            ;;
            archimport)
                : import
            ;;
            cat-file)
                : plumbing
            ;;
            check-attr)
                : plumbing
            ;;
            check-ref-format)
                : plumbing
            ;;
            checkout-index)
                : plumbing
            ;;
            commit-tree)
                : plumbing
            ;;
            count-objects)
                : infrequent
            ;;
            cvsexportcommit)
                : export
            ;;
            cvsimport)
                : import
            ;;
            cvsserver)
                : daemon
            ;;
            daemon)
                : daemon
            ;;
            diff-files)
                : plumbing
            ;;
            diff-index)
                : plumbing
            ;;
            diff-tree)
                : plumbing
            ;;
            fast-import)
                : import
            ;;
            fast-export)
                : export
            ;;
            fsck-objects)
                : plumbing
            ;;
            fetch-pack)
                : plumbing
            ;;
            fmt-merge-msg)
                : plumbing
            ;;
            for-each-ref)
                : plumbing
            ;;
            hash-object)
                : plumbing
            ;;
            http-*)
                : transport
            ;;
            index-pack)
                : plumbing
            ;;
            init-db)
                : deprecated
            ;;
            local-fetch)
                : plumbing
            ;;
            lost-found)
                : infrequent
            ;;
            ls-files)
                : plumbing
            ;;
            ls-remote)
                : plumbing
            ;;
            ls-tree)
                : plumbing
            ;;
            mailinfo)
                : plumbing
            ;;
            mailsplit)
                : plumbing
            ;;
            merge-*)
                : plumbing
            ;;
            mktree)
                : plumbing
            ;;
            mktag)
                : plumbing
            ;;
            pack-objects)
                : plumbing
            ;;
            pack-redundant)
                : plumbing
            ;;
            pack-refs)
                : plumbing
            ;;
            parse-remote)
                : plumbing
            ;;
            patch-id)
                : plumbing
            ;;
            peek-remote)
                : plumbing
            ;;
            prune)
                : plumbing
            ;;
            prune-packed)
                : plumbing
            ;;
            quiltimport)
                : import
            ;;
            read-tree)
                : plumbing
            ;;
            receive-pack)
                : plumbing
            ;;
            remote-*)
                : transport
            ;;
            repo-config)
                : deprecated
            ;;
            rerere)
                : plumbing
            ;;
            rev-list)
                : plumbing
            ;;
            rev-parse)
                : plumbing
            ;;
            runstatus)
                : plumbing
            ;;
            sh-setup)
                : internal
            ;;
            shell)
                : daemon
            ;;
            show-ref)
                : plumbing
            ;;
            send-pack)
                : plumbing
            ;;
            show-index)
                : plumbing
            ;;
            ssh-*)
                : transport
            ;;
            stripspace)
                : plumbing
            ;;
            symbolic-ref)
                : plumbing
            ;;
            tar-tree)
                : deprecated
            ;;
            unpack-file)
                : plumbing
            ;;
            unpack-objects)
                : plumbing
            ;;
            update-index)
                : plumbing
            ;;
            update-ref)
                : plumbing
            ;;
            update-server-info)
                : daemon
            ;;
            upload-archive)
                : plumbing
            ;;
            upload-pack)
                : plumbing
            ;;
            write-tree)
                : plumbing
            ;;
            var)
                : infrequent
            ;;
            verify-pack)
                : infrequent
            ;;
            verify-tag)
                : plumbing
            ;;
            *)
                echo $i
            ;;
        esac;
    done
}
__git_pretty_aliases () 
{ 
    local i IFS='
';
    for i in $(git --git-dir="$(__gitdir)" config --get-regexp "pretty\..*" 2>/dev/null);
    do
        case "$i" in 
            pretty.*)
                i="${i#pretty.}";
                echo "${i/ */}"
            ;;
        esac;
    done
}
__git_ps1 () 
{ 
    local g="$(__gitdir)";
    if [ -n "$g" ]; then
        local r="";
        local b="";
        if [ -f "$g/rebase-merge/interactive" ]; then
            r="|REBASE-i";
            b="$(cat "$g/rebase-merge/head-name")";
        else
            if [ -d "$g/rebase-merge" ]; then
                r="|REBASE-m";
                b="$(cat "$g/rebase-merge/head-name")";
            else
                if [ -d "$g/rebase-apply" ]; then
                    if [ -f "$g/rebase-apply/rebasing" ]; then
                        r="|REBASE";
                    else
                        if [ -f "$g/rebase-apply/applying" ]; then
                            r="|AM";
                        else
                            r="|AM/REBASE";
                        fi;
                    fi;
                else
                    if [ -f "$g/MERGE_HEAD" ]; then
                        r="|MERGING";
                    else
                        if [ -f "$g/BISECT_LOG" ]; then
                            r="|BISECTING";
                        fi;
                    fi;
                fi;
                b="$(git symbolic-ref HEAD 2>/dev/null)" || { 
                    b="$(
				case "${GIT_PS1_DESCRIBE_STYLE-}" in
				(contains)
					git describe --contains HEAD ;;
				(branch)
					git describe --contains --all HEAD ;;
				(describe)
					git describe HEAD ;;
				(* | default)
					git describe --tags --exact-match HEAD ;;
				esac 2>/dev/null)" || b="$(cut -c1-7 "$g/HEAD" 2>/dev/null)..." || b="unknown";
                    b="($b)"
                };
            fi;
        fi;
        local w="";
        local i="";
        local s="";
        local u="";
        local c="";
        local p="";
        if [ "true" = "$(git rev-parse --is-inside-git-dir 2>/dev/null)" ]; then
            if [ "true" = "$(git rev-parse --is-bare-repository 2>/dev/null)" ]; then
                c="BARE:";
            else
                b="GIT_DIR!";
            fi;
        else
            if [ "true" = "$(git rev-parse --is-inside-work-tree 2>/dev/null)" ]; then
                if [ -n "${GIT_PS1_SHOWDIRTYSTATE-}" ]; then
                    if [ "$(git config --bool bash.showDirtyState)" != "false" ]; then
                        git diff --no-ext-diff --quiet --exit-code || w="*";
                        if git rev-parse --quiet --verify HEAD > /dev/null; then
                            git diff-index --cached --quiet HEAD -- || i="+";
                        else
                            i="#";
                        fi;
                    fi;
                fi;
                if [ -n "${GIT_PS1_SHOWSTASHSTATE-}" ]; then
                    git rev-parse --verify refs/stash > /dev/null 2>&1 && s="$";
                fi;
                if [ -n "${GIT_PS1_SHOWUNTRACKEDFILES-}" ]; then
                    if [ -n "$(git ls-files --others --exclude-standard)" ]; then
                        u="%";
                    fi;
                fi;
                if [ -n "${GIT_PS1_SHOWUPSTREAM-}" ]; then
                    __git_ps1_show_upstream;
                fi;
            fi;
        fi;
        local f="$w$i$s$u";
        printf "${1:- (%s)}" "$c${b##refs/heads/}${f:+ $f}$r$p";
    fi
}
__git_ps1_show_upstream () 
{ 
    local key value;
    local svn_remote=() svn_url_pattern count n;
    local upstream=git legacy="" verbose="";
    while read key value; do
        case "$key" in 
            bash.showupstream)
                GIT_PS1_SHOWUPSTREAM="$value";
                if [[ -z "${GIT_PS1_SHOWUPSTREAM}" ]]; then
                    p="";
                    return;
                fi
            ;;
            svn-remote.*.url)
                svn_remote[ $((${#svn_remote[@]} + 1)) ]="$value";
                svn_url_pattern+="\\|$value";
                upstream=svn+git
            ;;
        esac;
    done < <(git config -z --get-regexp '^(svn-remote\..*\.url|bash\.showupstream)$' 2>/dev/null | tr '\0\n' '\n ');
    for option in ${GIT_PS1_SHOWUPSTREAM};
    do
        case "$option" in 
            git | svn)
                upstream="$option"
            ;;
            verbose)
                verbose=1
            ;;
            legacy)
                legacy=1
            ;;
        esac;
    done;
    case "$upstream" in 
        git)
            upstream="@{upstream}"
        ;;
        svn*)
            local svn_upstream=($(git log --first-parent -1 					--grep="^git-svn-id: \(${svn_url_pattern#??}\)" 2>/dev/null));
            if [[ 0 -ne ${#svn_upstream[@]} ]]; then
                svn_upstream=${svn_upstream[ ${#svn_upstream[@]} - 2 ]};
                svn_upstream=${svn_upstream%@*};
                local n_stop="${#svn_remote[@]}";
                for ((n=1; n <= n_stop; ++n))
                do
                    svn_upstream=${svn_upstream#${svn_remote[$n]}};
                done;
                if [[ -z "$svn_upstream" ]]; then
                    upstream=${GIT_SVN_ID:-git-svn};
                else
                    upstream=${svn_upstream#/};
                fi;
            else
                if [[ "svn+git" = "$upstream" ]]; then
                    upstream="@{upstream}";
                fi;
            fi
        ;;
    esac;
    if [[ -z "$legacy" ]]; then
        count="$(git rev-list --count --left-right 				"$upstream"...HEAD 2>/dev/null)";
    else
        local commits;
        if commits="$(git rev-list --left-right "$upstream"...HEAD 2>/dev/null)"; then
            local commit behind=0 ahead=0;
            for commit in $commits;
            do
                case "$commit" in 
                    "<"*)
                        let ++behind
                    ;;
                    *)
                        let ++ahead
                    ;;
                esac;
            done;
            count="$behind	$ahead";
        else
            count="";
        fi;
    fi;
    if [[ -z "$verbose" ]]; then
        case "$count" in 
            "")
                p=""
            ;;
            "0	0")
                p="="
            ;;
            "0	"*)
                p=">"
            ;;
            *"	0")
                p="<"
            ;;
            *)
                p="<>"
            ;;
        esac;
    else
        case "$count" in 
            "")
                p=""
            ;;
            "0	0")
                p=" u="
            ;;
            "0	"*)
                p=" u+${count#0	}"
            ;;
            *"	0")
                p=" u-${count%	0}"
            ;;
            *)
                p=" u+${count#*	}-${count%	*}"
            ;;
        esac;
    fi
}
__git_reassemble_comp_words_by_ref () 
{ 
    local exclude i j first;
    exclude="${1//[^$COMP_WORDBREAKS]}";
    cword_=$COMP_CWORD;
    if [ -z "$exclude" ]; then
        words_=("${COMP_WORDS[@]}");
        return;
    fi;
    for ((i=0, j=0; i < ${#COMP_WORDS[@]}; i++, j++))
    do
        first=t;
        while [ $i -gt 0 ] && [ -n "${COMP_WORDS[$i]}" ] && [ "${COMP_WORDS[$i]//[^$exclude]}" = "${COMP_WORDS[$i]}" ]; do
            if [ $j -ge 2 ] && [ -n "$first" ]; then
                ((j--));
            fi;
            first=;
            words_[$j]=${words_[j]}${COMP_WORDS[i]};
            if [ $i = $COMP_CWORD ]; then
                cword_=$j;
            fi;
            if (($i < ${#COMP_WORDS[@]} - 1)); then
                ((i++));
            else
                return;
            fi;
        done;
        words_[$j]=${words_[j]}${COMP_WORDS[i]};
        if [ $i = $COMP_CWORD ]; then
            cword_=$j;
        fi;
    done
}
__git_refs () 
{ 
    local i is_hash=y dir="$(__gitdir "${1-}")" track="${2-}";
    local cur format refs;
    _get_comp_words_by_ref -n =: cur;
    if [ -d "$dir" ]; then
        case "$cur" in 
            refs | refs/*)
                format="refname";
                refs="${cur%/*}";
                track=""
            ;;
            *)
                for i in HEAD FETCH_HEAD ORIG_HEAD MERGE_HEAD;
                do
                    if [ -e "$dir/$i" ]; then
                        echo $i;
                    fi;
                done;
                format="refname:short";
                refs="refs/tags refs/heads refs/remotes"
            ;;
        esac;
        git --git-dir="$dir" for-each-ref --format="%($format)" $refs;
        if [ -n "$track" ]; then
            local ref entry;
            git --git-dir="$dir" for-each-ref --shell --format="ref=%(refname:short)" "refs/remotes/" | while read entry; do
                eval "$entry";
                ref="${ref#*/}";
                if [[ "$ref" == "$cur"* ]]; then
                    echo "$ref";
                fi;
            done | uniq -u;
        fi;
        return;
    fi;
    for i in $(git ls-remote "$dir" 2>/dev/null);
    do
        case "$is_hash,$i" in 
            y,*)
                is_hash=n
            ;;
            n,*^{})
                is_hash=y
            ;;
            n,refs/tags/*)
                is_hash=y;
                echo "${i#refs/tags/}"
            ;;
            n,refs/heads/*)
                is_hash=y;
                echo "${i#refs/heads/}"
            ;;
            n,refs/remotes/*)
                is_hash=y;
                echo "${i#refs/remotes/}"
            ;;
            n,*)
                is_hash=y;
                echo "$i"
            ;;
        esac;
    done
}
__git_refs2 () 
{ 
    local i;
    for i in $(__git_refs "$1");
    do
        echo "$i:$i";
    done
}
__git_refs_remotes () 
{ 
    local cmd i is_hash=y;
    for i in $(git ls-remote "$1" 2>/dev/null);
    do
        case "$is_hash,$i" in 
            n,refs/heads/*)
                is_hash=y;
                echo "$i:refs/remotes/$1/${i#refs/heads/}"
            ;;
            y,*)
                is_hash=n
            ;;
            n,*^{})
                is_hash=y
            ;;
            n,refs/tags/*)
                is_hash=y
            ;;
            n,*)
                is_hash=y
            ;;
        esac;
    done
}
__git_remotes () 
{ 
    local i ngoff IFS='
' d="$(__gitdir)";
    shopt -q nullglob || ngoff=1;
    shopt -s nullglob;
    for i in "$d/remotes"/*;
    do
        echo ${i#$d/remotes/};
    done;
    [ "$ngoff" ] && shopt -u nullglob;
    for i in $(git --git-dir="$d" config --get-regexp 'remote\..*\.url' 2>/dev/null);
    do
        i="${i#remote.}";
        echo "${i/.url*/}";
    done
}
__git_tags () 
{ 
    local cmd i is_hash=y dir="$(__gitdir "${1-}")";
    if [ -d "$dir" ]; then
        git --git-dir="$dir" for-each-ref --format='%(refname:short)' refs/tags;
        return;
    fi;
    for i in $(git ls-remote "${1-}" 2>/dev/null);
    do
        case "$is_hash,$i" in 
            y,*)
                is_hash=n
            ;;
            n,*^{})
                is_hash=y
            ;;
            n,refs/tags/*)
                is_hash=y;
                echo "${i#refs/tags/}"
            ;;
            n,*)
                is_hash=y;
                echo "$i"
            ;;
        esac;
    done
}
__gitcomp () 
{ 
    local cur;
    _get_comp_words_by_ref -n =: cur;
    if [ $# -gt 2 ]; then
        cur="$3";
    fi;
    case "$cur" in 
        --*=)
            COMPREPLY=()
        ;;
        *)
            local IFS='
';
            COMPREPLY=($(compgen -P "${2-}" 			-W "$(__gitcomp_1 "${1-}" "${4-}")" 			-- "$cur"))
        ;;
    esac
}
__gitcomp_1 () 
{ 
    local c IFS=' ''	''
';
    for c in $1;
    do
        case "$c$2" in 
            --*=*)
                printf %s'
' "$c$2"
            ;;
            *.)
                printf %s'
' "$c$2"
            ;;
            *)
                printf %s'
' "$c$2 "
            ;;
        esac;
    done
}
__gitdir () 
{ 
    if [ -z "${1-}" ]; then
        if [ -n "${__git_dir-}" ]; then
            echo "$__git_dir";
        else
            if [ -d .git ]; then
                echo .git;
            else
                git rev-parse --git-dir 2> /dev/null;
            fi;
        fi;
    else
        if [ -d "$1/.git" ]; then
            echo "$1/.git";
        else
            echo "$1";
        fi;
    fi
}
__gsettings () 
{ 
    local IFS='
';
    local cur=`_get_cword :`;
    local suggestions=$(gsettings complete "${COMP_LINE}" ${COMP_POINT});
    COMPREPLY=($(compgen -W "$suggestions" -- "$cur"));
    case "$cur" in 
        *:*)
            case "$COMP_WORDBREAKS" in 
                *:*)
                    local colon_word=${cur%${cur##*:}};
                    local i=${#COMPREPLY[*]};
                    while [ $((--i)) -ge 0 ]; do
                        COMPREPLY[$i]=${COMPREPLY[$i]#"$colon_word"};
                    done
                ;;
            esac
        ;;
    esac
}
__gvfs_multiple_uris () 
{ 
    local IFS='
';
    local cur="${COMP_WORDS[COMP_CWORD]}";
    COMPREPLY=($(compgen -W '$(gvfs-ls --show-completions "$cur")' -- ""));
    case "$cur" in 
        *:*)
            case "$COMP_WORDBREAKS" in 
                *:*)
                    colon_prefix=$(echo $cur | sed 's/:[^:]*$/:/' );
                    COMPREPLY=${COMPREPLY##${colon_prefix}}
                ;;
            esac
        ;;
    esac
}
__linux_fstab_unescape () 
{ 
    eval $1="'${!1//\'/\047}'";
    eval $1="'${!1/%\\/\\\\}'";
    eval "$1=$'${!1}'"
}
__ltrim_colon_completions () 
{ 
    if [[ "$1" == *:* && ( ${BASH_VERSINFO[0]} -lt 4 || ( ${BASH_VERSINFO[0]} -ge 4 && "$COMP_WORDBREAKS" == *:* ) ) ]]; then
        local colon_word=${1%${1##*:}};
        local i=${#COMPREPLY[*]};
        while [ $((--i)) -ge 0 ]; do
            COMPREPLY[$i]=${COMPREPLY[$i]#"$colon_word"};
        done;
    fi
}
__reassemble_comp_words_by_ref () 
{ 
    local exclude i j ref;
    if [[ -n $1 ]]; then
        exclude="${1//[^$COMP_WORDBREAKS]}";
    fi;
    eval $3=$COMP_CWORD;
    if [[ -n $exclude ]]; then
        for ((i=0, j=0; i < ${#COMP_WORDS[@]}; i++, j++))
        do
            while [[ $i -gt 0 && -n ${COMP_WORDS[$i]} && ${COMP_WORDS[$i]//[^$exclude]} == ${COMP_WORDS[$i]} ]]; do
                [ $j -ge 2 ] && ((j--));
                ref="$2[$j]";
                eval $2[$j]=\${!ref}\${COMP_WORDS[i]};
                [ $i = $COMP_CWORD ] && eval $3=$j;
                (( $i < ${#COMP_WORDS[@]} - 1)) && ((i++)) || break 2;
            done;
            ref="$2[$j]";
            eval $2[$j]=\${!ref}\${COMP_WORDS[i]};
            [[ $i == $COMP_CWORD ]] && eval $3=$j;
        done;
    else
        eval $2=\( \"\${COMP_WORDS[@]}\" \);
    fi
}
__udisks () 
{ 
    local IFS='
';
    local cur="${COMP_WORDS[COMP_CWORD]}";
    if [ "${COMP_WORDS[$(($COMP_CWORD - 1))]}" = "--show-info" ]; then
        COMPREPLY=($(compgen -W "$(udisks --enumerate-device-files)" -- $cur));
    else
        if [ "${COMP_WORDS[$(($COMP_CWORD - 1))]}" = "--inhibit-polling" ]; then
            COMPREPLY=($(compgen -W "$(udisks --enumerate-device-files)" -- $cur));
        else
            if [ "${COMP_WORDS[$(($COMP_CWORD - 1))]}" = "--mount" ]; then
                COMPREPLY=($(compgen -W "$(udisks --enumerate-device-files)" -- $cur));
            else
                if [ "${COMP_WORDS[$(($COMP_CWORD - 1))]}" = "--unmount" ]; then
                    COMPREPLY=($(compgen -W "$(udisks --enumerate-device-files)" -- $cur));
                else
                    if [ "${COMP_WORDS[$(($COMP_CWORD - 1))]}" = "--detach" ]; then
                        COMPREPLY=($(compgen -W "$(udisks --enumerate-device-files)" -- $cur));
                    else
                        if [ "${COMP_WORDS[$(($COMP_CWORD - 1))]}" = "--eject" ]; then
                            COMPREPLY=($(compgen -W "$(udisks --enumerate-device-files)" -- $cur));
                        else
                            if [ "${COMP_WORDS[$(($COMP_CWORD - 1))]}" = "--ata-smart-refresh" ]; then
                                COMPREPLY=($(compgen -W "$(udisks --enumerate-device-files)" -- $cur));
                            else
                                if [ "${COMP_WORDS[$(($COMP_CWORD - 1))]}" = "--ata-smart-simulate" ]; then
                                    _filedir || return 0;
                                else
                                    if [ "${COMP_WORDS[$(($COMP_CWORD - 1))]}" = "--set-spindown" ]; then
                                        COMPREPLY=($(compgen -W "$(udisks --enumerate-device-files)" -- $cur));
                                    else
                                        if [ "${COMP_WORDS[$(($COMP_CWORD - 1))]}" = "--poll-for-media" ]; then
                                            COMPREPLY=($(compgen -W "$(udisks --enumerate-device-files)" -- $cur));
                                        else
                                            COMPREPLY=($(IFS=: compgen -W "--dump:--inhibit-polling:--inhibit-all-polling:--enumerate:--enumerate-device-files:--monitor:--monitor-detail:--show-info:--help:--mount:--mount-fstype:--mount-options:--unmount:--unmount-options:--detach:--detach-options:--eject:--eject-options:--ata-smart-refresh:--ata-smart-wakeup:--ata-smart-simulate:--set-spindown:--set-spindown-all:--spindown-timeout:--poll-for-media" -- $cur));
                                        fi;
                                    fi;
                                fi;
                            fi;
                        fi;
                    fi;
                fi;
            fi;
        fi;
    fi
}
_abook () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    [[ ${BASH_VERSINFO[0]} -ge 4 && $COMP_CWORD -eq 1 && -z "$cur" ]] && { 
        compopt -o nospace;
        COMPREPLY=("-");
        return 0
    };
    case $cur in 
        -*)
            _longopt abook;
            return 0
        ;;
    esac;
    case $prev in 
        --informat)
            COMPREPLY=($( compgen -W "$(abook --formats |                 sed -n -e 's/^\t\([a-z]*\).*/\1/p' -e '/^$/q')" -- "$cur" ));
            return 0
        ;;
        --outformat)
            COMPREPLY=($( compgen -W "$(abook --formats |                 sed -n -e '/^$/,$s/^\t\([a-z]*\).*/\1/p')" -- "$cur" ));
            return 0
        ;;
        --infile)
            COMPREPLY=($( compgen -W stdin -- "$cur" ));
            _filedir;
            return 0
        ;;
        --outfile)
            COMPREPLY=($( compgen -W stdout -- "$cur" ));
            _filedir;
            return 0
        ;;
        --config | --datafile)
            _filedir;
            return 0
        ;;
    esac
}
_aclocal () 
{ 
    COMPREPLY=();
    local cur prev split=false;
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case "$prev" in 
        --help | --print-ac-dir | --version)
            return 0
        ;;
        --acdir | -I)
            _filedir -d;
            return 0
        ;;
        --output)
            _filedir;
            return 0
        ;;
        --warnings | -W)
            local cats=(syntax unsupported);
            COMPREPLY=($( compgen -W                 '${cats[@]} ${cats[@]/#/no-} all none error' -- "$cur" ));
            return 0
        ;;
    esac;
    $split && return 0;
    _longopt $1
}
_alias () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    case $COMP_LINE in 
        *[^=])
            COMPREPLY=($( compgen -A alias -- "$cur" ))
        ;;
        *=)
            COMPREPLY=("$( alias ${cur%=} 2>/dev/null | sed                 -e 's|^alias '"$cur"'\(.*\)$|\1|' )")
        ;;
    esac
}
_allowed_groups () 
{ 
    if _complete_as_root; then
        local IFS='
';
        COMPREPLY=($( compgen -g -- "$1" ));
    else
        local IFS='
 ';
        COMPREPLY=($( compgen -W             "$( id -Gn 2>/dev/null || groups 2>/dev/null )" -- "$1" ));
    fi
}
_allowed_users () 
{ 
    if _complete_as_root; then
        local IFS='
';
        COMPREPLY=($( compgen -u -- "${1:-$cur}" ));
    else
        local IFS='
 ';
        COMPREPLY=($( compgen -W             "$( id -un 2>/dev/null || whoami 2>/dev/null )" -- "${1:-$cur}" ));
    fi
}
_animate () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    _ImageMagick;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-alpha -authenticate -backdrop \
            -background -bordercolor -borderwidth -channel \
            -coalesce -colormap -colors -colorspace -crop -debug \
            -decipher -define -delay -density -depth -display \
            -dispose -dither -extract -filter -flatten -font \
            -foreground -format -gamma -geometry -help \
            -iconGeometry -iconic -identify -immutable -interlace \
            -interpolate -limit -list -log -loop -map -mattecolor \
            -mattecolor -monitor -monochrome -name -page -pause \
            -quantize -quiet -regard-warnings -remote -repage \
            -resample -resize -respect-parenthesis -rotate \
            -sampling-factor -scenes -seed -set -shared-memory \
            -size -strip -title -transparent-color -treedepth \
            -trim -verbose -version -virtual-pixel -visual \
            -window' -- "$cur" ));
    else
        if [[ "$cur" == +* ]]; then
            COMPREPLY=($( compgen -W '+debug +dither +gamma +map +matte'             -- "$cur" ));
        else
            _filedir;
        fi;
    fi
}
_arch_compgen () 
{ 
    local i r;
    COMPREPLY=($(compgen -W '$*' -- "$cur"));
    for ((i=1; i < ${#COMP_WORDS[@]}-1; i++))
    do
        for r in ${!COMPREPLY[@]};
        do
            if [[ ${COMP_WORDS[i]} = ${COMPREPLY[r]} ]]; then
                unset 'COMPREPLY[r]';
                break;
            fi;
        done;
    done
}
_arch_incomp () 
{ 
    local r="\s-(-${1#* }\s|\w*${1% *})";
    [[ $COMP_LINE =~ $r ]]
}
_arch_ptr2comp () 
{ 
    local list= x y;
    for x in "$@";
    do
        for y in '0 --' '1 -';
        do
            eval 'set -- ${'$x'[${y% *}]}';
            list+=\ ${@/#/${y#* }};
        done;
    done;
    _arch_compgen $list
}
_args () 
{ 
    args=0;
    if [[ "${COMP_WORDS[0]}" == lvm ]]; then
        offset=2;
    else
        offset=1;
    fi;
    for ((i=$offset; i < COMP_CWORD; i++ ))
    do
        if [[ "${COMP_WORDS[i]}" != -* ]]; then
            args=$(($args + 1));
        fi;
    done
}
_aspell () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case $prev in 
        -c | -p | check | --conf | --personal | --repl | --per-conf)
            _filedir;
            return 0
        ;;
        --conf-dir | --data-dir | --dict-dir | --home-dir | --local-data-dir | --prefix)
            _filedir -d;
            return 0
        ;;
        dump | create | merge)
            COMPREPLY=($( compgen -W 'master personal repl' -- "$cur" ));
            return 0
        ;;
        --mode)
            COMPREPLY=($( compgen -W 'none url email sgml tex' -- "$cur" ));
            return 0
        ;;
        --sug-mode)
            COMPREPLY=($( compgen -W 'ultra fast normal bad-speller' -- "$cur" ));
            return 0
        ;;
        --keymapping)
            COMPREPLY=($( compgen -W 'aspell ispell' -- "$cur" ));
            return 0
        ;;
        -d | --master)
            _aspell_dictionary;
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--conf --conf-dir --data-dir --dict-dir \
            --encoding --add-filter --rem-filter --mode \
            --add-extra-dicts --rem-extra-dicts \
            --home-dir --ignore --ignore-accents \
            --dont-ignore-accents --ignore-case --dont-ignore-case \
            --ignore-repl --dont-ignore-repl --jargon --keyboard \
            --lang --language-tag --local-data-dir --master \
            --module --add-module-search-order \
            --rem-module-search-order --per-conf --personal \
            --prefix --repl --run-together --dont-run-together \
            --run-together-limit --run-together-min --save-repl \
            --dont-save-repl --set-prefix --dont-set-prefix --size \
            --spelling --strip-accents --dont-strip-accents \
            --sug-mode --add-word-list-path --rem-word-list-path \
            --backup --dont-backup --reverse --dont-reverse \
            --time --dont-time --keymapping --add-email-quote \
            --rem-email-quote --email-margin --add-tex-command \
            --rem-tex-command --tex-check-comments \
            --dont-tex-check-comments --add-tex-extension \
            --rem-tex-extension --add-sgml-check --rem-sgml-check \
            --add-sgml-extension --rem-sgml-extension' -- "$cur" ));
    else
        COMPREPLY=($( compgen -W 'usage help check pipe list \
            config soundslike filter version dump create merge' -- "$cur" ));
    fi
}
_aspell_dictionary () 
{ 
    local datadir;
    datadir=$( aspell config data-dir 2>/dev/null || echo /usr/lib/aspell );
    COMPREPLY=($( command ls $datadir/*.alias 2>/dev/null ));
    COMPREPLY=(${COMPREPLY[@]%.alias});
    COMPREPLY=(${COMPREPLY[@]#$datadir/});
    COMPREPLY=("${COMPREPLY[@]}" $( aspell dicts 2>/dev/null ));
    COMPREPLY=($( compgen -W '${COMPREPLY[@]}' -- "$cur" ))
}
_autoconf () 
{ 
    COMPREPLY=();
    local cur prev split=false;
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case "$prev" in 
        --help | -h | --version | -V | --trace | -t)
            return 0
        ;;
        --output | -o)
            _filedir;
            return 0
        ;;
        --warnings | -W)
            local cats=(cross obsolete syntax);
            COMPREPLY=($( compgen -W                 '${cats[@]} ${cats[@]/#/no-} all none error' -- "$cur" ));
            return 0
        ;;
        --prepend-include | -B | --include | -I)
            _filedir -d;
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        _longopt $1;
        return;
    fi;
    _filedir '@(ac|in)'
}
_automake () 
{ 
    COMPREPLY=();
    local cur prev split=false;
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case "$prev" in 
        --help | --version)
            return 0
        ;;
        --warnings | -W)
            local cats=(gnu obsolete override portability syntax unsupported);
            COMPREPLY=($( compgen -W                 '${cats[@]} ${cats[@]/#/no-} all none error' -- "$cur" ));
            return 0
        ;;
        --libdir)
            _filedir -d;
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        _longopt $1;
        return;
    fi;
    _filedir
}
_autoreconf () 
{ 
    COMPREPLY=();
    local cur prev split=false;
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case "$prev" in 
        --help | -h | --version | -V)
            return 0
        ;;
        --warnings | -W)
            local cats=(cross gnu obsolete override portability syntax unsupported);
            COMPREPLY=($( compgen -W                 '${cats[@]} ${cats[@]/#/no-} all none error' -- "$cur" ));
            return 0
        ;;
        --prepend-include | -B | --include | -I)
            _filedir -d;
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        _longopt $1;
        return 0;
    fi;
    if [[ $1 == autoheader ]]; then
        _filedir '@(ac|in)';
    else
        _filedir -d;
    fi
}
_autoscan () 
{ 
    COMPREPLY=();
    local cur prev split=false;
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case "$prev" in 
        --help | -h | --version | -V)
            return 0
        ;;
        --prepend-include | -B | --include | -I)
            _filedir -d;
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        _longopt $1;
        return 0;
    fi;
    if [[ $1 == autoupdate ]]; then
        _filedir '@(ac|in)';
    else
        _filedir -d;
    fi
}
_available_interfaces () 
{ 
    local cmd;
    if [ "${1:-}" = -w ]; then
        cmd="iwconfig";
    else
        if [ "${1:-}" = -a ]; then
            cmd="ifconfig";
        else
            cmd="ifconfig -a";
        fi;
    fi;
    COMPREPLY=($( eval PATH="$PATH:/sbin" $cmd 2>/dev/null |         awk '/^[^ \t]/ { print $1 }' ));
    COMPREPLY=($( compgen -W '${COMPREPLY[@]/%[[:punct:]]/}' -- "$cur" ))
}
_badblocks () 
{ 
    COMPREPLY=();
    local cur prev;
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -b | -c | -e | -d | -p | -t)
            return 0
        ;;
        -i | -o)
            _filedir;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-b -c -e -d -f -i -n -o -p -s -t -v'             -- "$cur" ));
        return 0;
    fi;
    cur=${cur:=/dev/};
    _filedir
}
_bzip2 () 
{ 
    local cur prev xspec helpopts;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    helpopts=`_parse_help ${COMP_WORDS[0]}`;
    case $prev in 
        -b | -h | --help | -p)
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W "${helpopts//#/} -2 -3 -4 -5 -6 -7 -8 -9"             -- "$cur" ));
        return 0;
    fi;
    local IFS='
';
    xspec="*.bz2";
    if [[ "$prev" == --* ]]; then
        [[ "$prev" == --decompress || "$prev" == --list || "$prev" == --test ]] && xspec="!"$xspec;
        [[ "$prev" == --compress ]] && xspec=;
    else
        if [[ "$prev" == -* ]]; then
            [[ "$prev" == -*[dt]* ]] && xspec="!"$xspec;
            [[ "$prev" == -*z* ]] && xspec=;
        fi;
    fi;
    _expand || return 0;
    _compopt_o_filenames;
    COMPREPLY=($( compgen -f -X "$xspec" -- "$cur" ) $( compgen -d -- "$cur" ))
}
_bzr_lazy () 
{ 
    unset _bzr;
    eval "$(bzr bash-completion)";
    if [[ $(type -t _bzr) == function ]]; then
        unset _bzr_lazy;
        _bzr;
        return $?;
    else
        return 1;
    fi
}
_cardctl () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    if [ $COMP_CWORD -eq 1 ]; then
        COMPREPLY=($( compgen -W 'status config ident suspend \
            resume reset eject insert scheme' -- "$cur" ));
    fi
}
_cd () 
{ 
    local cur IFS='
' i j k;
    _get_comp_words_by_ref cur;
    if [[ "$cur" == ?(\\)\$* ]]; then
        COMPREPLY=($( compgen -v -P '$' -- "${cur#?(\\)$}" ));
        return 0;
    fi;
    _compopt_o_filenames;
    if [[ -z "${CDPATH:-}" || "$cur" == ?(.)?(.)/* ]]; then
        _filedir -d;
        return 0;
    fi;
    local -r mark_dirs=$(_rl_enabled mark-directories && echo y);
    local -r mark_symdirs=$(_rl_enabled mark-symlinked-directories && echo y);
    for i in ${CDPATH//:/'
'};
    do
        k="${#COMPREPLY[@]}";
        for j in $( compgen -d $i/$cur );
        do
            if [[ ( -n $mark_symdirs && -h $j || -n $mark_dirs && ! -h $j ) && ! -d ${j#$i/} ]]; then
                j="${j}/";
            fi;
            COMPREPLY[k++]=${j#$i/};
        done;
    done;
    _filedir -d;
    if [[ ${#COMPREPLY[@]} -eq 1 ]]; then
        i=${COMPREPLY[0]};
        if [[ "$i" == "$cur" && $i != "*/" ]]; then
            COMPREPLY[0]="${i}/";
        fi;
    fi;
    return 0
}
_cd_devices () 
{ 
    COMPREPLY=("${COMPREPLY[@]}" $( compgen -f -d -X "!*/?([amrs])cd*" -- "${cur:-/dev/}" ))
}
_chage () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case $prev in 
        -d | --lastday | -E | --expiredate | -h | --help | -I | --inactive | -m | --mindays | -M | --maxdays | -W | --warndays)
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--lastday --expiredate --help --inactive \
            --list --mindays --maxdays --warndays' -- "$cur" ));
        return 0;
    fi;
    COMPREPLY=($( compgen -u -- "$cur" ))
}
_chgrp () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    cur=${cur//\\\\/};
    _split_longopt && split=true;
    if [[ "$prev" == --reference ]]; then
        _filedir;
        return 0;
    fi;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        local w opts;
        for w in "${COMP_WORDS[@]}";
        do
            [[ "$w" == -@(R|-recursive) ]] && opts="-H -L -P" && break;
        done;
        COMPREPLY=($( compgen -W '-c -h -f -R -v --changes --dereference \
            --no-dereference --silent --quiet --reference --recursive \
            --verbose --help --version $opts' -- "$cur" ));
        return 0;
    fi;
    if [[ $COMP_CWORD -eq 1 && "$cur" != -* || "$prev" == -* ]]; then
        _allowed_groups;
    else
        _filedir || return 0;
    fi;
    return 0
}
_chown () 
{ 
    local cur prev split=false;
    _get_comp_words_by_ref -n : cur prev;
    _split_longopt && split=true;
    case "$prev" in 
        --from)
            _usergroup;
            return 0
        ;;
        --reference)
            _filedir;
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        local w opts;
        for w in "${COMP_WORDS[@]}";
        do
            [[ "$w" == -@(R|-recursive) ]] && opts="-H -L -P" && break;
        done;
        COMPREPLY=($( compgen -W '-c -h -f -R -v --changes --dereference \
            --no-dereference --from --silent --quiet --reference --recursive \
            --verbose --help --version $opts' -- "$cur" ));
    else
        local args;
        _count_args :;
        if [[ $args == 1 ]]; then
            _usergroup -u;
        else
            _filedir;
        fi;
    fi
}
_chpasswd () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case $prev in 
        -c | --crypt)
            COMPREPLY=($( compgen -W 'DES MD5 NONE SHA256 SHA512'                 -- "$cur" ));
            return 0
        ;;
        -s | --sha-rounds)
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--crypt-method --encrypted \
            --help --md5 --sha-rounds' -- "$cur" ));
        return 0;
    fi
}
_chsh () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        --list-shells | --help | -v | --version)
            return 0
        ;;
        -s | --shell)
            _shells;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* && "$( uname -s )" == @(Linux|GNU|GNU/*) ]]; then
        COMPREPLY=($( compgen -W '--shell --list-shells --help --version'             -- "$cur" ));
    else
        COMPREPLY=($( compgen -u -- "$cur" ));
    fi;
    return 0
}
_command () 
{ 
    local offset i;
    offset=1;
    for ((i=1; i <= COMP_CWORD; i++ ))
    do
        if [[ "${COMP_WORDS[i]}" != -* ]]; then
            offset=$i;
            break;
        fi;
    done;
    _command_offset $offset
}
_command_offset () 
{ 
    local cur func cline cspec noglob cmd i char_offset word_offset _COMMAND_FUNC _COMMAND_FUNC_ARGS;
    word_offset=$1;
    local first_word=${COMP_WORDS[$word_offset]};
    for ((i=0; i <= ${#COMP_LINE}; i++ ))
    do
        if [[ "${COMP_LINE:$i:${#first_word}}" == "$first_word" ]]; then
            char_offset=$i;
            break;
        fi;
    done;
    COMP_LINE=${COMP_LINE:$char_offset};
    COMP_POINT=$(( COMP_POINT - $char_offset ));
    for ((i=0; i <= COMP_CWORD - $word_offset; i++ ))
    do
        COMP_WORDS[i]=${COMP_WORDS[i+$word_offset]};
    done;
    for ((i; i <= COMP_CWORD; i++ ))
    do
        unset COMP_WORDS[i];
    done;
    COMP_CWORD=$(( $COMP_CWORD - $word_offset ));
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    if [[ $COMP_CWORD -eq 0 ]]; then
        _compopt_o_filenames;
        COMPREPLY=($( compgen -c -- "$cur" ));
    else
        cmd=${COMP_WORDS[0]};
        if complete -p ${cmd##*/} &>/dev/null; then
            cspec=$( complete -p ${cmd##*/} );
            if [ "${cspec#* -F }" != "$cspec" ]; then
                func=${cspec#*-F };
                func=${func%% *};
                if [[ ${#COMP_WORDS[@]} -ge 2 ]]; then
                    $func $cmd "${COMP_WORDS[${#COMP_WORDS[@]}-1]}" "${COMP_WORDS[${#COMP_WORDS[@]}-2]}";
                else
                    $func $cmd "${COMP_WORDS[${#COMP_WORDS[@]}-1]}";
                fi;
                if [ "${cspec#*-o }" != "$cspec" ]; then
                    cspec=${cspec#*-o };
                    cspec=${cspec%% *};
                    if [[ "$cspec" != @(dir|file)names ]]; then
                        COMPREPLY=("${COMPREPLY[@]//\\\\:/:}");
                    else
                        _compopt_o_filenames;
                    fi;
                fi;
            else
                if [ -n "$cspec" ]; then
                    cspec=${cspec#complete};
                    cspec=${cspec%%${cmd##*/}};
                    COMPREPLY=($( eval compgen "$cspec" -- "$cur" ));
                fi;
            fi;
        else
            if [ ${#COMPREPLY[@]} -eq 0 ]; then
                _filedir;
            fi;
        fi;
    fi
}
_compare () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    _ImageMagick;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-alpha -authenticate -channel \
            -colorspace -compress -debug -decipher -define \
            -density -depth -encipher -extract -format -fuzz \
            -help -highlight-color -identify -interlace -limit \
            -list -log -metric -monitor -passphrase -profile \
            -quality -quantize -quiet -regard-warnings \
            -respect-parenthesis -sampling-factor -seed -set \
            -size -transparent-color -type -verbose -version \
            -virtual-pixel' -- "$cur" ));
    else
        if [[ "$cur" == +* ]]; then
            COMPREPLY=($( compgen -W '+debug' -- "$cur" ));
        else
            _filedir;
        fi;
    fi
}
_complete () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -o)
            COMPREPLY=($( compgen -W 'bashdefault default dirnames filenames \
                nospace plusdirs' -- "$cur" ));
            return 0
        ;;
        -A)
            COMPREPLY=($( compgen -W 'alias arrayvar binding builtin command \
                directory disabled enabled export file function group \
                helptopic hostname job keyword running service setopt shopt \
                signal stopped user variable' -- "$cur" ));
            return 0
        ;;
        -C)
            COMPREPLY=($( compgen -A command -- "$cur" ));
            return 0
        ;;
        -F)
            COMPREPLY=($( compgen -A function -- "$cur" ));
            return 0
        ;;
        -p | -r)
            COMPREPLY=($( complete -p | sed -e 's|.* ||' ));
            COMPREPLY=($( compgen -W '${COMPREPLY[@]}' -- "$cur" ));
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        local opts="-a -b -c -d -e -f -g -j -k -o -s -u -v -A -G -W -P -S -X";
        [[ $1 != compgen ]] && opts="$opts -F -C";
        COMPREPLY=($( compgen -W "$opts" -- "$cur" ));
    else
        COMPREPLY=($( compgen -A command -- "$cur" ));
    fi
}
_complete_as_root () 
{ 
    [[ $EUID -eq 0 || -n ${root_command:-} ]]
}
_compopt_o_filenames () 
{ 
    type compopt &>/dev/null && compopt -o filenames 2> /dev/null || compgen -f /non-existing-dir/ > /dev/null
}
_composite () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    _ImageMagick;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-affine -alpha -authenticate \
            -blend -blue-primary -border -bordercolor -channel \
            -colors -colorspace -comment -compose -compress \
            -debug -decipher -define -density -depth -displace \
            -display -dispose -dissolve -dither -encipher \
            -encoding -endian -extract -filter -font -format \
            -geometry -gravity -green-primary -help -identify \
            -interlace -interpolate -label -limit -list -log \
            -monitor -monochrome -negate -page -profile -quality \
            -quantize -quiet -red-primary -regard-warnings \
            -repage -resize -respect-parenthesis -rotate \
            -sampling-factor -scene -seed -sharpen -shave -size \
            -stegano -stereo -strip -swap -thumbnail -tile \
            -transform -transparent-color -treedepth -type -units \
            -unsharp -verbose -version -virtual-pixel -watermark \
            -white-point -write' -- "$cur" ));
    else
        if [[ "$cur" == +* ]]; then
            COMPREPLY=($( compgen -W '+compress +debug +dither +endian +label \
            +matte +negate +page +write' -- "$cur" ));
        else
            _filedir;
        fi;
    fi
}
_configure () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case $prev in 
        --*prefix | --*dir)
            _filedir -d
        ;;
    esac;
    $split && return 0;
    [[ "$cur" != -* ]] && return 0;
    if [ -n "$COMP_CONFIGURE_HINTS" ]; then
        COMPREPLY=($( compgen -W "$( $1 --help 2>&1 |             awk '/^  --[A-Za-z]/ { print $1; \
            if ($2 ~ /--[A-Za-z]/) print $2 }' | sed -e 's/[[,].*//g' )"             -- "$cur" ));
    else
        COMPREPLY=($( compgen -W "$( $1 --help 2>&1 |             awk '/^  --[A-Za-z]/ { print $1; \
            if ($2 ~ /--[A-Za-z]/) print $2 }' | sed -e 's/[[,=].*//g' )"             -- "$cur" ));
    fi
}
_configured_interfaces () 
{ 
    if [ -f /etc/debian_version ]; then
        COMPREPLY=($( compgen -W "$( sed -ne 's|^iface \([^ ]\{1,\}\).*$|\1|p'            /etc/network/interfaces )" -- "$cur" ));
    else
        if [ -f /etc/SuSE-release ]; then
            COMPREPLY=($( compgen -W "$( printf '%s\n'             /etc/sysconfig/network/ifcfg-* |             sed -ne 's|.*ifcfg-\(.*\)|\1|p' )" -- "$cur" ));
        else
            if [ -f /etc/pld-release ]; then
                COMPREPLY=($( compgen -W "$( command ls -B             /etc/sysconfig/interfaces |             sed -ne 's|.*ifcfg-\(.*\)|\1|p' )" -- "$cur" ));
            else
                COMPREPLY=($( compgen -W "$( printf '%s\n'             /etc/sysconfig/network-scripts/ifcfg-* |             sed -ne 's|.*ifcfg-\(.*\)|\1|p' )" -- "$cur" ));
            fi;
        fi;
    fi
}
_conjure () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    _ImageMagick;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-debug -help -list -log -monitor -quiet \
            -regard-warnings -seed -verbose -version' -- "$cur" ));
    else
        if [[ "$cur" == +* ]]; then
            COMPREPLY=($( compgen -W '+debug' -- "$cur" ));
        else
            _filedir;
        fi;
    fi
}
_connected_intfs () 
{ 
    COMPREPLY=($( compgen -W "$( ls /var/run/network/interfaces/)" -- $cur ))
}
_connected_prfls () 
{ 
    COMPREPLY=($( compgen -W "$( ls /var/run/network/profiles/ )" -- $cur ))
}
_convert () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    _ImageMagick;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-adaptive-blur -adaptive-resize \
            -adaptive-sharpen -adjoin -affine -alpha -annotate \
            -antialias -append -attenuate -authenticate \
            -auto-orient -average -background -bench -bias \
            -black-point-compensation -black-threshold \
            -blue-primary -blur -border -bordercolor -caption \
            -channel -charcoal -chop -clip -clip-mask -clip-path \
            -clone -clut -coalesce -colorize -colors -colorspace \
            -combine -comment -compose -composite -compress \
            -contrast -contrast-stretch -convolve -crop -cycle \
            -debug -decipher -deconstruct -define -delay -delete \
            -density -depth -despeckle -display -dispose -distort \
            -dither -draw -edge -emboss -encipher -encoding \
            -endian -enhance -equalize -evaluate -extent -extract \
            -family -fill -filter -flatten -flip -floodfill -flop \
            -font -format -frame -fuzz -fx -gamma -gaussian-blur \
            -geometry -gravity -green-primary -help -identify \
            -implode -insert -intent -interlace -interpolate \
            -label -lat -layers -level -limit -linear-stretch \
            -liquid-rescale -list -log -loop -map -mask \
            -mattecolor -median -modulate -monitor -monochrome \
            -morph -mosaic -motion-blur -negate -noise -normalize \
            -opaque -ordered-dither -orient -page -paint -ping \
            -pointsize -polaroid -posterize -preview -print \
            -process -profile -quality -quantize -quiet \
            -radial-blur -raise -random-threshold -recolor \
            -red-primary -regard-warnings -region -render -repage \
            -resample -resize -respect-parenthesis -reverse -roll \
            -rotate -sample -sampling-factor -scale -scene -seed \
            -segment -separate -sepia-tone -set -shade -shadow \
            -sharpen -shave -shear -sigmoidal-contrast -size \
            -sketch -solarize -splice -spread -stretch -strip \
            -stroke -strokewidth -style -swap -swirl -taint \
            -texture -threshold -thumbnail -tile -tile-offset \
            -tint -transform -transparent -transparent-color \
            -transpose -transverse -treedepth -trim -type \
            -undercolor -unique-colors -units -unsharp -verbose \
            -version -view -vignette -virtual-pixel -wave \
            -weight -white-point -white-threshold \
            -write' -- "$cur" ));
    else
        if [[ "$cur" == +* ]]; then
            COMPREPLY=($( compgen -W '+adjoin +append +compress \
            +contrast +debug +dither +endian +gamma +label +map \
            +mask +matte +negate +noise +page +raise +render \
            +write' -- "$cur" ));
        else
            _filedir;
        fi;
    fi
}
_count_args () 
{ 
    local i cword words;
    __reassemble_comp_words_by_ref "$1" words cword;
    args=1;
    for i in "${words[@]:1:cword-1}";
    do
        [[ "$i" != -* ]] && args=$(($args+1));
    done
}
_cpan2dist () 
{ 
    local cur prev packagelist cpandirs;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        --format)
            COMPREPLY=($( compgen -W '$(perl -MCPANPLUS::Dist -e \
                "print map { \"\$_\n\" } CPANPLUS::Dist->dist_types")'                 -- "$cur" ));
            return 0
        ;;
        --banlist | --ignorelist | --modulelist | --logfile)
            _filedir;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--help --skiptest --force --install \
            --verbose --keepsource --makefile --buildprereq \
            --archive --flushcache --defaults --edit-metafile \
            --format --ban --banlist --ignore --ignorelist \
            --modulelist --logfile --timeout --set-config \
            --set-program --dist-opts --default-banlist \
            --default-ignorelist' -- $cur ));
    else
        cpandirs=("$HOME/.cpanplus/" "$HOME/.cpan/source/modules/");
        for dir in ${cpandirs[@]};
        do
            [[ -d "$dir" && -r "$dir/02packages.details.txt.gz" ]] && packagelist="$dir/02packages.details.txt.gz";
        done;
        COMPREPLY=($( zgrep "^${cur//-/::}"             $packagelist 2>/dev/null             | awk '{print $1}' | sed -e 's/::/-/g' ));
    fi
}
_crontab () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -u)
            _allowed_users;
            return 0
        ;;
    esac;
    local i opts=" -u -l -r -e";
    [ "$(uname -s)" = Linux ] && opts="$opts -i";
    [ -e /etc/selinux ] && opts="$opts -s";
    for ((i=0; i < ${#COMP_WORDS[@]}-1; i++ ))
    do
        case "${COMP_WORDS[i]}" in 
            -l)
                opts=${opts// -l -r -e/};
                opts=${opts// -i/};
                opts=${opts// -s/}
            ;;
            -e)
                opts=${opts// -l -r -e/};
                opts=${opts// -i/}
            ;;
            -r)
                opts=${opts// -l -r -e/}
            ;;
            -u)
                opts=${opts// -u/};
                opts=${opts// -i/}
            ;;
            -i | -s)
                opts=${opts// ${COMP_WORDS[i]}/}
            ;;
        esac;
    done;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '$opts' -- "$cur" ));
        return 0;
    fi;
    [[ "${COMP_LINE}" == *\ -@(l|r|e)* ]] || _filedir
}
_cryptsetup () 
{ 
    local cur prev arg;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=`_get_pword`;
    case $prev in 
        --key-file | --master-key-file | --header-backup-file | -d)
            _filedir;
            return 0
        ;;
    esac;
    _get_first_arg;
    if [ -z $arg ]; then
        if [[ "$cur" == -* ]]; then
            COMPREPLY=($( compgen -W '--hash --cipher --verify-passphrase \
                --key-file --master-key-file --key-slot --key-size --size \
                --offset --skip --readonly --iter-time --batch-mode --timeout \
                --tries --align-payload --version' -- "$cur" ));
        else
            COMPREPLY=($( compgen -W 'create remove status resize luksFormat \
                luksOpen luksClose luksSuspend luksResume luksAddKey \
                luksRemoveKey luksKillSlot luksDelKey luksUUID isLuks \
                luksDump luksHeaderBackup luksHeaderRestore' -- "$cur" ));
        fi;
    else
        _count_args;
        case $arg in 
            create)
                case $args in 
                    2)
                        _cryptsetup_name
                    ;;
                    3)
                        _cryptsetup_device
                    ;;
                esac
            ;;
            remove | status | resize | luksClose | luksSuspend | luksResume)
                case $args in 
                    2)
                        _cryptsetup_name
                    ;;
                esac
            ;;
            luksFormat | luksAddKey | luksRemoveKey)
                case $args in 
                    2)
                        _cryptsetup_device
                    ;;
                    3)
                        _filedir
                    ;;
                esac
            ;;
            luksOpen)
                case $args in 
                    2)
                        _cryptsetup_device
                    ;;
                    3)
                        _cryptsetup_name
                    ;;
                esac
            ;;
            luksKillSlot | luksDelKey | luksUUID | isLuks | luksDump)
                case $args in 
                    2)
                        _cryptsetup_device
                    ;;
                esac
            ;;
            luksHeaderBackup | luksHeaderRestore)
                case $args in 
                    2)
                        _cryptsetup_device
                    ;;
                    3)
                        COMPREPLY=('--header-backup-file')
                    ;;
                esac
            ;;
        esac;
    fi;
    return 0
}
_cryptsetup_device () 
{ 
    cur=${cur:=/dev/};
    _filedir
}
_cryptsetup_name () 
{ 
    COMPREPLY=($( compgen -X control -W '$( command ls /dev/mapper )'         -- "$cur" ))
}
_dd () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref -n = cur;
    case $cur in 
        if=* | of=*)
            cur=${cur#*=};
            _filedir;
            return 0
        ;;
        conv=*)
            cur=${cur#*=};
            COMPREPLY=($( compgen -W 'ascii ebcdic ibm block unblock lcase
                notrunc ucase swab noerror sync' -- "$cur" ));
            return 0
        ;;
    esac;
    _expand || return 0;
    COMPREPLY=($( compgen -W '--help --version' -- "$cur" ) $( compgen -W 'bs cbs conv count ibs if obs of seek skip'                            -S '=' -- "$cur" ))
}
_display () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    _ImageMagick;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-alpha -antialias -authenticate \
            -auto-orient -backdrop -background -border \
            -bordercolor -borderwidth -channel -clip \
            -clip-path -coalesce -colormap -colors -colorspace \
            -comment -compress -contrast -crop -debug -decipher \
            -define -delay -density -depth -despeckle -display \
            -dispose -dither -edge -endian -enhance -extract \
            -filter -flatten -flip -flop -font -foreground \
            -format -frame -gamma -geometry -help -iconGeometry \
            -iconic -identify -immutable -interlace -interpolate \
            -label -limit -list -log -loop -map -mattecolor \
            -monitor -monochrome -name -negate -page -profile \
            -quality -quantize -quiet -raise -regard-warnings \
            -remote -repage -resample -resize \
            -respect-parenthesis -roll -rotate -sample \
            -sampling-factor -scenes -seed -segment -set \
            -shared-memory -sharpen -size -strip -texture -title \
            -transparent-color -treedepth -trim -update \
            -usePixmap -verbose -version -virtual-pixel -visual \
            -window -window-group -write' -- "$cur" ));
    else
        if [[ "$cur" == +* ]]; then
            COMPREPLY=($( compgen -W '+compress +contrast +debug +dither \
            +endian +gamma +label +map +matte +negate +page \
            +raise +write' -- "$cur" ));
        else
            _filedir;
        fi;
    fi
}
_django_completion () 
{ 
    COMPREPLY=($( COMP_WORDS="${COMP_WORDS[*]}"                    COMP_CWORD=$COMP_CWORD 	               DJANGO_AUTO_COMPLETE=1 $1 ))
}
_dumpe2fs () 
{ 
    COMPREPLY=();
    local cur prev;
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -o | -V)
            return 0
        ;;
        -i)
            _filedir;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-b -o -f -h -i -x -V' -- "$cur" ));
        return 0;
    fi;
    cur=${cur:=/dev/};
    _filedir
}
_dvd_devices () 
{ 
    COMPREPLY=("${COMPREPLY[@]}" $( compgen -f -d -X "!*/?(r)dvd*" -- "${cur:-/dev/}" ))
}
_e2freefrag () 
{ 
    COMPREPLY=();
    local cur prev;
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -c | -h)
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-c -h' -- "$cur" ));
        return 0;
    fi;
    cur=${cur:=/dev/};
    _filedir
}
_e2label () 
{ 
    COMPREPLY=();
    local cur cword;
    _get_comp_words_by_ref cur cword;
    if [ $cword -eq 1 ]; then
        cur=${cur:=/dev/};
        _filedir;
    fi
}
_expand () 
{ 
    if [[ "$cur" == \~*/* ]]; then
        eval cur=$cur;
    else
        if [[ "$cur" == \~* ]]; then
            cur=${cur#\~};
            COMPREPLY=($( compgen -P '~' -u "$cur" ));
            [ ${#COMPREPLY[@]} -eq 1 ] && eval COMPREPLY[0]=${COMPREPLY[0]};
            return ${#COMPREPLY[@]};
        fi;
    fi
}
_export () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    case $COMP_LINE in 
        *=\$*)
            COMPREPLY=($( compgen -v -P '$' -- "${cur#*=\$}" ))
        ;;
        *[^=])
            COMPREPLY=($( compgen -v -S '=' -- "$cur" ))
        ;;
        *=)
            COMPREPLY=("$( eval echo -n \"$`echo ${cur%=}`\" |
                ( echo -n \'
                  sed -e 's/'\''/'\''\\\'\'''\''/g'
                  echo -n \' ) )")
        ;;
    esac
}
_faillog () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case $prev in 
        -h | --help | -l | --lock-time | -m | --maximum | -t | --time)
            return 0
        ;;
        -u | --user)
            COMPREPLY=($( compgen -u -- "$cur" ));
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--all --help --lock-time \
            --maximum --reset --time --user' -- "$cur" ));
        return 0;
    fi
}
_filedir () 
{ 
    local i IFS='
' xspec;
    _tilde "$cur" || return 0;
    local -a toks;
    local quoted tmp;
    _quote_readline_by_ref "$cur" quoted;
    toks=(${toks[@]-} $(
        compgen -d -- "$quoted" | {
            while read -r tmp; do
                # TODO: I have removed a "[ -n $tmp ] &&" before 'printf ..',
                #       and everything works again. If this bug suddenly
                #       appears again (i.e. "cd /b<TAB>" becomes "cd /"),
                #       remember to check for other similar conditionals (here
                #       and _filedir_xspec()). --David
                printf '%s\n' $tmp
            done
        }
    ));
    if [[ "$1" != -d ]]; then
        [[ ${BASH_VERSINFO[0]} -ge 4 ]] && xspec=${1:+"!*.@($1|${1^^})"} || xspec=${1:+"!*.@($1|$(printf %s $1 | tr '[:lower:]' '[:upper:]'))"};
        toks=(${toks[@]-} $( compgen -f -X "$xspec" -- $quoted));
    fi;
    [ ${#toks[@]} -ne 0 ] && _compopt_o_filenames;
    COMPREPLY=("${COMPREPLY[@]}" "${toks[@]}")
}
_filedir_xspec () 
{ 
    local IFS cur xspec;
    IFS='
';
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    _expand || return 0;
    xspec=$( awk "/^complete[ \t]+.*[ \t]${1##*/}([ \t]|\$)/ { print \$0; exit }"         "$BASH_COMPLETION" );
    xspec=${xspec#*-X };
    xspec=${xspec%% *};
    local -a toks;
    local tmp;
    toks=(${toks[@]-} $(
        compgen -d -- "$(quote_readline "$cur")" | {
        while read -r tmp; do
            # see long TODO comment in _filedir() --David
            printf '%s\n' $tmp
        done
        }
        ));
    eval xspec="${xspec}";
    local matchop=!;
    if [[ $xspec == !* ]]; then
        xspec=${xspec#!};
        matchop=@;
    fi;
    [[ ${BASH_VERSINFO[0]} -ge 4 ]] && xspec="$matchop($xspec|${xspec^^})" || xspec="$matchop($xspec|$(printf %s $xspec | tr '[:lower:]' '[:upper:]'))";
    toks=(${toks[@]-} $(
        eval compgen -f -X "!$xspec" -- "\$(quote_readline "\$cur")" | {
        while read -r tmp; do
            [ -n $tmp ] && printf '%s\n' $tmp
        done
        }
        ));
    [ ${#toks[@]} -ne 0 ] && _compopt_o_filenames;
    COMPREPLY=("${toks[@]}")
}
_filefrag () 
{ 
    COMPREPLY=();
    local cur;
    _get_comp_words_by_ref cur;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-B -b -s -v -x' -- "$cur" ));
        return 0;
    fi;
    _filedir
}
_find () 
{ 
    local cur prev i exprfound onlyonce;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -maxdepth | -mindepth)
            COMPREPLY=($( compgen -W '0 1 2 3 4 5 6 7 8 9' -- "$cur" ));
            return 0
        ;;
        -newer | -anewer | -cnewer | -fls | -fprint | -fprint0 | -fprintf | -name | -iname | -lname | -ilname | -wholename | -iwholename | -samefile)
            _filedir;
            return 0
        ;;
        -fstype)
            _fstypes;
            if [[ "$( uname -s )" == *BSD ]]; then
                COMPREPLY=("${COMPREPLY[@]}" $( compgen -W 'local rdonly' -- "$cur" ));
            fi;
            return 0
        ;;
        -gid)
            _gids;
            return 0
        ;;
        -group)
            COMPREPLY=($( compgen -g -- "$cur" 2>/dev/null));
            return 0
        ;;
        -xtype | -type)
            COMPREPLY=($( compgen -W 'b c d p f l s' -- "$cur" ));
            return 0
        ;;
        -uid)
            _uids;
            return 0
        ;;
        -user)
            COMPREPLY=($( compgen -u -- "$cur" ));
            return 0
        ;;
        -exec | -execdir | -ok | -okdir)
            COMP_WORDS=(COMP_WORDS[0] "$cur");
            COMP_CWORD=1;
            _command;
            return 0
        ;;
        -[acm]min | -[acm]time | -iname | -lname | -wholename | -iwholename | -lwholename | -ilwholename | -inum | -path | -ipath | -regex | -iregex | -links | -perm | -size | -used | -printf | -context)
            return 0
        ;;
        -regextype)
            COMPREPLY=($( compgen -W 'emacs posix-awk posix-basic \
                posix-egrep posix-extended' -- "$cur" ));
            return 0
        ;;
    esac;
    _expand || return 0;
    for i in ${COMP_WORDS[@]};
    do
        [[ "$i" = [-\(\),\!]* ]] && exprfound=1 && break;
    done;
    if [[ "$exprfound" != 1 && "$cur" != [-\(\),\!]* ]]; then
        _filedir -d;
        return 0;
    fi;
    COMPREPLY=($( compgen -W '-daystart -depth -follow -help \
        -ignore_readdir_race -maxdepth -mindepth -mindepth -mount \
        -noignore_readdir_race -noleaf -regextype -version -warn -nowarn \
        -xdev \
        -amin -anewer -atime -cmin -cnewer -ctime -empty -executable -false \
        -fstype -gid -group -ilname -iname -inum -ipath -iregex -iwholename \
        -links -lname -mmin -mtime -name -newer -nogroup -nouser -path -perm \
        -readable -regex -samefile -size -true -type -uid -used -user \
        -wholename -writable -xtype -context \
        -delete -exec -execdir -fls -fprint -fprint0 -fprintf -ls -ok -okdir \
        -print -print0 -printf -prune -quit' -- "$cur" ));
    onlyonce=' -daystart -depth -follow -help -ignore_readdir_race -maxdepth \
       -mindepth -mount -noignore_readdir_race -noleaf -nowarn -regextype \
       -version -warn -xdev ';
    COMPREPLY=($(            (while read -d ' ' i; do
            [[ -z "$i" || "${onlyonce/ ${i%% *} / }" == "$onlyonce" ]] &&
            continue
            # flatten array with spaces on either side,
            # otherwise we cannot grep on word boundaries of
            # first and last word
            COMPREPLY=" ${COMPREPLY[@]} "
            # remove word from list of completions
            COMPREPLY=( ${COMPREPLY/ ${i%% *} / } )
            done
            printf '%s ' "${COMPREPLY[@]}") <<<"${COMP_WORDS[@]}"
          ));
    _filedir;
    return 0
}
_fstypes () 
{ 
    local fss;
    if [ -e /proc/filesystems ]; then
        fss="$( cut -d'	' -f2 /proc/filesystems )
             $( awk '! /\*/ { print $NF }' /etc/filesystems 2>/dev/null )";
    else
        fss="$( awk '/^[ \t]*[^#]/ { print $3 }' /etc/fstab 2>/dev/null )
             $( awk '/^[ \t]*[^#]/ { print $3 }' /etc/mnttab 2>/dev/null )
             $( awk '/^[ \t]*[^#]/ { print $4 }' /etc/vfstab 2>/dev/null )
             $( awk '{ print $1 }' /etc/dfs/fstypes 2>/dev/null )
             $( [ -d /etc/fs ] && command ls /etc/fs )";
    fi;
    [ -n "$fss" ] && COMPREPLY=("${COMPREPLY[@]}" $( compgen -W "$fss" -- "$cur" ))
}
_function () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    if [[ $1 == @(declare|typeset) ]]; then
        if [ "$prev" = -f ]; then
            COMPREPLY=($( compgen -A function -- "$cur" ));
        else
            if [[ "$cur" == -* ]]; then
                COMPREPLY=($( compgen -W '-a -f -F -i -r -x -p' -- "$cur" ));
            fi;
        fi;
    else
        if [ $COMP_CWORD -eq 1 ]; then
            COMPREPLY=($( compgen -A function -- "$cur" ));
        else
            COMPREPLY=("() $( type -- ${COMP_WORDS[1]} | sed -e 1,2d )");
        fi;
    fi
}
_fusermount () 
{ 
    COMPREPLY=();
    local cur prev;
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -h | -V | -o)
            return 0
        ;;
        -u)
            COMPREPLY=($( compgen -W "$( awk                 '{ if ($3 ~ /^fuse\./) print $2 }' /etc/mtab 2>/dev/null )"                 -- "$cur" ));
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-h -V -o -u -q -z' -- "$cur" ));
    else
        _filedir -d;
    fi
}
_gcc () 
{ 
    local cur cc backend;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    _expand || return 0;
    case $1 in 
        gcj)
            backend=jc1
        ;;
        gpc)
            backend=gpc1
        ;;
        *77)
            backend=f771
        ;;
        *)
            backend=cc1
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        cc=$( $1 -print-prog-name=$backend );
        COMPREPLY=($( compgen -W "$( $cc --help 2>/dev/null |            tr '\t' ' ' |            sed -e '/^  *-/!d' -e 's/ *-\([^ ]*\).*/-\1/' |            sort -u )" -- "$cur" ));
    else
        _filedir;
    fi
}
_get_comp_words_by_ref () 
{ 
    local exclude flag i OPTIND=1;
    local cur cword words=();
    local upargs=() upvars=() vcur vcword vprev vwords;
    while getopts "c:i:n:p:w:" flag "$@"; do
        case $flag in 
            c)
                vcur=$OPTARG
            ;;
            i)
                vcword=$OPTARG
            ;;
            n)
                exclude=$OPTARG
            ;;
            p)
                vprev=$OPTARG
            ;;
            w)
                vwords=$OPTARG
            ;;
        esac;
    done;
    while [[ $# -ge $OPTIND ]]; do
        case ${!OPTIND} in 
            cur)
                vcur=cur
            ;;
            prev)
                vprev=prev
            ;;
            cword)
                vcword=cword
            ;;
            words)
                vwords=words
            ;;
            *)
                echo "bash: $FUNCNAME(): \`${!OPTIND}': unknown argument" 1>&2;
                return 1
            ;;
        esac;
        let "OPTIND += 1";
    done;
    __get_cword_at_cursor_by_ref "$exclude" words cword cur;
    [[ -n $vcur ]] && { 
        upvars+=("$vcur");
        upargs+=(-v $vcur "$cur")
    };
    [[ -n $vcword ]] && { 
        upvars+=("$vcword");
        upargs+=(-v $vcword "$cword")
    };
    [[ -n $vprev ]] && { 
        upvars+=("$vprev");
        upargs+=(-v $vprev "${words[cword - 1]}")
    };
    [[ -n $vwords ]] && { 
        upvars+=("$vwords");
        upargs+=(-a${#words[@]} $vwords "${words[@]}")
    };
    (( ${#upvars[@]} )) && local "${upvars[@]}" && _upvars "${upargs[@]}"
}
_get_cword () 
{ 
    local LC_CTYPE=C;
    local cword words;
    __reassemble_comp_words_by_ref "$1" words cword;
    if [[ -n ${2//[^0-9]/} ]]; then
        printf "%s" "${words[cword-$2]}";
    else
        if [[ "${#words[cword]}" -eq 0 || "$COMP_POINT" == "${#COMP_LINE}" ]]; then
            printf "%s" "${words[cword]}";
        else
            local i;
            local cur="$COMP_LINE";
            local index="$COMP_POINT";
            for ((i = 0; i <= cword; ++i ))
            do
                while [[ "${#cur}" -ge ${#words[i]} && "${cur:0:${#words[i]}}" != "${words[i]}" ]]; do
                    cur="${cur:1}";
                    ((index--));
                done;
                if [[ "$i" -lt "$cword" ]]; then
                    local old_size="${#cur}";
                    cur="${cur#${words[i]}}";
                    local new_size="${#cur}";
                    index=$(( index - old_size + new_size ));
                fi;
            done;
            if [[ "${words[cword]:0:${#cur}}" != "$cur" ]]; then
                printf "%s" "${words[cword]}";
            else
                printf "%s" "${cur:0:$index}";
            fi;
        fi;
    fi
}
_get_first_arg () 
{ 
    local i;
    arg=;
    for ((i=1; i < COMP_CWORD; i++ ))
    do
        if [[ "${COMP_WORDS[i]}" != -* ]]; then
            arg=${COMP_WORDS[i]};
            break;
        fi;
    done
}
_get_pword () 
{ 
    if [ $COMP_CWORD -ge 1 ]; then
        _get_cword "${@:-}" 1;
    fi
}
_getent () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        passwd)
            COMPREPLY=($( compgen -u "$cur"  ));
            return 0
        ;;
        group)
            COMPREPLY=($( compgen -g "$cur"  ));
            return 0
        ;;
        services)
            COMPREPLY=($( compgen -s "$cur"  ));
            return 0
        ;;
        hosts)
            COMPREPLY=($( compgen -A hostname "$cur"  ));
            return 0
        ;;
        protocols | networks | ahosts | ahostsv4 | ahostsv6 | rpc)
            COMPREPLY=($( compgen -W "$( getent "$prev" |                 awk '{ print $1 }' )" -- "$cur" ));
            return 0
        ;;
        aliases | shadow)
            COMPREPLY=($( compgen -W "$( getent "$prev" | cut -d: -f1 )"                 -- "$cur" ));
            return 0
        ;;
    esac;
    if [ $COMP_CWORD -eq 1 ]; then
        COMPREPLY=($( compgen -W 'passwd group hosts services protocols \
            networks ahosts ahostsv4 ahostsv6 aliases ethers netgroup rpc \
            shadow' -- "$cur" ));
    fi
}
_gids () 
{ 
    if type getent &>/dev/null; then
        COMPREPLY=($( compgen -W '$( getent group | cut -d: -f3 )'             -- "$cur" ));
    else
        if type perl &>/dev/null; then
            COMPREPLY=($( compgen -W '$( perl -e '"'"'while (($gid) = (getgrent)[2]) { print $gid . "\n" }'"'"' )' -- "$cur" ));
        else
            COMPREPLY=($( compgen -W '$( cut -d: -f3 /etc/group )' -- "$cur" ));
        fi;
    fi
}
_git () 
{ 
    local i c=1 command __git_dir;
    if [[ -n ${ZSH_VERSION-} ]]; then
        emulate -L bash;
        setopt KSH_TYPESET;
    fi;
    local cur words cword;
    _get_comp_words_by_ref -n =: cur words cword;
    while [ $c -lt $cword ]; do
        i="${words[c]}";
        case "$i" in 
            --git-dir=*)
                __git_dir="${i#--git-dir=}"
            ;;
            --bare)
                __git_dir="."
            ;;
            --version | -p | --paginate)

            ;;
            --help)
                command="help";
                break
            ;;
            *)
                command="$i";
                break
            ;;
        esac;
        c=$((++c));
    done;
    if [ -z "$command" ]; then
        case "$cur" in 
            --*)
                __gitcomp "
			--paginate
			--no-pager
			--git-dir=
			--bare
			--version
			--exec-path
			--html-path
			--work-tree=
			--help
			"
            ;;
            *)
                __git_compute_porcelain_commands;
                __gitcomp "$__git_porcelain_commands $(__git_aliases)"
            ;;
        esac;
        return;
    fi;
    local completion_func="_git_${command//-/_}";
    declare -f $completion_func > /dev/null && $completion_func && return;
    local expansion=$(__git_aliased_command "$command");
    if [ -n "$expansion" ]; then
        completion_func="_git_${expansion//-/_}";
        declare -f $completion_func > /dev/null && $completion_func;
    fi
}
_git_add () 
{ 
    __git_has_doubledash && return;
    local cur;
    _get_comp_words_by_ref -n =: cur;
    case "$cur" in 
        --*)
            __gitcomp "
			--interactive --refresh --patch --update --dry-run
			--ignore-errors --intent-to-add
			";
            return
        ;;
    esac;
    COMPREPLY=()
}
_git_am () 
{ 
    local cur dir="$(__gitdir)";
    _get_comp_words_by_ref -n =: cur;
    if [ -d "$dir"/rebase-apply ]; then
        __gitcomp "--skip --continue --resolved --abort";
        return;
    fi;
    case "$cur" in 
        --whitespace=*)
            __gitcomp "$__git_whitespacelist" "" "${cur##--whitespace=}";
            return
        ;;
        --*)
            __gitcomp "
			--3way --committer-date-is-author-date --ignore-date
			--ignore-whitespace --ignore-space-change
			--interactive --keep --no-utf8 --signoff --utf8
			--whitespace= --scissors
			";
            return
        ;;
    esac;
    COMPREPLY=()
}
_git_apply () 
{ 
    local cur;
    _get_comp_words_by_ref -n =: cur;
    case "$cur" in 
        --whitespace=*)
            __gitcomp "$__git_whitespacelist" "" "${cur##--whitespace=}";
            return
        ;;
        --*)
            __gitcomp "
			--stat --numstat --summary --check --index
			--cached --index-info --reverse --reject --unidiff-zero
			--apply --no-add --exclude=
			--ignore-whitespace --ignore-space-change
			--whitespace= --inaccurate-eof --verbose
			";
            return
        ;;
    esac;
    COMPREPLY=()
}
_git_archive () 
{ 
    local cur;
    _get_comp_words_by_ref -n =: cur;
    case "$cur" in 
        --format=*)
            __gitcomp "$(git archive --list)" "" "${cur##--format=}";
            return
        ;;
        --remote=*)
            __gitcomp "$(__git_remotes)" "" "${cur##--remote=}";
            return
        ;;
        --*)
            __gitcomp "
			--format= --list --verbose
			--prefix= --remote= --exec=
			";
            return
        ;;
    esac;
    __git_complete_file
}
_git_bisect () 
{ 
    __git_has_doubledash && return;
    local subcommands="start bad good skip reset visualize replay log run";
    local subcommand="$(__git_find_on_cmdline "$subcommands")";
    if [ -z "$subcommand" ]; then
        if [ -f "$(__gitdir)"/BISECT_START ]; then
            __gitcomp "$subcommands";
        else
            __gitcomp "replay start";
        fi;
        return;
    fi;
    case "$subcommand" in 
        bad | good | reset | skip | start)
            __gitcomp "$(__git_refs)"
        ;;
        *)
            COMPREPLY=()
        ;;
    esac
}
_git_branch () 
{ 
    local i c=1 only_local_ref="n" has_r="n" cur words cword;
    _get_comp_words_by_ref -n =: cur words cword;
    while [ $c -lt $cword ]; do
        i="${words[c]}";
        case "$i" in 
            -d | -m)
                only_local_ref="y"
            ;;
            -r)
                has_r="y"
            ;;
        esac;
        c=$((++c));
    done;
    case "$cur" in 
        --*)
            __gitcomp "
			--color --no-color --verbose --abbrev= --no-abbrev
			--track --no-track --contains --merged --no-merged
			--set-upstream
			"
        ;;
        *)
            if [ $only_local_ref = "y" -a $has_r = "n" ]; then
                __gitcomp "$(__git_heads)";
            else
                __gitcomp "$(__git_refs)";
            fi
        ;;
    esac
}
_git_bundle () 
{ 
    local words cword;
    _get_comp_words_by_ref -n =: words cword;
    local cmd="${words[2]}";
    case "$cword" in 
        2)
            __gitcomp "create list-heads verify unbundle"
        ;;
        3)

        ;;
        *)
            case "$cmd" in 
                create)
                    __git_complete_revlist
                ;;
            esac
        ;;
    esac
}
_git_checkout () 
{ 
    __git_has_doubledash && return;
    local cur;
    _get_comp_words_by_ref -n =: cur;
    case "$cur" in 
        --conflict=*)
            __gitcomp "diff3 merge" "" "${cur##--conflict=}"
        ;;
        --*)
            __gitcomp "
			--quiet --ours --theirs --track --no-track --merge
			--conflict= --orphan --patch
			"
        ;;
        *)
            local flags="--track --no-track --no-guess" track=1;
            if [ -n "$(__git_find_on_cmdline "$flags")" ]; then
                track='';
            fi;
            __gitcomp "$(__git_refs '' $track)"
        ;;
    esac
}
_git_cherry () 
{ 
    __gitcomp "$(__git_refs)"
}
_git_cherry_pick () 
{ 
    local cur;
    _get_comp_words_by_ref -n =: cur;
    case "$cur" in 
        --*)
            __gitcomp "--edit --no-commit"
        ;;
        *)
            __gitcomp "$(__git_refs)"
        ;;
    esac
}
_git_clean () 
{ 
    __git_has_doubledash && return;
    local cur;
    _get_comp_words_by_ref -n =: cur;
    case "$cur" in 
        --*)
            __gitcomp "--dry-run --quiet";
            return
        ;;
    esac;
    COMPREPLY=()
}
_git_clone () 
{ 
    local cur;
    _get_comp_words_by_ref -n =: cur;
    case "$cur" in 
        --*)
            __gitcomp "
			--local
			--no-hardlinks
			--shared
			--reference
			--quiet
			--no-checkout
			--bare
			--mirror
			--origin
			--upload-pack
			--template=
			--depth
			";
            return
        ;;
    esac;
    COMPREPLY=()
}
_git_commit () 
{ 
    __git_has_doubledash && return;
    local cur;
    _get_comp_words_by_ref -n =: cur;
    case "$cur" in 
        --cleanup=*)
            __gitcomp "default strip verbatim whitespace
			" "" "${cur##--cleanup=}";
            return
        ;;
        --reuse-message=*)
            __gitcomp "$(__git_refs)" "" "${cur##--reuse-message=}";
            return
        ;;
        --reedit-message=*)
            __gitcomp "$(__git_refs)" "" "${cur##--reedit-message=}";
            return
        ;;
        --untracked-files=*)
            __gitcomp "all no normal" "" "${cur##--untracked-files=}";
            return
        ;;
        --*)
            __gitcomp "
			--all --author= --signoff --verify --no-verify
			--edit --amend --include --only --interactive
			--dry-run --reuse-message= --reedit-message=
			--reset-author --file= --message= --template=
			--cleanup= --untracked-files --untracked-files=
			--verbose --quiet
			";
            return
        ;;
    esac;
    COMPREPLY=()
}
_git_config () 
{ 
    local cur prev;
    _get_comp_words_by_ref -n =: cur prev;
    case "$prev" in 
        branch.*.remote)
            __gitcomp "$(__git_remotes)";
            return
        ;;
        branch.*.merge)
            __gitcomp "$(__git_refs)";
            return
        ;;
        remote.*.fetch)
            local remote="${prev#remote.}";
            remote="${remote%.fetch}";
            __gitcomp "$(__git_refs_remotes "$remote")";
            return
        ;;
        remote.*.push)
            local remote="${prev#remote.}";
            remote="${remote%.push}";
            __gitcomp "$(git --git-dir="$(__gitdir)" 			for-each-ref --format='%(refname):%(refname)' 			refs/heads)";
            return
        ;;
        pull.twohead | pull.octopus)
            __git_compute_merge_strategies;
            __gitcomp "$__git_merge_strategies";
            return
        ;;
        color.branch | color.diff | color.interactive | color.showbranch | color.status | color.ui)
            __gitcomp "always never auto";
            return
        ;;
        color.pager)
            __gitcomp "false true";
            return
        ;;
        color.*.*)
            __gitcomp "
			normal black red green yellow blue magenta cyan white
			bold dim ul blink reverse
			";
            return
        ;;
        help.format)
            __gitcomp "man info web html";
            return
        ;;
        log.date)
            __gitcomp "$__git_log_date_formats";
            return
        ;;
        sendemail.aliasesfiletype)
            __gitcomp "mutt mailrc pine elm gnus";
            return
        ;;
        sendemail.confirm)
            __gitcomp "$__git_send_email_confirm_options";
            return
        ;;
        sendemail.suppresscc)
            __gitcomp "$__git_send_email_suppresscc_options";
            return
        ;;
        --get | --get-all | --unset | --unset-all)
            __gitcomp "$(__git_config_get_set_variables)";
            return
        ;;
        *.*)
            COMPREPLY=();
            return
        ;;
    esac;
    case "$cur" in 
        --*)
            __gitcomp "
			--global --system --file=
			--list --replace-all
			--get --get-all --get-regexp
			--add --unset --unset-all
			--remove-section --rename-section
			";
            return
        ;;
        branch.*.*)
            local pfx="${cur%.*}.";
            cur="${cur##*.}";
            __gitcomp "remote merge mergeoptions rebase" "$pfx" "$cur";
            return
        ;;
        branch.*)
            local pfx="${cur%.*}.";
            cur="${cur#*.}";
            __gitcomp "$(__git_heads)" "$pfx" "$cur" ".";
            return
        ;;
        guitool.*.*)
            local pfx="${cur%.*}.";
            cur="${cur##*.}";
            __gitcomp "
			argprompt cmd confirm needsfile noconsole norescan
			prompt revprompt revunmerged title
			" "$pfx" "$cur";
            return
        ;;
        difftool.*.*)
            local pfx="${cur%.*}.";
            cur="${cur##*.}";
            __gitcomp "cmd path" "$pfx" "$cur";
            return
        ;;
        man.*.*)
            local pfx="${cur%.*}.";
            cur="${cur##*.}";
            __gitcomp "cmd path" "$pfx" "$cur";
            return
        ;;
        mergetool.*.*)
            local pfx="${cur%.*}.";
            cur="${cur##*.}";
            __gitcomp "cmd path trustExitCode" "$pfx" "$cur";
            return
        ;;
        pager.*)
            local pfx="${cur%.*}.";
            cur="${cur#*.}";
            __git_compute_all_commands;
            __gitcomp "$__git_all_commands" "$pfx" "$cur";
            return
        ;;
        remote.*.*)
            local pfx="${cur%.*}.";
            cur="${cur##*.}";
            __gitcomp "
			url proxy fetch push mirror skipDefaultUpdate
			receivepack uploadpack tagopt pushurl
			" "$pfx" "$cur";
            return
        ;;
        remote.*)
            local pfx="${cur%.*}.";
            cur="${cur#*.}";
            __gitcomp "$(__git_remotes)" "$pfx" "$cur" ".";
            return
        ;;
        url.*.*)
            local pfx="${cur%.*}.";
            cur="${cur##*.}";
            __gitcomp "insteadOf pushInsteadOf" "$pfx" "$cur";
            return
        ;;
    esac;
    __gitcomp "
		add.ignoreErrors
		advice.commitBeforeMerge
		advice.detachedHead
		advice.implicitIdentity
		advice.pushNonFastForward
		advice.resolveConflict
		advice.statusHints
		alias.
		am.keepcr
		apply.ignorewhitespace
		apply.whitespace
		branch.autosetupmerge
		branch.autosetuprebase
		browser.
		clean.requireForce
		color.branch
		color.branch.current
		color.branch.local
		color.branch.plain
		color.branch.remote
		color.decorate.HEAD
		color.decorate.branch
		color.decorate.remoteBranch
		color.decorate.stash
		color.decorate.tag
		color.diff
		color.diff.commit
		color.diff.frag
		color.diff.func
		color.diff.meta
		color.diff.new
		color.diff.old
		color.diff.plain
		color.diff.whitespace
		color.grep
		color.grep.context
		color.grep.filename
		color.grep.function
		color.grep.linenumber
		color.grep.match
		color.grep.selected
		color.grep.separator
		color.interactive
		color.interactive.error
		color.interactive.header
		color.interactive.help
		color.interactive.prompt
		color.pager
		color.showbranch
		color.status
		color.status.added
		color.status.changed
		color.status.header
		color.status.nobranch
		color.status.untracked
		color.status.updated
		color.ui
		commit.status
		commit.template
		core.abbrevguard
		core.askpass
		core.attributesfile
		core.autocrlf
		core.bare
		core.bigFileThreshold
		core.compression
		core.createObject
		core.deltaBaseCacheLimit
		core.editor
		core.eol
		core.excludesfile
		core.fileMode
		core.fsyncobjectfiles
		core.gitProxy
		core.ignoreCygwinFSTricks
		core.ignoreStat
		core.ignorecase
		core.logAllRefUpdates
		core.loosecompression
		core.notesRef
		core.packedGitLimit
		core.packedGitWindowSize
		core.pager
		core.preferSymlinkRefs
		core.preloadindex
		core.quotepath
		core.repositoryFormatVersion
		core.safecrlf
		core.sharedRepository
		core.sparseCheckout
		core.symlinks
		core.trustctime
		core.warnAmbiguousRefs
		core.whitespace
		core.worktree
		diff.autorefreshindex
		diff.external
		diff.ignoreSubmodules
		diff.mnemonicprefix
		diff.noprefix
		diff.renameLimit
		diff.renames
		diff.suppressBlankEmpty
		diff.tool
		diff.wordRegex
		difftool.
		difftool.prompt
		fetch.recurseSubmodules
		fetch.unpackLimit
		format.attach
		format.cc
		format.headers
		format.numbered
		format.pretty
		format.signature
		format.signoff
		format.subjectprefix
		format.suffix
		format.thread
		format.to
		gc.
		gc.aggressiveWindow
		gc.auto
		gc.autopacklimit
		gc.packrefs
		gc.pruneexpire
		gc.reflogexpire
		gc.reflogexpireunreachable
		gc.rerereresolved
		gc.rerereunresolved
		gitcvs.allbinary
		gitcvs.commitmsgannotation
		gitcvs.dbTableNamePrefix
		gitcvs.dbdriver
		gitcvs.dbname
		gitcvs.dbpass
		gitcvs.dbuser
		gitcvs.enabled
		gitcvs.logfile
		gitcvs.usecrlfattr
		guitool.
		gui.blamehistoryctx
		gui.commitmsgwidth
		gui.copyblamethreshold
		gui.diffcontext
		gui.encoding
		gui.fastcopyblame
		gui.matchtrackingbranch
		gui.newbranchtemplate
		gui.pruneduringfetch
		gui.spellingdictionary
		gui.trustmtime
		help.autocorrect
		help.browser
		help.format
		http.lowSpeedLimit
		http.lowSpeedTime
		http.maxRequests
		http.minSessions
		http.noEPSV
		http.postBuffer
		http.proxy
		http.sslCAInfo
		http.sslCAPath
		http.sslCert
		http.sslCertPasswordProtected
		http.sslKey
		http.sslVerify
		http.useragent
		i18n.commitEncoding
		i18n.logOutputEncoding
		imap.authMethod
		imap.folder
		imap.host
		imap.pass
		imap.port
		imap.preformattedHTML
		imap.sslverify
		imap.tunnel
		imap.user
		init.templatedir
		instaweb.browser
		instaweb.httpd
		instaweb.local
		instaweb.modulepath
		instaweb.port
		interactive.singlekey
		log.date
		log.decorate
		log.showroot
		mailmap.file
		man.
		man.viewer
		merge.
		merge.conflictstyle
		merge.log
		merge.renameLimit
		merge.renormalize
		merge.stat
		merge.tool
		merge.verbosity
		mergetool.
		mergetool.keepBackup
		mergetool.keepTemporaries
		mergetool.prompt
		notes.displayRef
		notes.rewrite.
		notes.rewrite.amend
		notes.rewrite.rebase
		notes.rewriteMode
		notes.rewriteRef
		pack.compression
		pack.deltaCacheLimit
		pack.deltaCacheSize
		pack.depth
		pack.indexVersion
		pack.packSizeLimit
		pack.threads
		pack.window
		pack.windowMemory
		pager.
		pretty.
		pull.octopus
		pull.twohead
		push.default
		rebase.autosquash
		rebase.stat
		receive.autogc
		receive.denyCurrentBranch
		receive.denyDeleteCurrent
		receive.denyDeletes
		receive.denyNonFastForwards
		receive.fsckObjects
		receive.unpackLimit
		receive.updateserverinfo
		remotes.
		repack.usedeltabaseoffset
		rerere.autoupdate
		rerere.enabled
		sendemail.
		sendemail.aliasesfile
		sendemail.aliasfiletype
		sendemail.bcc
		sendemail.cc
		sendemail.cccmd
		sendemail.chainreplyto
		sendemail.confirm
		sendemail.envelopesender
		sendemail.from
		sendemail.identity
		sendemail.multiedit
		sendemail.signedoffbycc
		sendemail.smtpdomain
		sendemail.smtpencryption
		sendemail.smtppass
		sendemail.smtpserver
		sendemail.smtpserveroption
		sendemail.smtpserverport
		sendemail.smtpuser
		sendemail.suppresscc
		sendemail.suppressfrom
		sendemail.thread
		sendemail.to
		sendemail.validate
		showbranch.default
		status.relativePaths
		status.showUntrackedFiles
		status.submodulesummary
		submodule.
		tar.umask
		transfer.unpackLimit
		url.
		user.email
		user.name
		user.signingkey
		web.browser
		branch. remote.
	"
}
_git_describe () 
{ 
    local cur;
    _get_comp_words_by_ref -n =: cur;
    case "$cur" in 
        --*)
            __gitcomp "
			--all --tags --contains --abbrev= --candidates=
			--exact-match --debug --long --match --always
			";
            return
        ;;
    esac;
    __gitcomp "$(__git_refs)"
}
_git_diff () 
{ 
    __git_has_doubledash && return;
    local cur;
    _get_comp_words_by_ref -n =: cur;
    case "$cur" in 
        --*)
            __gitcomp "--cached --staged --pickaxe-all --pickaxe-regex
			--base --ours --theirs --no-index
			$__git_diff_common_options
			";
            return
        ;;
    esac;
    __git_complete_file
}
_git_difftool () 
{ 
    __git_has_doubledash && return;
    local cur;
    _get_comp_words_by_ref -n =: cur;
    case "$cur" in 
        --tool=*)
            __gitcomp "$__git_mergetools_common kompare" "" "${cur##--tool=}";
            return
        ;;
        --*)
            __gitcomp "--cached --staged --pickaxe-all --pickaxe-regex
			--base --ours --theirs
			--no-renames --diff-filter= --find-copies-harder
			--relative --ignore-submodules
			--tool=";
            return
        ;;
    esac;
    __git_complete_file
}
_git_fetch () 
{ 
    local cur;
    _get_comp_words_by_ref -n =: cur;
    case "$cur" in 
        --*)
            __gitcomp "$__git_fetch_options";
            return
        ;;
    esac;
    __git_complete_remote_or_refspec
}
_git_format_patch () 
{ 
    local cur;
    _get_comp_words_by_ref -n =: cur;
    case "$cur" in 
        --thread=*)
            __gitcomp "
			deep shallow
			" "" "${cur##--thread=}";
            return
        ;;
        --*)
            __gitcomp "
			--stdout --attach --no-attach --thread --thread=
			--output-directory
			--numbered --start-number
			--numbered-files
			--keep-subject
			--signoff --signature --no-signature
			--in-reply-to= --cc=
			--full-index --binary
			--not --all
			--cover-letter
			--no-prefix --src-prefix= --dst-prefix=
			--inline --suffix= --ignore-if-in-upstream
			--subject-prefix=
			";
            return
        ;;
    esac;
    __git_complete_revlist
}
_git_fsck () 
{ 
    local cur;
    _get_comp_words_by_ref -n =: cur;
    case "$cur" in 
        --*)
            __gitcomp "
			--tags --root --unreachable --cache --no-reflogs --full
			--strict --verbose --lost-found
			";
            return
        ;;
    esac;
    COMPREPLY=()
}
_git_gc () 
{ 
    local cur;
    _get_comp_words_by_ref -n =: cur;
    case "$cur" in 
        --*)
            __gitcomp "--prune --aggressive";
            return
        ;;
    esac;
    COMPREPLY=()
}
_git_gitk () 
{ 
    _gitk
}
_git_grep () 
{ 
    __git_has_doubledash && return;
    local cur;
    _get_comp_words_by_ref -n =: cur;
    case "$cur" in 
        --*)
            __gitcomp "
			--cached
			--text --ignore-case --word-regexp --invert-match
			--full-name
			--extended-regexp --basic-regexp --fixed-strings
			--files-with-matches --name-only
			--files-without-match
			--max-depth
			--count
			--and --or --not --all-match
			";
            return
        ;;
    esac;
    __gitcomp "$(__git_refs)"
}
_git_help () 
{ 
    local cur;
    _get_comp_words_by_ref -n =: cur;
    case "$cur" in 
        --*)
            __gitcomp "--all --info --man --web";
            return
        ;;
    esac;
    __git_compute_all_commands;
    __gitcomp "$__git_all_commands
		attributes cli core-tutorial cvs-migration
		diffcore gitk glossary hooks ignore modules
		repository-layout tutorial tutorial-2
		workflows
		"
}
_git_init () 
{ 
    local cur;
    _get_comp_words_by_ref -n =: cur;
    case "$cur" in 
        --shared=*)
            __gitcomp "
			false true umask group all world everybody
			" "" "${cur##--shared=}";
            return
        ;;
        --*)
            __gitcomp "--quiet --bare --template= --shared --shared=";
            return
        ;;
    esac;
    COMPREPLY=()
}
_git_log () 
{ 
    __git_has_doubledash && return;
    local g="$(git rev-parse --git-dir 2>/dev/null)";
    local merge="";
    if [ -f "$g/MERGE_HEAD" ]; then
        merge="--merge";
    fi;
    local cur;
    _get_comp_words_by_ref -n =: cur;
    case "$cur" in 
        --pretty=*)
            __gitcomp "$__git_log_pretty_formats $(__git_pretty_aliases)
			" "" "${cur##--pretty=}";
            return
        ;;
        --format=*)
            __gitcomp "$__git_log_pretty_formats $(__git_pretty_aliases)
			" "" "${cur##--format=}";
            return
        ;;
        --date=*)
            __gitcomp "$__git_log_date_formats" "" "${cur##--date=}";
            return
        ;;
        --decorate=*)
            __gitcomp "long short" "" "${cur##--decorate=}";
            return
        ;;
        --*)
            __gitcomp "
			$__git_log_common_options
			$__git_log_shortlog_options
			$__git_log_gitk_options
			--root --topo-order --date-order --reverse
			--follow --full-diff
			--abbrev-commit --abbrev=
			--relative-date --date=
			--pretty= --format= --oneline
			--cherry-pick
			--graph
			--decorate --decorate=
			--walk-reflogs
			--parents --children
			$merge
			$__git_diff_common_options
			--pickaxe-all --pickaxe-regex
			";
            return
        ;;
    esac;
    __git_complete_revlist
}
_git_ls_files () 
{ 
    __git_has_doubledash && return;
    local cur;
    _get_comp_words_by_ref -n =: cur;
    case "$cur" in 
        --*)
            __gitcomp "--cached --deleted --modified --others --ignored
			--stage --directory --no-empty-directory --unmerged
			--killed --exclude= --exclude-from=
			--exclude-per-directory= --exclude-standard
			--error-unmatch --with-tree= --full-name
			--abbrev --ignored --exclude-per-directory
			";
            return
        ;;
    esac;
    COMPREPLY=()
}
_git_ls_remote () 
{ 
    __gitcomp "$(__git_remotes)"
}
_git_ls_tree () 
{ 
    __git_complete_file
}
_git_merge () 
{ 
    __git_complete_strategy && return;
    local cur;
    _get_comp_words_by_ref -n =: cur;
    case "$cur" in 
        --*)
            __gitcomp "$__git_merge_options";
            return
        ;;
    esac;
    __gitcomp "$(__git_refs)"
}
_git_merge_base () 
{ 
    __gitcomp "$(__git_refs)"
}
_git_mergetool () 
{ 
    local cur;
    _get_comp_words_by_ref -n =: cur;
    case "$cur" in 
        --tool=*)
            __gitcomp "$__git_mergetools_common tortoisemerge" "" "${cur##--tool=}";
            return
        ;;
        --*)
            __gitcomp "--tool=";
            return
        ;;
    esac;
    COMPREPLY=()
}
_git_mv () 
{ 
    local cur;
    _get_comp_words_by_ref -n =: cur;
    case "$cur" in 
        --*)
            __gitcomp "--dry-run";
            return
        ;;
    esac;
    COMPREPLY=()
}
_git_name_rev () 
{ 
    __gitcomp "--tags --all --stdin"
}
_git_notes () 
{ 
    local subcommands='add append copy edit list prune remove show';
    local subcommand="$(__git_find_on_cmdline "$subcommands")";
    local cur words cword;
    _get_comp_words_by_ref -n =: cur words cword;
    case "$subcommand,$cur" in 
        ,--*)
            __gitcomp '--ref'
        ;;
        ,*)
            case "${words[cword-1]}" in 
                --ref)
                    __gitcomp "$(__git_refs)"
                ;;
                *)
                    __gitcomp "$subcommands --ref"
                ;;
            esac
        ;;
        add,--reuse-message=* | append,--reuse-message=*)
            __gitcomp "$(__git_refs)" "" "${cur##--reuse-message=}"
        ;;
        add,--reedit-message=* | append,--reedit-message=*)
            __gitcomp "$(__git_refs)" "" "${cur##--reedit-message=}"
        ;;
        add,--* | append,--*)
            __gitcomp '--file= --message= --reedit-message=
				--reuse-message='
        ;;
        copy,--*)
            __gitcomp '--stdin'
        ;;
        prune,--*)
            __gitcomp '--dry-run --verbose'
        ;;
        prune,*)

        ;;
        *)
            case "${words[cword-1]}" in 
                -m | -F)

                ;;
                *)
                    __gitcomp "$(__git_refs)"
                ;;
            esac
        ;;
    esac
}
_git_pull () 
{ 
    __git_complete_strategy && return;
    local cur;
    _get_comp_words_by_ref -n =: cur;
    case "$cur" in 
        --*)
            __gitcomp "
			--rebase --no-rebase
			$__git_merge_options
			$__git_fetch_options
		";
            return
        ;;
    esac;
    __git_complete_remote_or_refspec
}
_git_push () 
{ 
    local cur prev;
    _get_comp_words_by_ref -n =: cur prev;
    case "$prev" in 
        --repo)
            __gitcomp "$(__git_remotes)";
            return
        ;;
    esac;
    case "$cur" in 
        --repo=*)
            __gitcomp "$(__git_remotes)" "" "${cur##--repo=}";
            return
        ;;
        --*)
            __gitcomp "
			--all --mirror --tags --dry-run --force --verbose
			--receive-pack= --repo=
		";
            return
        ;;
    esac;
    __git_complete_remote_or_refspec
}
_git_rebase () 
{ 
    local dir="$(__gitdir)";
    local cur;
    _get_comp_words_by_ref -n =: cur;
    if [ -d "$dir"/rebase-apply ] || [ -d "$dir"/rebase-merge ]; then
        __gitcomp "--continue --skip --abort";
        return;
    fi;
    __git_complete_strategy && return;
    case "$cur" in 
        --whitespace=*)
            __gitcomp "$__git_whitespacelist" "" "${cur##--whitespace=}";
            return
        ;;
        --*)
            __gitcomp "
			--onto --merge --strategy --interactive
			--preserve-merges --stat --no-stat
			--committer-date-is-author-date --ignore-date
			--ignore-whitespace --whitespace=
			--autosquash
			";
            return
        ;;
    esac;
    __gitcomp "$(__git_refs)"
}
_git_reflog () 
{ 
    local subcommands="show delete expire";
    local subcommand="$(__git_find_on_cmdline "$subcommands")";
    if [ -z "$subcommand" ]; then
        __gitcomp "$subcommands";
    else
        __gitcomp "$(__git_refs)";
    fi
}
_git_remote () 
{ 
    local subcommands="add rename rm show prune update set-head";
    local subcommand="$(__git_find_on_cmdline "$subcommands")";
    if [ -z "$subcommand" ]; then
        __gitcomp "$subcommands";
        return;
    fi;
    case "$subcommand" in 
        rename | rm | show | prune)
            __gitcomp "$(__git_remotes)"
        ;;
        update)
            local i c='' IFS='
';
            for i in $(git --git-dir="$(__gitdir)" config --get-regexp "remotes\..*" 2>/dev/null);
            do
                i="${i#remotes.}";
                c="$c ${i/ */}";
            done;
            __gitcomp "$c"
        ;;
        *)
            COMPREPLY=()
        ;;
    esac
}
_git_replace () 
{ 
    __gitcomp "$(__git_refs)"
}
_git_reset () 
{ 
    __git_has_doubledash && return;
    local cur;
    _get_comp_words_by_ref -n =: cur;
    case "$cur" in 
        --*)
            __gitcomp "--merge --mixed --hard --soft --patch";
            return
        ;;
    esac;
    __gitcomp "$(__git_refs)"
}
_git_revert () 
{ 
    local cur;
    _get_comp_words_by_ref -n =: cur;
    case "$cur" in 
        --*)
            __gitcomp "--edit --mainline --no-edit --no-commit --signoff";
            return
        ;;
    esac;
    __gitcomp "$(__git_refs)"
}
_git_rm () 
{ 
    __git_has_doubledash && return;
    local cur;
    _get_comp_words_by_ref -n =: cur;
    case "$cur" in 
        --*)
            __gitcomp "--cached --dry-run --ignore-unmatch --quiet";
            return
        ;;
    esac;
    COMPREPLY=()
}
_git_send_email () 
{ 
    local cur;
    _get_comp_words_by_ref -n =: cur;
    case "$cur" in 
        --confirm=*)
            __gitcomp "
			$__git_send_email_confirm_options
			" "" "${cur##--confirm=}";
            return
        ;;
        --suppress-cc=*)
            __gitcomp "
			$__git_send_email_suppresscc_options
			" "" "${cur##--suppress-cc=}";
            return
        ;;
        --smtp-encryption=*)
            __gitcomp "ssl tls" "" "${cur##--smtp-encryption=}";
            return
        ;;
        --*)
            __gitcomp "--annotate --bcc --cc --cc-cmd --chain-reply-to
			--compose --confirm= --dry-run --envelope-sender
			--from --identity
			--in-reply-to --no-chain-reply-to --no-signed-off-by-cc
			--no-suppress-from --no-thread --quiet
			--signed-off-by-cc --smtp-pass --smtp-server
			--smtp-server-port --smtp-encryption= --smtp-user
			--subject --suppress-cc= --suppress-from --thread --to
			--validate --no-validate";
            return
        ;;
    esac;
    COMPREPLY=()
}
_git_shortlog () 
{ 
    __git_has_doubledash && return;
    local cur;
    _get_comp_words_by_ref -n =: cur;
    case "$cur" in 
        --*)
            __gitcomp "
			$__git_log_common_options
			$__git_log_shortlog_options
			--numbered --summary
			";
            return
        ;;
    esac;
    __git_complete_revlist
}
_git_show () 
{ 
    __git_has_doubledash && return;
    local cur;
    _get_comp_words_by_ref -n =: cur;
    case "$cur" in 
        --pretty=*)
            __gitcomp "$__git_log_pretty_formats $(__git_pretty_aliases)
			" "" "${cur##--pretty=}";
            return
        ;;
        --format=*)
            __gitcomp "$__git_log_pretty_formats $(__git_pretty_aliases)
			" "" "${cur##--format=}";
            return
        ;;
        --*)
            __gitcomp "--pretty= --format= --abbrev-commit --oneline
			$__git_diff_common_options
			";
            return
        ;;
    esac;
    __git_complete_file
}
_git_show_branch () 
{ 
    local cur;
    _get_comp_words_by_ref -n =: cur;
    case "$cur" in 
        --*)
            __gitcomp "
			--all --remotes --topo-order --current --more=
			--list --independent --merge-base --no-name
			--color --no-color
			--sha1-name --sparse --topics --reflog
			";
            return
        ;;
    esac;
    __git_complete_revlist
}
_git_stage () 
{ 
    _git_add
}
_git_stash () 
{ 
    local cur;
    _get_comp_words_by_ref -n =: cur;
    local save_opts='--keep-index --no-keep-index --quiet --patch';
    local subcommands='save list show apply clear drop pop create branch';
    local subcommand="$(__git_find_on_cmdline "$subcommands")";
    if [ -z "$subcommand" ]; then
        case "$cur" in 
            --*)
                __gitcomp "$save_opts"
            ;;
            *)
                if [ -z "$(__git_find_on_cmdline "$save_opts")" ]; then
                    __gitcomp "$subcommands";
                else
                    COMPREPLY=();
                fi
            ;;
        esac;
    else
        case "$subcommand,$cur" in 
            save,--*)
                __gitcomp "$save_opts"
            ;;
            apply,--* | pop,--*)
                __gitcomp "--index --quiet"
            ;;
            show,--* | drop,--* | branch,--*)
                COMPREPLY=()
            ;;
            show,* | apply,* | drop,* | pop,* | branch,*)
                __gitcomp "$(git --git-dir="$(__gitdir)" stash list 					| sed -n -e 's/:.*//p')"
            ;;
            *)
                COMPREPLY=()
            ;;
        esac;
    fi
}
_git_submodule () 
{ 
    __git_has_doubledash && return;
    local subcommands="add status init update summary foreach sync";
    if [ -z "$(__git_find_on_cmdline "$subcommands")" ]; then
        local cur;
        _get_comp_words_by_ref -n =: cur;
        case "$cur" in 
            --*)
                __gitcomp "--quiet --cached"
            ;;
            *)
                __gitcomp "$subcommands"
            ;;
        esac;
        return;
    fi
}
_git_svn () 
{ 
    local subcommands="
		init fetch clone rebase dcommit log find-rev
		set-tree commit-diff info create-ignore propget
		proplist show-ignore show-externals branch tag blame
		migrate mkdirs reset gc
		";
    local subcommand="$(__git_find_on_cmdline "$subcommands")";
    if [ -z "$subcommand" ]; then
        __gitcomp "$subcommands";
    else
        local remote_opts="--username= --config-dir= --no-auth-cache";
        local fc_opts="
			--follow-parent --authors-file= --repack=
			--no-metadata --use-svm-props --use-svnsync-props
			--log-window-size= --no-checkout --quiet
			--repack-flags --use-log-author --localtime
			--ignore-paths= $remote_opts
			";
        local init_opts="
			--template= --shared= --trunk= --tags=
			--branches= --stdlayout --minimize-url
			--no-metadata --use-svm-props --use-svnsync-props
			--rewrite-root= --prefix= --use-log-author
			--add-author-from $remote_opts
			";
        local cmt_opts="
			--edit --rmdir --find-copies-harder --copy-similarity=
			";
        local cur;
        _get_comp_words_by_ref -n =: cur;
        case "$subcommand,$cur" in 
            fetch,--*)
                __gitcomp "--revision= --fetch-all $fc_opts"
            ;;
            clone,--*)
                __gitcomp "--revision= $fc_opts $init_opts"
            ;;
            init,--*)
                __gitcomp "$init_opts"
            ;;
            dcommit,--*)
                __gitcomp "
				--merge --strategy= --verbose --dry-run
				--fetch-all --no-rebase --commit-url
				--revision $cmt_opts $fc_opts
				"
            ;;
            set-tree,--*)
                __gitcomp "--stdin $cmt_opts $fc_opts"
            ;;
            create-ignore,--* | propget,--* | proplist,--* | show-ignore,--* | show-externals,--* | mkdirs,--*)
                __gitcomp "--revision="
            ;;
            log,--*)
                __gitcomp "
				--limit= --revision= --verbose --incremental
				--oneline --show-commit --non-recursive
				--authors-file= --color
				"
            ;;
            rebase,--*)
                __gitcomp "
				--merge --verbose --strategy= --local
				--fetch-all --dry-run $fc_opts
				"
            ;;
            commit-diff,--*)
                __gitcomp "--message= --file= --revision= $cmt_opts"
            ;;
            info,--*)
                __gitcomp "--url"
            ;;
            branch,--*)
                __gitcomp "--dry-run --message --tag"
            ;;
            tag,--*)
                __gitcomp "--dry-run --message"
            ;;
            blame,--*)
                __gitcomp "--git-format"
            ;;
            migrate,--*)
                __gitcomp "
				--config-dir= --ignore-paths= --minimize
				--no-auth-cache --username=
				"
            ;;
            reset,--*)
                __gitcomp "--revision= --parent"
            ;;
            *)
                COMPREPLY=()
            ;;
        esac;
    fi
}
_git_tag () 
{ 
    local i c=1 f=0;
    local words cword prev;
    _get_comp_words_by_ref -n =: words cword prev;
    while [ $c -lt $cword ]; do
        i="${words[c]}";
        case "$i" in 
            -d | -v)
                __gitcomp "$(__git_tags)";
                return
            ;;
            -f)
                f=1
            ;;
        esac;
        c=$((++c));
    done;
    case "$prev" in 
        -m | -F)
            COMPREPLY=()
        ;;
        -* | tag)
            if [ $f = 1 ]; then
                __gitcomp "$(__git_tags)";
            else
                COMPREPLY=();
            fi
        ;;
        *)
            __gitcomp "$(__git_refs)"
        ;;
    esac
}
_git_whatchanged () 
{ 
    _git_log
}
_gitk () 
{ 
    if [[ -n ${ZSH_VERSION-} ]]; then
        emulate -L bash;
        setopt KSH_TYPESET;
    fi;
    __git_has_doubledash && return;
    local cur;
    local g="$(__gitdir)";
    local merge="";
    if [ -f "$g/MERGE_HEAD" ]; then
        merge="--merge";
    fi;
    _get_comp_words_by_ref -n =: cur;
    case "$cur" in 
        --*)
            __gitcomp "
			$__git_log_common_options
			$__git_log_gitk_options
			$merge
			";
            return
        ;;
    esac;
    __git_complete_revlist
}
_gpasswd () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -a | -d | -A | -M)
            COMPREPLY=($( compgen -u -- "$cur" ));
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-a -d -r -R -A -M' -- "$cur" ));
        return 0;
    fi;
    COMPREPLY=($( compgen -g -- "$cur" ))
}
_gpg () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -s | --sign | --clearsign | --decrypt-files | --load-extension)
            _filedir;
            return 0
        ;;
        --export | --sign-key | --lsignkey | --nrsignkey | --nrlsignkey | --editkey)
            COMPREPLY=($( compgen -W "$( gpg --list-keys 2>/dev/null |                 sed -ne 's@^pub.*/\([^ ]*\).*$@\1@p'                     -ne 's@^.*\(<\([^>]*\)>\).*$@\2@p' )" -- "$cur" ));
            return 0
        ;;
        -r | --recipient)
            COMPREPLY=($( compgen -W "$( gpg --list-keys 2>/dev/null |                 sed -ne 's@^.*<\([^>]*\)>.*$@\1@p')" -- "$cur" ));
            if [ -e ~/.gnupg/gpg.conf ]; then
                COMPREPLY=("${COMPREPLY[@]}" $( compgen -W "$( sed -ne                     's@^[ \t]*group[ \t][ \t]*\([^=]*\).*$@\1@p'                     ~/.gnupg/gpg.conf  )" -- "$cur"));
            fi;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '$(gpg --dump-options)' -- "$cur" ));
    fi
}
_gpg2 () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        --homedir)
            _filedir -d;
            return 0
        ;;
        -s | --sign | --clearsign | --options | --decrypt)
            _filedir;
            return 0
        ;;
        --export | --sign-key | --lsign-key | --nrsign-key | --nrlsign-key | --edit-key)
            COMPREPLY=($( compgen -W "$( gpg2 --list-keys 2>/dev/null |                 sed -ne 's@^pub.*/\([^ ]*\).*$@\1@p'                     -ne 's@^.*\(<\([^>]*\)>\).*$@\2@p' )" -- "$cur" ));
            return 0
        ;;
        -r | --recipient)
            COMPREPLY=($( compgen -W "$( gpg2 --list-keys 2>/dev/null |                 sed -ne 's@^.*<\([^>]*\)>.*$@\1@p')" -- "$cur" ));
            if [ -e ~/.gnupg/gpg.conf ]; then
                COMPREPLY=("${COMPREPLY[@]}" $( compgen -W "$( sed -ne                     's@^[ \t]*group[ \t][ \t]*\([^=]*\).*$@\1@p'                     ~/.gnupg/gpg.conf)" -- "$cur"));
            fi;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '$(gpg2 --dump-options)' -- "$cur" ));
    fi
}
_groupadd () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case $prev in 
        -g | --gid | -K | --key | -p | --password)
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--force --gid --help \
            --key --non-unique --password --system' -- "$cur" ));
        return 0;
    fi
}
_groupmems () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -a | -d)
            COMPREPLY=($( compgen -u -- "$cur" ));
            return 0
        ;;
        -g)
            COMPREPLY=($( compgen -g -- "$cur" ));
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-a -d -p -g -l' -- "$cur" ));
        return 0;
    fi
}
_groupmod () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case $prev in 
        -g | --gid | -h | --help | -n | --new-name | -p | --password)
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--gid --help --new-name \
            --non-unique --password' -- "$cur" ));
        return 0;
    fi;
    COMPREPLY=($( compgen -g -- "$cur" ))
}
_grpck () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-r -s' -- "$cur" ));
        return 0;
    fi;
    _filedir
}
_gzip () 
{ 
    local cur prev xspec helpopts;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    helpopts=`_parse_help ${COMP_WORDS[0]}`;
    case $prev in 
        -b | --blocksize | -p | --processes | -S | --suffix | -h | --help | -V | --version)
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W "$helpopts -1 -2 -3 -4 -5 -6 -7 -8 -9"             -- "$cur" ));
        return 0;
    fi;
    local IFS='
';
    xspec="*.@(gz|t[ag]z)";
    if [[ "$prev" == --* ]]; then
        [[ "$prev" == --decompress || "$prev" == --list || "$prev" == --test ]] && xspec="!"$xspec;
        [[ "$prev" == --force ]] && xspec=;
    else
        if [[ "$prev" == -* ]]; then
            [[ "$prev" == -*[dlt]* ]] && xspec="!"$xspec;
            [[ "$prev" == -*f* ]] && xspec=;
        else
            if [[ "$prev" == '>' || "$prev" == '>>' ]]; then
                xspec=;
            else
                if [ "$prev" = '<' ]; then
                    xspec=;
                fi;
            fi;
        fi;
    fi;
    _expand || return 0;
    _compopt_o_filenames;
    COMPREPLY=($( compgen -f -X "$xspec" -- "$cur" ) $( compgen -d -- "$cur" ))
}
_heimdal_encodings () 
{ 
    COMPREPLY=($( compgen -W 'des-cbc-mcrc des-cbc-md4 des-cbc-md5 \
        des3-cbc-sha1 arcfour-hmac-md5 aes128-cts-hmac-sha1-96 \
        aes256-cts-hmac-sha1-96' -- "$cur" ))
}
_heimdal_principals () 
{ 
    COMPREPLY=($( compgen -W "$( kadmin -l dump 2>/dev/null |         awk '{print $1}' )" -- "$cur" ))
}
_heimdal_realms () 
{ 
    COMPREPLY=($( compgen -W "( kadmin -l dump 2>/dev/null |         awk '{print $1}' | awk -F@ '{print $2}' )" -- "$cur" ))
}
_iconv () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case $prev in 
        -'?' | --help | --usage | -V | --version | --unicode-subst | --byte-subst | --widechar-subst)
            return 0
        ;;
        -f | --from-code | -t | --to-code)
            COMPREPLY=($( compgen -W '$( iconv -l | \
                sed -e "s@/*\$@@" -e "s/[,()]//g" )' -- "$cur" ));
            return 0
        ;;
        -o | --output)
            _filedir;
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" = -* ]]; then
        COMPREPLY=($( compgen -W '--from-code --to-code --list -c
            --unicode-subst --byte-subst --widechar-subst --output --silent
            --verbose --help --usage --version' -- "$cur" ));
        return 0;
    fi
}
_id () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-a -g --group -G --groups -n --name\
            -r --real -u --user --help --version' -- "$cur" ));
    else
        COMPREPLY=($( compgen -u "$cur" ));
    fi
}
_identify () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    _ImageMagick;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-alpha -antialias -authenticate \
            -channel -colorspace -crop -debug -define -density \
            -depth -extract -format -fuzz -gamma -help -interlace \
            -interpolate -limit -list -log -monitor -ping -quiet \
            -regard-warnings -respect-parenthesis \
            -sampling-factor -seed -set -size -strip -units \
            -verbose -version -virtual-pixel' -- "$cur" ));
    else
        if [[ "$cur" == +* ]]; then
            COMPREPLY=($( compgen -W '+debug' -- "$cur" ));
        else
            _filedir;
        fi;
    fi
}
_import () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    _ImageMagick;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-adjoin -annotate -border -channel \
            -colors -colorspace -comment -compress -crop -debug \
            -define -delay -density -depth -descend -display \
            -dispose -dither -encipher -encoding -endian -filter \
            -format -frame -geometry -gravity -help -identify \
            -interlace -interpolate -label -limit -list -log \
            -monitor -monochrome -negate -page -pause -pointsize \
            -quality -quantize -quiet -regard-warnings -repage \
            -resize -respect-parenthesis -rotate -sampling-factor \
            -scene -screen -seed -set -silent -snaps -strip \
            -thumbnail -transparent -transparent-color -treedepth \
            -trim -type -verbose -version -virtual-pixel \
            -window' -- "$cur" ));
    else
        if [[ "$cur" == +* ]]; then
            COMPREPLY=($( compgen -W '+debug' -- "$cur" ));
        else
            _filedir;
        fi;
    fi
}
_info () 
{ 
    local cur i infopath;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    _expand || return 0;
    if [[ "$cur" == */* ]]; then
        _filedir;
        return 0;
    fi;
    infopath='/usr/share/info';
    if [ "${INFOPATH: -1:1}" == ':' ]; then
        infopath=${INFOPATH}${infopath};
    else
        if [ ${INFOPATH:+set} ]; then
            infopath=$INFOPATH;
        fi;
    fi;
    infopath=$infopath:;
    if [ -n "$cur" ]; then
        infopath="${infopath//://$cur* }";
    else
        infopath="${infopath//:// }";
    fi;
    COMPREPLY=($( eval command ls "$infopath" 2>/dev/null ));
    COMPREPLY=(${COMPREPLY[@]##*/?(:)});
    for ((i=0 ; i < ${#COMPREPLY[@]} ; ++i ))
    do
        if [ "${COMPREPLY[$i]}" == 'dir' ]; then
            unset COMPREPLY[$i];
        fi;
    done;
    COMPREPLY=(${COMPREPLY[@]%.@(gz|bz2|xz|lzma)});
    COMPREPLY=($( compgen -W '${COMPREPLY[@]%.*}' -- "${cur//\\\\/}" ));
    return 0
}
_insmod () 
{ 
    local cur prev modpath;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    if [[ ${1##*/} == modprobe && "${COMP_WORDS[1]}" == -r ]]; then
        _installed_modules "$cur";
        return 0;
    fi;
    if [[ "$cur" == */* ]]; then
        _filedir '@(?(k)o?(.gz))';
        return 0;
    fi;
    if [[ $COMP_CWORD -gt 1 && "${COMP_WORDS[COMP_CWORD-1]}" != -* ]]; then
        COMPREPLY=($( compgen -W "$( /sbin/modinfo -p ${COMP_WORDS[1]} |             cut -d: -f1 )" -- "$cur" ));
    else
        _modules $(uname -r);
    fi;
    return 0
}
_installed_modules () 
{ 
    COMPREPLY=($( compgen -W "$( PATH="$PATH:/sbin" lsmod |         awk '{if (NR != 1) print $1}' )" -- "$1" ))
}
_ip () 
{ 
    COMPREPLY=();
    local cur prev words cword;
    _get_comp_words_by_ref cur prev words cword;
    case $prev in 
        -V | -Version | -rc | -rcvbuf)
            return 0
        ;;
        -f | -family)
            COMPREPLY=($( compgen -W 'inet inet6 ipx dnet link' -- "$cur" ));
            return 0
        ;;
        -b | -batch)
            _filedir;
            return 0
        ;;
        -force)
            COMPREPLY=($( compgen -W '-batch' -- "$cur" ));
            return 0
        ;;
    esac;
    local subcword cmd subcmd;
    for ((subcword=1; subcword < ${#words[@]}-1; subcword++ ))
    do
        [[ ${words[subcword]} == -b?(atch) ]] && return 0;
        [[ -n $cmd ]] && subcmd=${words[subcword]} && break;
        [[ ${words[subcword]} != -* && ${words[subcword-1]} != -@(f?(amily)|rc?(vbuf)) ]] && cmd=${words[subcword]};
    done;
    if [[ -z $cmd ]]; then
        case $cur in 
            -*)
                local c="-Version -statistics -details -resolve -family
                    -oneline -timestamp -batch -rcvbuf";
                [[ $cword -eq 1 ]] && c="$c -force";
                COMPREPLY=($( compgen -W "$c" -- "$cur" ));
                return 0
            ;;
            *)
                COMPREPLY=($( compgen -W "help $( ip help 2>&1 |                     sed -e '/OBJECT := /,/}/!d'                         -e 's/.*{//' -e 's/}.*//' -e 's/|//g' )" -- "$cur" ));
                return 0
            ;;
        esac;
    fi;
    [[ $subcmd == help ]] && return 0;
    case $cmd in 
        link)
            case $subcmd in 
                add)

                ;;
                delete)
                    case $(($cword-$subcword)) in 
                        1)
                            _available_interfaces
                        ;;
                        2)
                            COMPREPLY=($( compgen -W 'type' -- "$cur" ))
                        ;;
                        3)
                            [[ $prev == type ]] && COMPREPLY=($( compgen -W 'vlan veth vcan dummy
                                    ifb macvlan can' -- "$cur" ))
                        ;;
                    esac
                ;;
                set)
                    if [[ $cword-$subcword -eq 1 ]]; then
                        _available_interfaces;
                    else
                        case $prev in 
                            arp | dynamic | multicast | allmulticast | promisc | trailers)
                                COMPREPLY=($( compgen -W 'on off'                                     -- "$cur" ))
                            ;;
                            txqueuelen | name | address | broadcast | mtu | netns | alias)

                            ;;
                            *)
                                local c="arp dynamic multicast allmulticast
                                    promisc trailers txqueuelen name address
                                    broadcast mtu netns alias";
                                [[ $prev != @(up|down) ]] && c="$c up down";
                                COMPREPLY=($( compgen -W "$c" -- "$cur" ))
                            ;;
                        esac;
                    fi
                ;;
                show)
                    [[ $cword -eq $subcword+1 ]] && _available_interfaces
                ;;
                *)
                    [[ $cword -eq $subcword ]] && COMPREPLY=($( compgen -W 'help add delete set show'                         -- "$cur" ))
                ;;
            esac
        ;;
        addr)
            case $subcmd in 
                add | change | replace)

                ;;
                del)

                ;;
                show | flush)

                ;;
                *)
                    [[ $cword -eq $subcword ]] && COMPREPLY=($( compgen -W 'help add change replace del
                            show flush' -- "$cur" ))
                ;;
            esac
        ;;
        addrlabel)
            case $subcmd in 
                list | add | del | flush)

                ;;
                *)
                    [[ $cword -eq $subcword ]] && COMPREPLY=($( compgen -W 'help list add del flush'                         -- "$cur" ))
                ;;
            esac
        ;;
        route)
            case $subcmd in 
                list | flush)

                ;;
                get)

                ;;
                add | del | change | append | replace | monitor)

                ;;
                *)
                    [[ $cword -eq $subcword ]] && COMPREPLY=($( compgen -W 'help list flush get add del
                            change append replace monitor' -- "$cur" ))
                ;;
            esac
        ;;
        rule)
            case $subcmd in 
                list | add | del | flush)

                ;;
                *)
                    [[ $cword -eq $subcword ]] && COMPREPLY=($( compgen -W 'help list add del flush'                         -- "$cur" ))
                ;;
            esac
        ;;
        neigh)
            case $subcmd in 
                add | del | change | replace)

                ;;
                show | flush)

                ;;
                *)
                    [[ $cword -eq $subcword ]] && COMPREPLY=($( compgen -W 'help add del change replace
                            show flush' -- "$cur" ))
                ;;
            esac
        ;;
        ntable)
            case $subcmd in 
                change)

                ;;
                show)

                ;;
                *)
                    [[ $cword -eq $subcword ]] && COMPREPLY=($( compgen -W 'help change show'                         -- "$cur" ))
                ;;
            esac
        ;;
        tunnel)
            case $subcmd in 
                add | change | del | show | prl | 6rd)

                ;;
                *)
                    [[ $cword -eq $subcword ]] && COMPREPLY=($( compgen -W 'help add change del show prl
                            6rd' -- "$cur" ))
                ;;
            esac
        ;;
        maddr)
            case $subcmd in 
                add | del)

                ;;
                show)
                    if [[ $cword -eq $subcword+1 || $prev == dev ]]; then
                        _available_interfaces;
                        [[ $prev != dev ]] && COMPREPLY=($( compgen -W '${COMPREPLY[@]} dev'                             -- "$cur" ));
                    fi
                ;;
                *)
                    [[ $cword -eq $subcword ]] && COMPREPLY=($( compgen -W 'help add del show'                         -- "$cur" ))
                ;;
            esac
        ;;
        mroute)
            case $subcmd in 
                show)

                ;;
                *)
                    [[ $cword -eq $subcword ]] && COMPREPLY=($( compgen -W 'help show' -- "$cur" ))
                ;;
            esac
        ;;
        monitor)
            case $subcmd in 
                all)

                ;;
                *)
                    [[ $cword -eq $subcword ]] && COMPREPLY=($( compgen -W 'help all' -- "$cur" ))
                ;;
            esac
        ;;
        xfrm)
            case $subcmd in 
                state | policy | monitor)

                ;;
                *)
                    [[ $cword -eq $subcword ]] && COMPREPLY=($( compgen -W 'state policy monitor'                         -- "$cur" ))
                ;;
            esac
        ;;
    esac
}
_isql () 
{ 
    local cur;
    _get_comp_words_by_ref cur;
    [ -f "$ODBCINI" ] && COMPREPLY=($( command grep \\["$cur" "$ODBCINI" | tr -d \\[\\] ))
}
_iwconfig () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        mode)
            COMPREPLY=($( compgen -W 'managed ad-hoc master \
                repeater secondary monitor' -- "$cur" ));
            return 0
        ;;
        essid)
            COMPREPLY=($( compgen -W 'on off any' -- "$cur" ));
            if [ -n "${COMP_IWLIST_SCAN:-}" ]; then
                COMPREPLY=("${COMPREPLY[@]}" $( compgen -W                     "$( iwlist ${COMP_WORDS[1]} scan |                     awk -F'\"' '/ESSID/ {print $2}' )" -- "$cur" ));
            fi;
            return 0
        ;;
        nwid)
            COMPREPLY=($( compgen -W 'on off' -- "$cur" ));
            return 0
        ;;
        channel)
            COMPREPLY=($( compgen -W "$( iwlist ${COMP_WORDS[1]} channel |                 awk '/^[ \t]*Channel/ {print $2}' )" -- "$cur" ));
            return 0
        ;;
        freq)
            COMPREPLY=($( compgen -W "$( iwlist ${COMP_WORDS[1]} channel |                 awk '/^[ \t]*Channel/ {print $4"G"}')" -- "$cur" ));
            return 0
        ;;
        ap)
            COMPREPLY=($( compgen -W 'on off any' -- "$cur" ));
            if [ -n "${COMP_IWLIST_SCAN:-}" ]; then
                COMPREPLY=("${COMPREPLY[@]}" $( compgen -W                     "$( iwlist ${COMP_WORDS[1]} scan |                     awk -F ': ' '/Address/ {print $2}' )" -- "$cur" ));
            fi;
            return 0
        ;;
        rate)
            COMPREPLY=($( compgen -W 'auto fixed' -- "$cur" ));
            COMPREPLY=("${COMPREPLY[@]}" $( compgen -W                 "$( iwlist ${COMP_WORDS[1]} rate |                 awk '/^[ \t]*[0-9]/ {print $1"M"}' )" -- "$cur" ));
            return 0
        ;;
        rts | frag)
            COMPREPLY=($( compgen -W 'auto fixed off' -- "$cur" ));
            return 0
        ;;
        key | enc)
            COMPREPLY=($( compgen -W 'off on open restricted' -- "$cur" ));
            return 0
        ;;
        power)
            COMPREPLY=($( compgen -W 'period timeout off on' -- "$cur" ));
            return 0
        ;;
        txpower)
            COMPREPLY=($( compgen -W 'off on auto' -- "$cur" ));
            return 0
        ;;
        retry)
            COMPREPLY=($( compgen -W 'limit lifetime' -- "$cur" ));
            return 0
        ;;
    esac;
    if [ $COMP_CWORD -eq 1 ]; then
        if [[ "$cur" == -* ]]; then
            COMPREPLY=($( compgen -W '--help --version' -- "$cur" ));
        else
            _available_interfaces -w;
        fi;
    else
        COMPREPLY=($( compgen -W 'essid nwid mode freq channel sens mode \
            ap nick rate rts frag enc key power txpower commit' -- "$cur" ));
    fi
}
_iwlist () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    if [ $COMP_CWORD -eq 1 ]; then
        if [[ "$cur" == -* ]]; then
            COMPREPLY=($( compgen -W '--help --version' -- "$cur" ));
        else
            _available_interfaces -w;
        fi;
    else
        COMPREPLY=($( compgen -W 'scan scanning freq frequency \
            channel rate bit bitrate key enc encryption power \
            txpower retry ap accesspoint peers event' -- "$cur" ));
    fi
}
_iwpriv () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        roam)
            COMPREPLY=($( compgen -W 'on off' -- "$cur" ));
            return 0
        ;;
        port)
            COMPREPLY=($( compgen -W 'ad-hoc managed' -- "$cur" ));
            return 0
        ;;
    esac;
    if [ $COMP_CWORD -eq 1 ]; then
        if [[ "$cur" == -* ]]; then
            COMPREPLY=($( compgen -W '--help --version' -- "$cur" ));
        else
            _available_interfaces -w;
        fi;
    else
        COMPREPLY=($( compgen -W '--all roam port' -- "$cur" ));
    fi
}
_iwspy () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    if [ $COMP_CWORD -eq 1 ]; then
        if [[ "$cur" == -* ]]; then
            COMPREPLY=($( compgen -W '--help --version' -- "$cur" ));
        else
            _available_interfaces -w;
        fi;
    else
        COMPREPLY=($( compgen -W 'setthr getthr off' -- "$cur" ));
    fi
}
_jar () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    if [ $COMP_CWORD = 1 ]; then
        COMPREPLY=($( compgen -W 'c t x u' -- "$cur" ));
        return 0;
    fi;
    case ${COMP_WORDS[1]} in 
        *c*f)
            _filedir
        ;;
        *f)
            _filedir '@([ejw]ar|zip|apk)'
        ;;
        *)
            _filedir
        ;;
    esac
}
_jarsigner () 
{ 
    COMPREPLY=();
    local cur prev;
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -keystore)
            COMPREPLY=($( compgen -W 'NONE' -- "$cur" ));
            _filedir '@(jks|ks|p12|pfx)';
            return 0
        ;;
        -storepass | -keypass | -sigfile | -digestalg | -sigalg | -tsacert | -altsigner | -altsignerpath | -providerName | -providerClass | -providerArg)
            return 0
        ;;
        -storetype)
            COMPREPLY=($( compgen -W 'JKS PKCS11 PKCS12' -- "$cur" ));
            return 0
        ;;
        -signedjar)
            _filedir jar;
            return 0
        ;;
        -tsa)
            _filedir;
            return 0
        ;;
    esac;
    local i jar=false;
    for ((i=0; i < ${#COMP_WORDS[@]}-1; i++ ))
    do
        if [[ "${COMP_WORDS[i]}" == *.jar && "${COMP_WORDS[i-1]}" != -signedjar ]]; then
            jar=true;
            break;
        fi;
    done;
    if ! $jar; then
        if [[ "$cur" == -* ]]; then
            COMPREPLY=($( compgen -W '-keystore -storepass -storetype \
                -keypass -sigfile -signedjar -digestalg -sigalg -verify \
                -verbose -certs -tsa -tsacert -altsigner -altsignerpath \
                -protected -providerName -providerClass -providerArg'                 -- "$cur" ));
        fi;
        _filedir jar;
    fi
}
_java () 
{ 
    local cur prev words cword i;
    COMPREPLY=();
    _get_comp_words_by_ref -n : cur prev words cword;
    for ((i=1; i < $cword; i++))
    do
        case ${words[$i]} in 
            -cp | -classpath)
                ((i++))
            ;;
            -*)

            ;;
            *)
                _filedir;
                return 0
            ;;
        esac;
    done;
    case $cur in 
        -verbose:*)
            COMPREPLY=($( compgen -W 'class gc jni' -- "${cur#*:}" ));
            return 0
        ;;
        -javaagent:*)
            cur=${cur#*:};
            _filedir '@(jar|zip)';
            return 0
        ;;
        -agentpath:*)
            cur=${cur#*:};
            _filedir so;
            return 0
        ;;
        -splash:*)
            cur=${cur#*:};
            _filedir '@(gif|jp?(e)g|png)';
            return 0
        ;;
        -Xbootclasspath*:*)
            _java_path;
            return 0
        ;;
        -Xcheck:*)
            COMPREPLY=($( compgen -W 'jni' -- "${cur#*:}" ));
            return 0
        ;;
        -Xgc:*)
            COMPREPLY=($( compgen -W 'singlecon gencon singlepar genpar'                 -- "${cur#*:}" ));
            return 0
        ;;
        -Xgcprio:*)
            COMPREPLY=($( compgen -W 'throughput pausetime deterministic'                 -- "${cur#*:}" ));
            return 0
        ;;
        -Xloggc:* | -Xverboselog:*)
            cur=${cur#*:};
            _filedir;
            return 0
        ;;
        -Xshare:*)
            COMPREPLY=($( compgen -W 'auto off on' -- "${cur#*:}" ));
            return 0
        ;;
        -Xverbose:*)
            COMPREPLY=($( compgen -W 'memory load jni cpuinfo codegen opt
                gcpause gcreport' -- "${cur#*:}" ));
            return 0
        ;;
        -Xverify:*)
            COMPREPLY=($( compgen -W 'all none remote' -- "${cur#*:}" ));
            return 0
        ;;
        -D* | -*:*)
            return 0
        ;;
    esac;
    case $prev in 
        -cp | -classpath)
            _java_path;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-client -server -agentlib: -agentpath:
            -classpath -D -d32 -d64 -enableassertions -disableassertions
            -enablesystemassertions -disablesystemassertions -jar -javaagent:
            -verbose -verbose -version -showversion -help -X' -- "$cur" ));
    else
        if [[ "$prev" == -jar ]]; then
            _filedir jar;
        else
            _java_classes;
        fi;
    fi;
    [[ ${#COMPREPLY[@]} -eq 1 && ${COMPREPLY[0]} == -*[:=] ]] && type compopt &>/dev/null && compopt -o nospace;
    __ltrim_colon_completions "$cur"
}
_java_classes () 
{ 
    local classpath i;
    _java_find_classpath;
    cur=${cur//.//};
    for i in ${classpath//:/ };
    do
        if [[ "$i" == *.@(jar|zip) && -r $i ]]; then
            if type zipinfo &>/dev/null; then
                COMPREPLY=("${COMPREPLY[@]}" $( zipinfo -1                     "$i" "$cur*" 2>/dev/null |                     command grep '^[^$]*\.class$' ));
            else
                COMPREPLY=("${COMPREPLY[@]}" $( jar tf "$i"                     "$cur" | command grep '^[^$]*\.class$' ));
            fi;
        else
            if [ -d $i ]; then
                COMPREPLY=("${COMPREPLY[@]}" $( command ls $i/$cur*.class 2>/dev/null |                     sed -ne '/\$/d' -e "s|^$i//*||p" ));
            fi;
        fi;
    done;
    COMPREPLY=(${COMPREPLY[@]%.class});
    COMPREPLY=(${COMPREPLY[@]//\//.})
}
_java_find_classpath () 
{ 
    local i;
    for ((i=1; i < COMP_CWORD; i++ ))
    do
        if [[ "${COMP_WORDS[i]}" == -@(cp|classpath) ]]; then
            classpath=${COMP_WORDS[i+1]};
            break;
        fi;
    done;
    [ -z "$classpath" ] && classpath=$CLASSPATH;
    [ -z "$classpath" ] && classpath=.
}
_java_find_sourcepath () 
{ 
    local i;
    for ((i=1; i < COMP_CWORD; i++ ))
    do
        if [[ "${COMP_WORDS[i]}" == -sourcepath ]]; then
            sourcepath=${COMP_WORDS[i+1]};
            break;
        fi;
    done;
    if [ -z "$sourcepath" ]; then
        _java_find_classpath;
        sourcepath=$classpath;
    fi
}
_java_packages () 
{ 
    local sourcepath i;
    _java_find_sourcepath;
    cur=${cur//.//};
    for i in ${sourcepath//:/ };
    do
        if [ -d $i ]; then
            COMPREPLY=("${COMPREPLY[@]}" $( command ls -F -d                 $i/$cur* 2>/dev/null | sed -e 's|^'$i'/||' ));
        fi;
    done;
    COMPREPLY=($( tr " " "\n" <<<"${COMPREPLY[@]}" | command grep "/$" ));
    COMPREPLY=(${COMPREPLY[@]%/});
    cur=${COMPREPLY[@]//\//.}
}
_java_path () 
{ 
    cur=${cur##*:};
    _filedir '@(jar|zip)'
}
_javac () 
{ 
    COMPREPLY=();
    local cur prev;
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -d)
            _filedir -d;
            return 0
        ;;
        -classpath | -bootclasspath | -sourcepath | -extdirs)
            _java_path;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-g -g:none -g:lines -g:vars \
            -g:source -O -nowarn -verbose -deprecation -classpath \
            -sourcepath -bootclasspath -extdirs -d -encoding -source \
            -target -help' -- "$cur" ));
    else
        _filedir java;
    fi
}
_javadoc () 
{ 
    COMPREPLY=();
    local cur prev classpath;
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -overview | -helpfile)
            _filedir '?(x)htm?(l)';
            return 0
        ;;
        -stylesheetfile)
            _filedir css;
            return 0
        ;;
        -d | -link | -linkoffline)
            _filedir -d;
            return 0
        ;;
        -classpath | -bootclasspath | -docletpath | -sourcepath | -extdirs)
            _java_path;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-overview -public -protected \
            -package -private -help -doclet -docletpath \
            -sourcepath -classpath -exclude -subpackages \
            -breakiterator -bootclasspath -source -extdirs \
            -verbose -locale -encoding -J -d -use -version \
            -author -docfilessubdirs -splitindex \
            -windowtitle -doctitle -header -footer -bottom \
            -link -linkoffline -excludedocfilessubdir \
            -group -nocomment -nodeprecated -noqualifier \
            -nosince -nodeprecatedlist -notree -noindex \
            -nohelp -nonavbar -quiet -serialwarn -tag \
            -taglet -tagletpath -charset -helpfile \
            -linksource -stylesheetfile -docencoding' -- "$cur" ));
    else
        _filedir java;
        _java_packages;
    fi
}
_kernel_versions () 
{ 
    COMPREPLY=($( compgen -W '$( command ls /lib/modules )' -- "$cur" ))
}
_kill () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    if [[ $COMP_CWORD -eq 1 && "$cur" == -* ]]; then
        _signals;
    else
        _pids;
    fi
}
_killall () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    if [[ $COMP_CWORD -eq 1 && "$cur" == -* ]]; then
        _signals;
    else
        _pnames;
    fi;
    return 0
}
_known_hosts () 
{ 
    local options;
    COMPREPLY=();
    [[ "$1" == -a || "$2" == -a ]] && options=-a;
    [[ "$1" == -c || "$2" == -c ]] && options="$options -c";
    _known_hosts_real $options "$(_get_cword :)"
}
_known_hosts_real () 
{ 
    local configfile flag prefix;
    local cur curd awkcur user suffix aliases i host;
    local -a kh khd config;
    local OPTIND=1;
    while getopts "acF:p:" flag "$@"; do
        case $flag in 
            a)
                aliases='yes'
            ;;
            c)
                suffix=':'
            ;;
            F)
                configfile=$OPTARG
            ;;
            p)
                prefix=$OPTARG
            ;;
        esac;
    done;
    [ $# -lt $OPTIND ] && echo "error: $FUNCNAME: missing mandatory argument CWORD";
    cur=${!OPTIND};
    let "OPTIND += 1";
    [ $# -ge $OPTIND ] && echo "error: $FUNCNAME("$@"): unprocessed arguments:" $(while [ $# -ge $OPTIND ]; do printf '%s\n' ${!OPTIND}; shift; done);
    [[ $cur == *@* ]] && user=${cur%@*}@ && cur=${cur#*@};
    kh=();
    if [ -n "$configfile" ]; then
        [ -r "$configfile" ] && config=("${config[@]}" "$configfile");
    else
        for i in /etc/ssh/ssh_config "${HOME}/.ssh/config" "${HOME}/.ssh2/config";
        do
            [ -r $i ] && config=("${config[@]}" "$i");
        done;
    fi;
    if [ ${#config[@]} -gt 0 ]; then
        local OIFS=$IFS IFS='
';
        local -a tmpkh;
        tmpkh=($( awk 'sub("^[ \t]*([Gg][Ll][Oo][Bb][Aa][Ll]|[Uu][Ss][Ee][Rr])[Kk][Nn][Oo][Ww][Nn][Hh][Oo][Ss][Tt][Ss][Ff][Ii][Ll][Ee][ \t]+", "") { print $0 }' "${config[@]}" | sort -u ));
        for i in "${tmpkh[@]}";
        do
            i=${i//\"};
            __expand_tilde_by_ref i;
            [ -r "$i" ] && kh=("${kh[@]}" "$i");
        done;
        IFS=$OIFS;
    fi;
    if [ -z "$configfile" ]; then
        for i in /etc/ssh/ssh_known_hosts /etc/ssh/ssh_known_hosts2 /etc/known_hosts /etc/known_hosts2 ~/.ssh/known_hosts ~/.ssh/known_hosts2;
        do
            [ -r $i ] && kh=("${kh[@]}" $i);
        done;
        for i in /etc/ssh2/knownhosts ~/.ssh2/hostkeys;
        do
            [ -d $i ] && khd=("${khd[@]}" $i/*pub);
        done;
    fi;
    if [[ ${#kh[@]} -gt 0 || ${#khd[@]} -gt 0 ]]; then
        awkcur=${cur//\//\\\/};
        awkcur=${awkcur//\./\\\.};
        curd=$awkcur;
        if [[ "$awkcur" == [0-9]*[.:]* ]]; then
            awkcur="^$awkcur[.:]*";
        else
            if [[ "$awkcur" == [0-9]* ]]; then
                awkcur="^$awkcur.*[.:]";
            else
                if [ -z "$awkcur" ]; then
                    awkcur="[a-z.:]";
                else
                    awkcur="^$awkcur";
                fi;
            fi;
        fi;
        if [ ${#kh[@]} -gt 0 ]; then
            COMPREPLY=("${COMPREPLY[@]}" $( awk 'BEGIN {FS=","}
            /^\s*[^|\#]/ {for (i=1; i<=2; ++i) { \
            sub(" .*$", "", $i); \
            sub("^\\[", "", $i); sub("\\](:[0-9]+)?$", "", $i); \
            if ($i ~ /'"$awkcur"'/) {print $i} \
            }}' "${kh[@]}" 2>/dev/null ));
        fi;
        if [ ${#khd[@]} -gt 0 ]; then
            for i in "${khd[@]}";
            do
                if [[ "$i" == *key_22_$curd*.pub && -r "$i" ]]; then
                    host=${i/#*key_22_/};
                    host=${host/%.pub/};
                    COMPREPLY=("${COMPREPLY[@]}" $host);
                fi;
            done;
        fi;
        for ((i=0; i < ${#COMPREPLY[@]}; i++ ))
        do
            COMPREPLY[i]=$prefix$user${COMPREPLY[i]}$suffix;
        done;
    fi;
    if [[ ${#config[@]} -gt 0 && -n "$aliases" ]]; then
        local hosts=$( sed -ne 's/^[ \t]*[Hh][Oo][Ss][Tt]\([Nn][Aa][Mm][Ee]\)\{0,1\}['"$'\t '"']\{1,\}\([^#*?]*\)\(#.*\)\{0,1\}$/\2/p' "${config[@]}" );
        COMPREPLY=("${COMPREPLY[@]}" $( compgen  -P "$prefix$user"             -S "$suffix" -W "$hosts" -- "$cur" ));
    fi;
    if [[ -n ${COMP_KNOWN_HOSTS_WITH_AVAHI:-} ]] && type avahi-browse &>/dev/null; then
        COMPREPLY=("${COMPREPLY[@]}" $(             compgen -P "$prefix$user" -S "$suffix" -W             "$( avahi-browse -cpr _workstation._tcp 2>/dev/null |                  awk -F';' '/^=/ { print $7 }' | sort -u )" -- "$cur" ));
    fi;
    if [ -n "${COMP_KNOWN_HOSTS_WITH_HOSTFILE-1}" ]; then
        COMPREPLY=("${COMPREPLY[@]}" $( compgen -A hostname -P "$prefix$user" -S "$suffix" -- "$cur" ));
    fi;
    __ltrim_colon_completions "$prefix$user$cur";
    return 0
}
_ktutil () 
{ 
    local cur prev command options split=false;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case $prev in 
        -p | --principal)
            _heimdal_principals;
            return 0
        ;;
        -e | --enctype)
            _heimdal_encodings;
            return 0
        ;;
        -a | --admin-server)
            _known_hosts_real "$cur";
            return 0
        ;;
        -r | --realm)
            _heimdal_realms;
            return 0
        ;;
        -s | -k | --srvtab | --keytab)
            _filedir;
            return 0
        ;;
    esac;
    $split && return 0;
    commands='add change copy get list remove rename purge srvconvert \
        srv2keytab srvcreate key2srvtab';
    for ((i=1; i < COMP_CWORD; i++ ))
    do
        case ${COMP_WORDS[i]} in 
            -k | --keytab)
                i=$(($i+1))
            ;;
            -*)

            ;;
            *)
                command=${COMP_WORDS[i]};
                break
            ;;
        esac;
    done;
    if [[ "$cur" == -* ]]; then
        case $command in 
            add)
                options='-p --principal -V -e --enctype -w --password -r \
                    --random -s --no-salt -h --hex'
            ;;
            change)
                options='-r --realm -a --admin-server -s --server-port'
            ;;
            get)
                options='-p --principal -e --enctype -r --realm -a \
                    --admin-server -s server --server-port'
            ;;
            list)
                options='--keys --timestamp'
            ;;
            remove)
                options='-p --principal -V --kvno -e --enctype'
            ;;
            purge)
                options='--age'
            ;;
            srv2keytab | key2srvtab)
                options='-s --srvtab'
            ;;
            *)
                options='-k --keytab -v --verbose --version -v --help'
            ;;
        esac;
        COMPREPLY=($( compgen -W "$options" -- "$cur" ));
    else
        case $command in 
            copy)
                _filedir
            ;;
            get)
                _heimdal_principals
            ;;
            rename)
                _heimdal_principals
            ;;
            *)
                COMPREPLY=($( compgen -W "$commands" -- "$cur" ))
            ;;
        esac;
    fi
}
_lastlog () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case $prev in 
        -b | --before | -h | --help | -t | --time)
            return 0
        ;;
        -u | --user)
            COMPREPLY=($( compgen -u -- "$cur" ));
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--before --help --time --user' -- "$cur" ));
        return 0;
    fi
}
_links () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    case $cur in 
        --*)
            COMPREPLY=($( compgen -W '--help' -- "$cur" ))
        ;;
        -*)
            COMPREPLY=($( compgen -W '-async-dns -max-connections \
                -max-connections-to-host -retries -receive-timeout \
                -unrestartable-receive-timeout -format-cache-size \
                -memory-cache-size -http-proxy -ftp-proxy -download-dir \
                -assume-codepage -anonymous -dump -no-connect \
                -source -version -help' -- "$cur" ))
        ;;
        *)
            if [ -r ~/.links/links.his ]; then
                COMPREPLY=($( compgen -W '$( < ~/.links/links.his )'                     -- "$cur" ));
            fi;
            _filedir '@(htm|html)';
            return 0
        ;;
    esac;
    return 0
}
_linux_fstab () 
{ 
    COMPREPLY=();
    local fs_spec fs_file fs_other;
    local oldifs="$IFS";
    while read -r fs_spec fs_file fs_other; do
        if [[ $fs_spec = [#]* ]]; then
            continue;
        fi;
        if [[ $1 == -L ]]; then
            local fs_label=${fs_spec/#LABEL=};
            if [[ $fs_label != "$fs_spec" ]]; then
                __linux_fstab_unescape fs_label;
                IFS='';
                COMPREPLY+=("$fs_label");
                IFS=$oldifs;
            fi;
        else
            __linux_fstab_unescape fs_spec;
            __linux_fstab_unescape fs_file;
            IFS='';
            [[ $fs_spec = */* ]] && COMPREPLY+=("$fs_spec");
            [[ $fs_file = */* ]] && COMPREPLY+=("$fs_file");
            IFS=$oldifs;
        fi;
    done;
    _reply_compgen_array
}
_loexp_ () 
{ 
    local c=${COMP_WORDS[COMP_CWORD]};
    local a="${COMP_LINE}";
    local e s g=0 cd dc t="";
    local IFS;
    shopt -q extglob && g=1;
    test $g -eq 0 && shopt -s extglob;
    cd='*-?(c)d*';
    dc='*-d?(c)*';
    case "${1##*/}" in 
        lobase)
            e='!*.+(odb|ODB)'
        ;;
        lofromtemplate)
            e='!*.+(stw|STW|dot|DOT|vor|VOR|stc|STC|xlt|XLT|sti|STI|pot|POT|std|STD|stw|STW|dotm|DOTM|dotx|DOTX|potm|POTM|potx|POTX|xltm|XLTM|xltx|XLTX)'
        ;;
        lodraw)
            e='!*.+(sxd|SXD|std|STD|dxf|DXF|emf|EMF|eps|EPS|met|MET|pct|PCT|sgf|SGF|sgv|SGV|sda|SDA|sdd|SDD|vor|VOR|svm|SVM|wmf|WMF|bmp|BMP|gif|GIF|jpg|JPG|jpeg|JPEG|jfif|JFIF|fif|FIF|jpe|JPE|pcd|PCD|pcx|PCX|pgm|PGM|png|PNG|ppm|PPM|psd|PSD|ras|RAS|tga|TGA|tif|TIF|tiff|TIFF|xbm|XBM|xpm|XPM|odg|ODG|otg|OTG|fodg|FODG|odc|ODC|odi|ODI|sds|SDS|wpg|WPG|svg|SVG)'
        ;;
        localc)
            e='!*.+(sxc|SXC|stc|STC|dif|DIF|dbf|DBF|xls|XLS|xlw|XLW|xlt|XLT|rtf|RTF|sdc|SDC|vor|VOR|slk|SLK|txt|TXT|htm|HTM|html|HTML|wk1|WK1|wks|WKS|123|123|xml|XML|ods|ODS|ots|OTS|fods|FODS|csv|CSV|xlsb|XLSB|xlsm|XLSM|xlsx|XLSX|xltm|XLTM|xltx|XLTX)'
        ;;
        lomath)
            e='!*.+(sxm|SXM|smf|SMF|mml|MML|odf|ODF)'
        ;;
        loweb)
            e='!*.+(htm|HTM|html|HTML|stw|STW|txt|TXT|vor|VOR|oth|OTH)'
        ;;
        libreoffice)
            e='!*.+(sxd|SXD|std|STD|dxf|DXF|emf|EMF|eps|EPS|met|MET|pct|PCT|sgf|SGF|sgv|SGV|sda|SDA|sdd|SDD|vor|VOR|svm|SVM|wmf|WMF|bmp|BMP|gif|GIF|jpg|JPG|jpeg|JPEG|jfif|JFIF|fif|FIF|jpe|JPE|pcd|PCD|pcx|PCX|pgm|PGM|png|PNG|ppm|PPM|psd|PSD|ras|RAS|tga|TGA|tif|TIF|tiff|TIFF|xbm|XBM|xpm|XPM|odg|ODG|otg|OTG|fodg|FODG|odc|ODC|odi|ODI|sds|SDS|wpg|WPG|svg|SVG|doc|DOC|dot|DOT|rtf|RTF|sxw|SXW|stw|STW|sdw|SDW|vor|VOR|txt|TXT|htm?|HTM?|xml|XML|wp|WP|wpd|WPD|wps|WPS|odt|ODT|ott|OTT|fodt|FODT|docm|DOCM|docx|DOCX|dotm|DOTM|dotx|DOTX|sxm|SXM|smf|SMF|mml|MML|odf|ODF|sxi|SXI|sti|STI|ppt|PPT|pps|PPS|pot|POT|sxd|SXD|sda|SDA|sdd|SDD|sdp|SDP|vor|VOR|cgm|CGM|odp|ODP|otp|OTP|fodp|FODP|ppsm|PPSM|ppsx|PPSX|pptm|PPTM|pptx|PPTX|potm|POTM|potx|POTX|odb|ODB|sxc|SXC|stc|STC|dif|DIF|dbf|DBF|xls|XLS|xlw|XLW|xlt|XLT|rtf|RTF|sdc|SDC|vor|VOR|slk|SLK|txt|TXT|htm|HTM|html|HTML|wk1|WK1|wks|WKS|123|123|xml|XML|ods|ODS|ots|OTS|fods|FODS|csv|CSV|xlsb|XLSB|xlsm|XLSM|xlsx|XLSX|xltm|XLTM|xltx|XLTX|sxg|SXG|odm|ODM|sgl|SGL|stw|STW|dot|DOT|vor|VOR|stc|STC|xlt|XLT|sti|STI|pot|POT|std|STD|stw|STW|dotm|DOTM|dotx|DOTX|potm|POTM|potx|POTX|xltm|XLTM|xltx|XLTX|htm|HTM|html|HTML|stw|STW|txt|TXT|vor|VOR|oth|OTH)'
        ;;
        lowriter)
            e='!*.+(doc|DOC|dot|DOT|rtf|RTF|sxw|SXW|stw|STW|sdw|SDW|vor|VOR|txt|TXT|htm?|HTM?|xml|XML|wp|WP|wpd|WPD|wps|WPS|odt|ODT|ott|OTT|fodt|FODT|docm|DOCM|docx|DOCX|dotm|DOTM|dotx|DOTX|sxg|SXG|odm|ODM|sgl|SGL)'
        ;;
        loimpress)
            e='!*.+(sxi|SXI|sti|STI|ppt|PPT|pps|PPS|pot|POT|sxd|SXD|sda|SDA|sdd|SDD|sdp|SDP|vor|VOR|cgm|CGM|odp|ODP|otp|OTP|fodp|FODP|ppsm|PPSM|ppsx|PPSX|pptm|PPTM|pptx|PPTX|potm|POTM|potx|POTX)'
        ;;
        unopkg)
            e='!*.+(oxt|OXT)'
        ;;
        *)
            e='!*'
        ;;
    esac;
    case "$(complete -p ${1##*/} 2> /dev/null)" in 
        *-d*)

        ;;
        *)
            s="-S/"
        ;;
    esac;
    IFS='
';
    case "$c" in 
        \$\(*\))
            eval COMPREPLY=\(${c}\)
        ;;
        \$\(*)
            COMPREPLY=($(compgen -c -P '$(' -S ')'  -- ${c#??}))
        ;;
        \`*\`)
            eval COMPREPLY=\(${c}\)
        ;;
        \`*)
            COMPREPLY=($(compgen -c -P '\`' -S '\`' -- ${c#?}))
        ;;
        \$\{*\})
            eval COMPREPLY=\(${c}\)
        ;;
        \$\{*)
            COMPREPLY=($(compgen -v -P '${' -S '}'  -- ${c#??}))
        ;;
        \$*)
            COMPREPLY=($(compgen -v -P '$'          -- ${c#?}))
        ;;
        \~*/*)
            COMPREPLY=($(compgen -f -X "$e"         -- ${c}))
        ;;
        \~*)
            COMPREPLY=($(compgen -u ${s}	 	-- ${c}))
        ;;
        *@*)
            COMPREPLY=($(compgen -A hostname -P '@' -S ':' -- ${c#*@}))
        ;;
        *[*?[]*)
            COMPREPLY=($(compgen -G "${c}"))
        ;;
        *[?*+\!@]\(*\)*)
            if test $g -eq 0; then
                COMPREPLY=($(compgen -f -X "$e" -- $c));
                test $g -eq 0 && shopt -u extglob;
                return;
            fi;
            COMPREPLY=($(compgen -G "${c}"))
        ;;
        *)
            if test "$c" = ".."; then
                COMPREPLY=($(compgen -d -X "$e" -S / ${_nosp} -- $c));
            else
                for s in $(compgen -f -X "$e" -- $c);
                do
                    if test -d $s; then
                        COMPREPLY=(${COMPREPLY[@]} $(compgen -f -X "$e" -S / -- $s));
                    else
                        if test -z "$t"; then
                            COMPREPLY=(${COMPREPLY[@]} $s);
                        else
                            case "$(file -b $s 2> /dev/null)" in 
                                $t)
                                    COMPREPLY=(${COMPREPLY[@]} $s)
                                ;;
                            esac;
                        fi;
                    fi;
                done;
            fi
        ;;
    esac;
    test $g -eq 0 && shopt -u extglob
}
_logicalvolumes () 
{ 
    COMPREPLY=($(compgen -W "$( lvscan 2>/dev/null |         sed -n -e "s|^.*'\(.*\)'.*$|\1|p" )" -- "$cur" ))
}
_longopt () 
{ 
    local cur prev split=false;
    _get_comp_words_by_ref -n = cur prev;
    _split_longopt && split=true;
    case "$prev" in 
        --*[Dd][Ii][Rr]*)
            _filedir -d;
            return 0
        ;;
        --*[Ff][Ii][Ll][Ee]* | --*[Pp][Aa][Tt][Hh]*)
            _filedir;
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W "$( $1 --help 2>&1 |             sed -ne 's/.*\(--[-A-Za-z0-9]\{1,\}\).*/\1/p' | sort -u )"             -- "$cur" ));
    else
        if [[ "$1" == @(mk|rm)dir ]]; then
            _filedir -d;
        else
            _filedir;
        fi;
    fi
}
_look () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    if [ $COMP_CWORD = 1 ]; then
        COMPREPLY=($( compgen -W '$(look "$cur" 2>/dev/null)' -- "$cur" ));
    fi
}
_lsof () 
{ 
    COMPREPLY=();
    local cur prev;
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -'?' | -h | +c | -c | -d | -F | -i | +r | -r | -s | -S | -T)
            return 0
        ;;
        -A | -k | -m | +m | -o)
            _filedir;
            return 0
        ;;
        +d | +D)
            _filedir -d;
            return 0
        ;;
        -D)
            COMPREPLY=($( compgen -W '? b i r u' -- "$cur" ));
            return 0
        ;;
        -f)
            COMPREPLY=($( compgen -W 'c f g G n' -- "$cur" ));
            return 0
        ;;
        -g)
            _pgids;
            return 0
        ;;
        -p)
            _pids;
            return 0
        ;;
        -u)
            COMPREPLY=($( compgen -u -- "$cur" ));
            return 0
        ;;
    esac;
    if [[ "$cur" == [-+]* ]]; then
        COMPREPLY=($( compgen -W '-h -a -A -b -c +c -C +d -d +D -D +f -f -F -g
            -i -k -l +L -L +m -m +M -M -n -N -o -O -p -P +r -r -R -s -S -T -t
            -u -U -v -V +w -w -x -X -z -Z' -- "$cur" ));
        return 0;
    fi;
    _filedir
}
_lvchange () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -a | -A | -C | -M | --available | --autobackup | --continguous | --persistent)
            COMPREPLY=($( compgen -W 'y n' -- "$cur" ));
            return 0
        ;;
        -p | --permission)
            COMPREPLY=($( compgen -W 'r rw' -- "$cur" ));
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--autobackup --available \
            --addtag --alloc --contiguous --debug --deltag \
            --force --help --ignorelockingfailure \
            --persistent --major --minor --partial \
            --permission --readahead --refresh --test \
            --verbose --version' -- "$cur" ));
    else
        _logicalvolumes;
    fi
}
_lvcreate () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -A | -C | -M | -Z | --autobackup | --continguous | --persistent | --zero)
            COMPREPLY=($( compgen -W 'y n' -- "$cur" ));
            return 0
        ;;
        -L | --size)
            _sizes;
            return 0
        ;;
        -p | --permission)
            COMPREPLY=($( compgen -W 'r rw' -- "$cur" ));
            return 0
        ;;
        -n | --name)
            _logicalvolumes;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--autobackup --addtag --alloc \
            --contiguous --debug --help --stripes \
            --stripesize --extents --size --persistent \
            --major --minor --name --permission \
            --readahead --test --type --verbose --zero \
            --version' -- "$cur" ));
    else
        _args;
        if [ $args -eq 0 ]; then
            _volumegroups;
        else
            _physicalvolumes;
        fi;
    fi
}
_lvdisplay () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        --units)
            _units;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--colon --columns --units \
            --partial --maps --verbose --debug --help --version' -- "$cur" ));
    else
        _logicalvolumes;
    fi
}
_lvextend () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -A | --autobackup)
            COMPREPLY=($( compgen -W 'y n' -- "$cur" ));
            return 0
        ;;
        -L | --size)
            _sizes;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--autobackup --alloc \
            --debug --help --stripes --stripesize \
            --extents --size --nofsck --resizefs \
            --test --type --verbose --version' -- "$cur" ));
    else
        _args;
        if [ $args -eq 0 ]; then
            _logicalvolumes;
        else
            _physicalvolumes;
        fi;
    fi
}
_lvm () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    if [ $COMP_CWORD -eq 1 ]; then
        COMPREPLY=($( compgen -W 'dumpconfig help lvchange \
            lvcreate lvdisplay lvextend lvmchange \
            lvmdiskscan lvmsadc lvmsar lvreduce \
            lvremove lvrename lvresize lvs lvscan \
            pvchange pvcreate pvdata pvdisplay pvmove \
            pvremove pvresize pvs pvscan vgcfgbackup \
            vgcfgrestore vgchange vgck vgconvert \
            vgcreate vgdisplay vgexport vgextend \
            vgimport vgmerge vgmknodes vgreduce \
            vgremove vgrename vgs vgscan vgsplit \
            version' -- "$cur" ));
    else
        case ${COMP_WORDS[1]} in 
            pvchange)
                _pvchange
            ;;
            pvcreate)
                _pvcreate
            ;;
            pvdisplay)
                _pvdisplay
            ;;
            pvmove)
                _pvmove
            ;;
            pvremove)
                _pvremove
            ;;
            pvresize)
                _pvresize
            ;;
            pvs)
                _pvs
            ;;
            pvscan)
                _pvscan
            ;;
            vgcfgbackup)
                _vgcfgbackup
            ;;
            vgcfgrestore)
                _vgcfgrestore
            ;;
            vgchange)
                _vgchange
            ;;
            vgck)
                _vgck
            ;;
            vgconvert)
                _vgconvert
            ;;
            vgcreate)
                _vgcreate
            ;;
            vgdisplay)
                _vgdisplay
            ;;
            vgexport)
                _vgexport
            ;;
            vgextend)
                _vgextend
            ;;
            vgimport)
                _vgimport
            ;;
            vgmerge)
                _vgmerge
            ;;
            vgmknodes)
                _vgmknodes
            ;;
            vgreduce)
                _vgreduce
            ;;
            vgremove)
                _vgremove
            ;;
            vgrename)
                _vgrename
            ;;
            vgs)
                _vgs
            ;;
            vgscan)
                _vgscan
            ;;
            vgsplit)
                _vgsplit
            ;;
            lvchange)
                _lvchange
            ;;
            lvcreate)
                _lvcreate
            ;;
            lvdisplay)
                _lvdisplay
            ;;
            lvextend)
                _lvextend
            ;;
            lvreduce)
                _lvreduce
            ;;
            lvremove)
                _lvremove
            ;;
            lvrename)
                _lvrename
            ;;
            lvresize)
                _lvresize
            ;;
            lvs)
                _lvs
            ;;
            lvscan)
                _lvscan
            ;;
        esac;
    fi
}
_lvmdiskscan () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--debug --help \
            --lvmpartition --verbose --version' -- "$cur" ));
    fi
}
_lvreduce () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -A | --autobackup)
            COMPREPLY=($( compgen -W 'y n' -- "$cur" ));
            return 0
        ;;
        -L | --size)
            _sizes;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--autobackup \
            --debug --force --help --extents \
            --size --nofsck --resizefs --test --verbose --version' -- "$cur" ));
    else
        _logicalvolumes;
    fi
}
_lvremove () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -A | --autobackup)
            COMPREPLY=($( compgen -W 'y n' -- "$cur" ));
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--autobackup --debug \
            --force --help --test --verbose --version' -- "$cur" ));
    else
        _logicalvolumes;
    fi
}
_lvrename () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -A | --autobackup)
            COMPREPLY=($( compgen -W 'y n' -- "$cur" ));
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--autobackup --debug \
            --help --test --verbose --version' -- "$cur" ));
    else
        _logicalvolumes;
    fi
}
_lvresize () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -A | --autobackup)
            COMPREPLY=($( compgen -W 'y n' -- "$cur" ));
            return 0
        ;;
        -L | --size)
            _sizes;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--autobackup --alloc \
            --debug --help --stripes --stripesize \
            --extents --size --nofsck --resizefs \
            --test --type --verbose --version' -- "$cur" ));
    else
        _args;
        if [ $args -eq 0 ]; then
            _logicalvolumes;
        else
            _physicalvolumes;
        fi;
    fi
}
_lvs () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -o | -O | --options | --sort)
            COMPREPLY=($( compgen -W 'lv_uuid lv_name lv_attr lv_minor \
                lv_size seg_count origin snap_percent segtype stripes \
                stripesize chunksize seg_start seg_size' -- "$cur" ));
            return 0
        ;;
        --units)
            _units;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--aligned --debug --help \
            --ignorelockingfailure --noheadings --nosuffix --options \
            --sort --partial --segments --separator --unbuffered --units \
            --verbose --version' -- "$cur" ));
    else
        _logicalvolumes;
    fi
}
_lvscan () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--blockdevice --debug \
            --help --ignorelockingfailure \
            --partial --verbose --version' -- "$cur" ));
    fi
}
_lzma () 
{ 
    local cur prev xspec;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-1 -2 -3 -4 -5 -6 -7 -8 -9 \
            --help --decompress --compress --keep --force --suffix \
            --test --stdout --quiet --verbose --license --list \
            --version --small --fast --best --text' -- "$cur" ));
        return 0;
    fi;
    local IFS='
';
    xspec="*.@(lzma|tlz)";
    if [[ "$prev" == --* ]]; then
        [[ "$prev" == --decompress || "$prev" == --list || "$prev" == --test ]] && xspec="!"$xspec;
        [[ "$prev" == --compress ]] && xspec=;
    else
        if [[ "$prev" == -* ]]; then
            [[ "$prev" == -*[dt]* ]] && xspec="!"$xspec;
            [[ "$prev" == -*z* ]] && xspec=;
        fi;
    fi;
    _expand || return 0;
    _compopt_o_filenames;
    COMPREPLY=($( compgen -f -X "$xspec" -- "$cur" ) $( compgen -d -- "$cur" ))
}
_lzop () 
{ 
    local cur prev xspec;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-1 -2 -3 -4 -5 -6 -7 -8 -9 -P \
            --fast --best --decompress --extract --test --list --ls --info \
            --sysinfo --license --help --version --stdout --output --path \
            --force --no-checksum --no-name --name --no-mode --no-time \
            --suffix --keep --delete --crc32 --no-warn --ignore-warn --quiet \
            --verbose --no-stdin --filter --checksum --no-color --mono \
            --color' -- "$cur" ));
        return 0;
    fi;
    case $prev in 
        -o | --output)
            _filedir;
            return 0
        ;;
        --path)
            _filedir -d;
            return 0
        ;;
        -S | --suffix)
            return 0
        ;;
    esac;
    xspec="*.?(t)lzo";
    case $prev in 
        --decompress | --uncompress | --extract | --list | --ls | --info | --test)
            xspec="!"$xspec
        ;;
        --force)
            xspec=
        ;;
        --*)

        ;;
        -*f* | '<' | '>')
            xspec=
        ;;
        -*[dltx]*)
            xspec="!"$xspec
        ;;
    esac;
    _expand || return 0;
    local IFS='
';
    _compopt_o_filenames;
    COMPREPLY=($( compgen -f -X "$xspec" -- "$cur" ) $( compgen -d -- "$cur" ))
}
_mac_addresses () 
{ 
    local re='\([A-Fa-f0-9]\{2\}:\)\{5\}[A-Fa-f0-9]\{2\}';
    local PATH="$PATH:/sbin:/usr/sbin";
    COMPREPLY=("${COMPREPLY[@]}" $( ifconfig -a 2>/dev/null | sed -ne         "s/.*[[:space:]]HWaddr[[:space:]]\{1,\}\($re\)[[:space:]]*$/\1/p" ));
    COMPREPLY=("${COMPREPLY[@]}" $( arp -an 2>/dev/null | sed -ne         "s/.*[[:space:]]\($re\)[[:space:]].*/\1/p" -ne         "s/.*[[:space:]]\($re\)[[:space:]]*$/\1/p" ));
    COMPREPLY=("${COMPREPLY[@]}" $( sed -ne         "s/^[[:space:]]*\($re\)[[:space:]].*/\1/p" /etc/ethers 2>/dev/null ));
    COMPREPLY=($( compgen -W '${COMPREPLY[@]}' -- "$cur" ));
    __ltrim_colon_completions "$cur"
}
_make () 
{ 
    local file makef makef_dir="." makef_inc cur prev i split=false;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case $prev in 
        -f | -o | -W | --file | --makefile | --old-file | --new-file | --assume-old | --assume-new | --what-if)
            _filedir;
            return 0
        ;;
        -I | -C | --directory | --include-dir)
            _filedir -d;
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-b -m -B -C -d -e -f -h -i -I\
            -j -l -k -n -o -p -q -r -R - s -S -t -v -w -W \
            --always-make --directory --debug \
            --environment-overrides --file --makefile --help \
            --ignore-errors --include-dir --jobs --load-average \
            --max-load --keep-going --just-print --dry-run \
            --recon --old-file --assume-old --print-data-base \
            --question --no-builtin-rules --no-builtin-variables \
            --silent --quiet --no-keep-goind --stop --touch \
            --version --print-directory --no-print-directory \
            --what-if --new-file --assume-new \
            --warn-undefined-variables' -- "$cur" ));
    else
        for ((i=0; i < ${#COMP_WORDS[@]}; i++ ))
        do
            if [[ ${COMP_WORDS[i]} == -@(C|-directory) ]]; then
                eval makef_dir=${COMP_WORDS[i+1]};
                break;
            fi;
        done;
        for ((i=0; i < ${#COMP_WORDS[@]}; i++ ))
        do
            if [[ ${COMP_WORDS[i]} == -@(f|-?(make)file) ]]; then
                eval makef=${COMP_WORDS[i+1]};
                break;
            fi;
        done;
        [ -n "$makef" ] && makef="-f ${makef}";
        [ -n "$makef_dir" ] && makef_dir="-C ${makef_dir}";
        COMPREPLY=($( compgen -W "$( make -qp $makef $makef_dir 2>/dev/null |             awk -F':' '/^[a-zA-Z0-9][^$#\/\t=]*:([^=]|$)/ \
            {split($1,A,/ /);for(i in A)print A[i]}' )"             -- "$cur" ));
    fi
}
_makepkg () 
{ 
    local cur opts prev;
    COMPREPLY=();
    cur=$(_get_cword);
    prev=${COMP_WORDS[COMP_CWORD-1]};
    if [[ $cur = -* && ! $prev =~ ^-(-(cleancache|config|help)$|\w*[Chp]) ]]; then
        opts=('allsource asroot clean cleancache config force geninteg help holdver
           ignorearch install log nobuild nocolor noconfirm nodeps noextract
           noprogressbar pkg repackage rmdeps skipinteg source syncdeps' 'A C L R c d e f g h i m o p r s');
        _arch_ptr2comp opts;
    fi;
    true
}
_man () 
{ 
    local cur i prev sect manpath manext mansect uname;
    manext="@([0-9lnp]|[0-9][px]|man|3pm)?(.@([gx]z|bz2|lzma|Z))";
    mansect="@([0-9lnp]|[0-9][px]|3pm)";
    COMPREPLY=();
    _get_comp_words_by_ref -n : cur prev;
    if [[ "$prev" == -l ]]; then
        _filedir $manext;
        return 0;
    fi;
    _expand || return 0;
    if [[ "$cur" == */* ]]; then
        _filedir $manext;
        return 0;
    fi;
    uname=$( uname -s );
    if [[ $uname == @(Linux|GNU|GNU/*|FreeBSD|Cygwin|CYGWIN_*) ]]; then
        manpath=$( manpath 2>/dev/null || command man --path );
    else
        manpath=$MANPATH;
    fi;
    if [ -z "$manpath" ]; then
        COMPREPLY=($( compgen -c -- "$cur" ));
        return 0;
    fi;
    [[ "$prev" == $mansect ]] && sect=$prev || sect='*';
    manpath=$manpath:;
    if [ -n "$cur" ]; then
        manpath="${manpath//://*man$sect/$cur* } ${manpath//://*cat$sect/$cur* }";
    else
        manpath="${manpath//://*man$sect/ } ${manpath//://*cat$sect/ }";
    fi;
    COMPREPLY=($( eval command ls "$manpath" 2>/dev/null ));
    COMPREPLY=(${COMPREPLY[@]##*/?(:)});
    COMPREPLY=(${COMPREPLY[@]%.@([gx]z|bz2|lzma|Z)});
    COMPREPLY=($( compgen -W '${COMPREPLY[@]%.*}' -- "${cur//\\\\/}" ));
    if [[ "$prev" != $mansect ]]; then
        local start=${#COMPREPLY[@]};
        _filedir $manext;
        for ((i=$start; i < ${#COMPREPLY[@]}; i++ ))
        do
            [[ ${COMPREPLY[i]} == */* ]] || COMPREPLY[i]=./${COMPREPLY[i]};
        done;
    fi;
    __ltrim_colon_completions "$cur";
    return 0
}
_mc () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case $prev in 
        -e | --edit | -v | --view | -l | --ftplog | -P | --printwd)
            _filedir;
            return 0
        ;;
        -C | --colors | -D | --debuglevel)
            return 0
        ;;
        -h | --help | -V | --version)
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--stickchars --nocolor --color --colors \
            --nomouse --edit --datadir --resetsoft --ftplog --printwd --slow \
            --termcap --nosubshell --subshell --view --version --xterm \
            --debuglevel --help' -- "$cur" ));
    else
        _filedir -d;
    fi
}
_mdadm () 
{ 
    local cur prev mode options split=false;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case $prev in 
        -c | --config | -b | --bitmap | --backup-file)
            _filedir;
            return 0
        ;;
        -l | --level)
            _mdadm_raid_level;
            return 0
        ;;
        -p | --layout | --parity)
            _mdadm_raid_layout;
            return 0
        ;;
        -a | --auto)
            _mdadm_auto_flag;
            return 0
        ;;
        -U | --update)
            _mdadm_update_flag;
            return 0
        ;;
    esac;
    $split && return 0;
    options='--help --help-options --version --verbose --quiet \
        --brief --force --config --scan --metadata --homehost';
    if [[ "$cur" == -* ]]; then
        if [[ $COMP_CWORD -eq 1 ]]; then
            COMPREPLY=($( compgen -W "$options --assemble --build                 --create --monitor --grow" -- "$cur" ));
        else
            case ${COMP_WORDS[COMP_CWORD-1]} in 
                -A | --assemble)
                    COMPREPLY=($( compgen -W "$options --uuid                         --super-minor --name --force --run                         --no-degraded --auto --bitmap --backup-file                         --update --auto-update-homehost" -- "$cur" ))
                ;;
                -B | -C | -G | --build | --create | --grow)
                    COMPREPLY=($( compgen -W "$options --raid-devices                         --spare-devices --size --chunk --rounding                         --level --layout --parity --bitmap                         --bitmap-chunk --write-mostly --write-behind                         --assume-clean --backup-file --name --run                         --force --auto" -- "$cur" ))
                ;;
                -F | --follow | --monitor)
                    COMPREPLY=($( compgen -W "$options --mail --program                         --alert --syslog --delay --daemonise                         --pid-file --oneshot --test" -- "$cur" ))
                ;;
                /dev/* | --add | --fail | --remove)
                    COMPREPLY=($( compgen -W "$options --add --re-add                         --remove --fail --set-faulty" -- "$cur" ))
                ;;
                *)
                    COMPREPLY=($( compgen -W "$options --query --detail                         --examine --sparc2.2 --examine-bitmap --run                         --stop --readonly --readwrite                         --zero-superblock --test" -- "$cur" ))
                ;;
            esac;
        fi;
    else
        cur=${cur:=/dev/};
        _filedir;
    fi
}
_mdadm_auto_flag () 
{ 
    COMPREPLY=($( compgen -W 'no yes md mdp part p' -- "$cur" ))
}
_mdadm_raid_layout () 
{ 
    local level;
    for ((i=1; i < COMP_CWORD; i++ ))
    do
        if [[ "${COMP_WORDS[i]}" == -@(l|-level) ]]; then
            level=${COMP_WORDS[i+1]};
            break;
        fi;
    done;
    case $level in 
        raid5)
            COMPREPLY=($( compgen -W 'left-asymmetric left-symmetric \
                right-asymmetric right-symmetric la ra ls rs' -- "$cur" ))
        ;;
        raid10)
            COMPREPLY=($( compgen -W 'n o p' -- "$cur" ))
        ;;
        faulty)
            COMPREPLY=($( compgen -W 'write-transient wt read-transient rt \
                write-persistent wp read-persistent rp write-all read-fixable \
                rf clear flush none' -- $cur ))
        ;;
    esac
}
_mdadm_raid_level () 
{ 
    local mode;
    for ((i=1; i < COMP_CWORD; i++ ))
    do
        case ${COMP_WORDS[i]} in 
            -C | --create)
                mode=create;
                break
            ;;
            -B | --build)
                mode=build;
                break
            ;;
        esac;
    done;
    case $mode in 
        create)
            COMPREPLY=($( compgen -W 'linear raid0 0 stripe raid1 1 mirror \
                raid4 4 raid5 5 raid6 6 raid10 10 multipath mp faulty'                 -- "$cur" ))
        ;;
        build)
            COMPREPLY=($( compgen -W 'linear stripe raid0 0 raid1 multipath \
                mp faulty' -- "$cur" ))
        ;;
    esac
}
_mdadm_update_flag () 
{ 
    COMPREPLY=($( compgen -W 'sparc2.2 summaries uuid name homehost resync \
        byteorder super-minor' -- "$cur" ))
}
_mii_tool () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case $prev in 
        -F | --force)
            COMPREPLY=($( compgen -W '100baseTx-FD 100baseTx-HD \
                10baseT-FD 10baseT-HD' -- "$cur" ));
            return 0
        ;;
        -A | --advertise)
            COMPREPLY=($( compgen -W '100baseT4 100baseTx-FD 100baseTx-HD \
                10baseT-FD 10baseT-HD' -- "$cur" ));
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--verbose --version --reset --restart \
            --watch --log --advertise --force' -- "$cur" ));
    else
        _available_interfaces -a;
    fi
}
_mktemp () 
{ 
    COMPREPLY=();
    local cur prev split=false;
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case "$prev" in 
        --help | --version | --suffix)
            return 0
        ;;
        --tmpdir | -p)
            _filedir -d;
            return 0
        ;;
    esac;
    $split && return 0;
    [[ "$cur" == -* ]] && COMPREPLY=($( compgen -W '-d -u -q -p -t' -- "$cur" ))
}
_modules () 
{ 
    local modpath;
    modpath=/lib/modules/$1;
    COMPREPLY=($( compgen -W "$( command ls -R $modpath |         sed -ne 's/^\(.*\)\.k\{0,1\}o\(\.gz\)\{0,1\}$/\1/p' )" -- "$cur" ))
}
_mogrify () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    _ImageMagick;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-adaptive-blur -adaptive-resize \
            -adaptive-sharpen -adjoin -affine -alpha -annotate \
            -antialias -attenuate -authenticate -auto-orient \
            -background -bias -black-point-compensation \
            -black-threshold -blue-primary -blur -border \
            -bordercolor -caption -channel -charcoal -chop -clip \
            -clip-mask -clip-path -clut -colorize -colors \
            -colorspace -comment -compose -compress -contrast \
            -contrast-stretch -convolve -cycle -debug -decipher \
            -define -delay -density -depth -despeckle -display \
            -dispose -distort -dither -draw -edge -emboss \
            -encipher -encoding -endian -enhance -equalize \
            -evaluate -extent -extract -family -fill -filter \
            -flip -floodfill -flop -font -format -frame -fuzz \
            -gamma -gaussian-blur -geometry -gravity \
            -green-primary -help -identify -implode -intent \
            -interlace -interpolate -label -lat -layers -level \
            -limit -linear-stretch -liquid-rescale -list -log \
            -loop -mask -mattecolor -median -modulate -monitor \
            -monochrome -motion-blur -negate -noise -normalize \
            -opaque -ordered-dither -orient -page -paint -path \
            -ping -pointsize -polaroid -posterize -preview -print \
            -profile -quality -quantize -quiet -radial-blur \
            -raise -random-threshold -recolor -red-primary \
            -regard-warnings -region -render -repage -resample \
            -resize -roll -rotate -sample -sampling-factor -scale \
            -scene -seed -segment -sepia-tone -set -shade -shadow \
            -sharpen -shave -shear -sigmoidal-contrast -size \
            -sketch -solarize -splice -spread -stretch -strip \
            -stroke -strokewidth -style -swirl -taint -texture \
            -threshold -thumbnail -tile -tile-offset -tint \
            -transform -transparent -transparent-color -transpose \
            -transverse -treedepth -trim -type -undercolor \
            -unique-colors -units -unsharp -verbose -version \
            -view -vignette -virtual-pixel -wave -weight \
            -white-point -white-threshold' -- "$cur" ));
    else
        if [[ "$cur" == +* ]]; then
            COMPREPLY=($( compgen -W '+compress +contrast +debug +dither \
            +endian +gamma +label +map +mask +matte +negate +page \
            +raise' -- "$cur" ));
        else
            _filedir;
        fi;
    fi
}
_montage () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    _ImageMagick;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-adjoin -affine -alpha \
            -authenticate -background -blue-primary -blur -border \
            -bordercolor -borderwidth -caption -channel -clone \
            -coalesce -colors -colorspace -comment -compose \
            -compress -crop -debug -define -density -depth \
            -display -dispose -dither -draw -encoding -endian \
            -extract -fill -filter -flatten -flip -flop -font \
            -format -frame -gamma -geometry -gravity \
            -green-primary -help -identify -interlace \
            -interpolate -label -limit -list -log -mattecolor \
            -mode -monitor -monochrome -origin -page -pointsize \
            -polaroid -profile -quality -quantize -quiet \
            -red-primary -regard-warnings -repage -resize \
            -respect-parenthesis -rotate -sampling-factor -scenes \
            -seed -set -shadow -size -strip -stroke -texture \
            -thumbnail -tile -title -transform -transparent \
            -transparent-color -treedepth -trim -type -units \
            -verbose -version -virtual-pixel \
            -white-point' -- "$cur" ));
    else
        if [[ "$cur" == +* ]]; then
            COMPREPLY=($( compgen -W '+adjoin +compress +debug +dither \
            +endian +gamma +label +matte +page' -- "$cur" ));
        else
            _filedir;
        fi;
    fi
}
_mount () 
{ 
    local cur sm host prev;
    COMPREPLY=();
    _get_comp_words_by_ref -n : cur prev;
    case $prev in 
        -t | --types)
            _fstypes;
            return 0
        ;;
    esac;
    [[ "$cur" == \\ ]] && cur="/";
    if [[ "$cur" == *:* ]]; then
        for sm in "$(type -P showmount)" {,/usr}/{,s}bin/showmount;
        do
            [ -x "$sm" ] || continue;
            COMPREPLY=($( compgen -W "$( "$sm" -e ${cur%%:*} |                 awk 'NR>1 {print $1}' )" -- "${cur#*:}" ));
            return 0;
        done;
    fi;
    if [[ "$cur" == //* ]]; then
        host=${cur#//};
        host=${host%%/*};
        if [ -n "$host" ]; then
            COMPREPLY=($( compgen -P "//$host" -W                 "$( smbclient -d 0 -NL $host 2>/dev/null |
                sed -ne '/^['"$'\t '"']*Sharename/,/^$/p' |
                sed -ne '3,$s|^[^A-Za-z]*\([^'"$'\t '"']*\).*$|/\1|p' )"                     -- "${cur#//$host}" ));
        fi;
    else
        if [ -r /etc/vfstab ]; then
            COMPREPLY=($( compgen -W "$( awk '! /^[ \t]*#/ {if ($3 ~ /\//) print $3}' /etc/vfstab )" -- "$cur" ));
        else
            if [ ! -e /etc/fstab ]; then
                COMPREPLY=($( compgen -W "$( mount | awk '! /^[ \t]*#/ {if ($3 ~ /\//) print $3}' )" -- "$cur" ));
            else
                if [ "$prev" = -L ]; then
                    _linux_fstab -L < /etc/fstab;
                else
                    if [ "$prev" = -U ]; then
                        COMPREPLY=($( compgen -W '$(sed -ne "s/^[[:space:]]*UUID=\([^[:space:]]*\).*/\1/p" /etc/fstab )' -- "$cur" ));
                    else
                        _linux_fstab < /etc/fstab;
                    fi;
                fi;
            fi;
        fi;
    fi;
    return 0
}
_mpc () 
{ 
    local c=1 word command;
    while [ $c -lt $COMP_CWORD ]; do
        word="${COMP_WORDS[c]}";
        case "$word" in 
            --host=*)
                MPD_HOST="${word#--host=}"
            ;;
            --port=*)
                MPD_PORT="${word#--host=}"
            ;;
            -f | --format | --wait | -q | --quiet | --no-status | -v | --verbose)

            ;;
            *)
                command="$word";
                break
            ;;
        esac;
        c=$((c+1));
    done;
    cur="${COMP_WORDS[COMP_CWORD]}";
    if [ -z "$command" ]; then
        case "$cur" in 
            --*)
                _mpc_long_options
            ;;
            -*)
                COMPREPLY=()
            ;;
            *)
                _mpc_commands
            ;;
        esac;
        return;
    fi;
    case "$command" in 
        add)
            _mpc_add
        ;;
        clear)

        ;;
        consume)
            _mpc_boolean
        ;;
        crop)

        ;;
        crossfade)

        ;;
        current)

        ;;
        del)

        ;;
        load)
            _mpc_playlists
        ;;
        ls)
            _mpc_ls
        ;;
        lsplaylists)

        ;;
        move)

        ;;
        next)

        ;;
        pause)

        ;;
        play)

        ;;
        prev)

        ;;
        random)
            _mpc_boolean
        ;;
        repeat)
            _mpc_boolean
        ;;
        rm)
            _mpc_playlists
        ;;
        save)
            _mpc_playlists
        ;;
        search)
            _mpc_search
        ;;
        seek)

        ;;
        single)
            _mpc_boolean
        ;;
        stats)

        ;;
        status)

        ;;
        stop)

        ;;
        toggle)

        ;;
        version)

        ;;
        volume)

        ;;
        *)

        ;;
    esac
}
_mpc_add () 
{ 
    local IFS='
';
    __get_long_cur;
    COMPREPLY=($(mpc tab $(eval echo "$cur") | sed -re "s%^(${cur}[^/]*/?).*%\\1%" | sort -u | __escape_strings_stdin))
}
_mpc_boolean () 
{ 
    local IFS='
';
    COMPREPLY=($(IFS=' '; compgen -W "true false yes no on off" -S ' ' "$cur"))
}
_mpc_commands () 
{ 
    local IFS='
';
    hold=$(mpc help 2>&1 | awk '/^ *mpc [a-z]+ /{print $2" "}');
    COMPREPLY=($(compgen -W "$hold"'
'"status " "$cur"))
}
_mpc_long_options () 
{ 
    local IFS='
';
    COMPREPLY=($(mpc help | grep -o -- "$cur"'[a-z-]*=\?' | sed 's/[^=]$/& /'))
}
_mpc_ls () 
{ 
    local success IFS='
';
    __get_long_cur;
    if [ -z "$cur" ]; then
        COMPREPLY=($(mpc ls | sed 's@$@/@' | __escape_strings_stdin));
    else
        COMPREPLY=($(mpc ls $(eval echo "$cur") 2> /dev/null | __escape_strings_stdin));
        if [ ${#COMPREPLY[*]} -eq 0 ]; then
            COMPREPLY=($(mpc lstab $(eval echo "$cur") | __escape_strings_stdin));
        fi;
    fi
}
_mpc_playlists () 
{ 
    local IFS='
';
    __get_long_cur;
    if [ -z "$cur" ]; then
        COMPREPLY=($(mpc lsplaylists | __escape_strings_stdin));
    else
        COMPREPLY=($(mpc loadtab $(eval echo "$cur") | __escape_strings_stdin));
    fi
}
_mpc_search () 
{ 
    local IFS='
';
    COMPREPLY=($(IFS=' '; compgen -W "artist album title track name genre date composer performer comment disc filename any" -S ' ' "$cur"))
}
_mplayer () 
{ 
    local cmd cur prev i j k=0;
    COMPREPLY=();
    cmd=${COMP_WORDS[0]};
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -[av][cfo] | -[av]fm | -vop | -fstype | -demuxer | -o[av]c | -of | -profile | -audio-demuxer | -sub-demuxer)
            _mplayer_options_list $cmd $prev;
            return 0
        ;;
        -show-profile)
            _mplayer_options_list $cmd -profile;
            return 0
        ;;
        -audiofile)
            _filedir '@(mp3|mpg|ogg|w?(a)v|mid|flac|mka|ape)';
            return 0
        ;;
        -font | -subfont)
            if [ "$prev" = -font ]; then
                _filedir '@(desc|ttf)';
            else
                _filedir ttf;
            fi;
            local IFS='
';
            COMPREPLY=("${COMPREPLY[@]}" $( compgen -W '$( fc-list 2>/dev/null )' -- "$cur" ));
            return 0
        ;;
        -sub)
            _filedir '@(srt|sub|txt|utf|rar|mpsub|smi|js|ssa|ass)';
            return 0
        ;;
        -vobsub)
            _filedir '@(idx|ifo|sub)';
            local IFS='
';
            COMPREPLY=($( for i in "${COMPREPLY[@]}"; do
                        if [[ -f $i && -r $i ]]; then
                            printf '%s\n' ${i%.*}
                        else
                            printf '%s\n' $i
                        fi
                       done ));
            return 0
        ;;
        -ifo)
            _filedir ifo;
            return 0
        ;;
        -cuefile)
            _filedir '@(bin|cue)';
            return 0
        ;;
        -skin)
            local -a dirs;
            if [ -n "$MPLAYER_SKINS_DIR" ]; then
                dirs=($MPLAYER_SKINS_DIR);
            else
                dirs=(/usr/share/mplayer/skins /usr/local/share/mplayer/skins);
            fi;
            local IFS='
';
            for i in ~/.mplayer/skins ${dirs[@]};
            do
                if [[ -d $i && -r $i ]]; then
                    for j in $( compgen -d $i/$cur );
                    do
                        COMPREPLY[$k]=${j#$i/};
                        k=$((++k));
                    done;
                fi;
            done;
            return 0
        ;;
        -cdrom-device)
            _cd_devices;
            _dvd_devices;
            return 0
        ;;
        -dvd-device)
            _filedir;
            return 0
        ;;
        -mixer | -dvdauth | -fb | -zrdev)
            cur=${cur:=/dev/};
            _filedir;
            return 0
        ;;
        -edl | -edlout | -lircconf | -menu-cfg | -playlist | -csslib | -dumpfile | -subfile | -vobsub | -aofile | -fbmodeconfig | -include | -o | -dvdkey | -passlogfile)
            _filedir;
            return 0
        ;;
        -autoq | -autosync | -loop | -menu-root | -speed | -sstep | -aid | -alang | -bandwidth | -cache | -chapter | -dvd | -dvdangle | -fps | -frames | -mc | -passwd | -user | -sb | -srate | -ss | -vcd | -vi | -vid | -vivo | -ffactor | -sid | -slang | -spualign | -spuaa | -spugauss | -vobsubid | -delay | -bpp | -brightness | -contrast | -dfbopts | -display | -fbmode | -geometry | -guiwid | -hue | -icelayer | -screen[wh] | -wid | -monitoraspect | -monitor-dotclock | -monitor-[hv]freq | -panscan | -saturation | -xineramascreen | -zrcrop | -zrnorm | -zrquality | -zr[xy]doff | -zr[vh]dec | -aspect | -pp | -x | -y | -xy | -z | -stereo | -audio-density | -audio-delay | -audio-preload | -endpos | -osdlevel | -ffourcc | -sws | -channels | -skiplimit | -format | -ofps | -aadriver | -aaosdcolor | -aasubcolor | -vobsubout | -vobsuboutid | -vobsuboutindex | -sub-bg-alpha | -sub-bg-color | -sub-cp | -sub-delay | -sub-fps | -sub-pos | -sub-align | -sub-width | -subfont-blur | -subfont-outline | -subfont-autoscale | -subfont-encoding | -subfont-osd-scale | -subfont-osd-text)
            return 0
        ;;
        -lavdopts)
            COMPREPLY=($( compgen -W 'bitexact bug= debug= ec= er= fast gray idct= lowres= sb= st= skiploopfilter= skipidct= skipframe= threads= vismv= vstats' -- "$cur" ));
            return 0
        ;;
        -lavcopts)
            COMPREPLY=($( compgen -W 'vcodec= vqmin= vqscale= vqmax= mbqmin= \
                mbqmax= vqdiff= vmax_b_frames= vme= vhq v4mv keyint= \
                vb_strategy= vpass= aspect= vbitrate= vratetol= vrc_maxrate= \
                vrc_minrate= vrc_buf_size= vb_qfactor= vi_qfactor= vb_qoffset= \
                vi_qoffset= vqblur= vqcomp= vrc_eq= vrc_override= \
                vrc_init_cplx= vqsquish= vlelim= vcelim= vstrict= vdpart \
                vpsize= gray vfdct= idct= lumi_mask= dark_mask= tcplx_mask= \
                scplx_mask= naq ildct format= pred qpel precmp= cmp= subcmp= \
                predia= dia= trell last_pred= preme= subq= psnr mpeg_quant aic \
                umv' -- "$cur" ));
            return 0
        ;;
        -ssf)
            COMPREPLY=($( compgen -W 'lgb= cgb= ls= cs= chs= cvs='                 -- "$cur" ));
            return 0
        ;;
        -jpeg)
            COMPREPLY=($( compgen -W 'noprogressive progressive nobaseline \
                baseline optimize= smooth= quality= outdir=' -- "$cur" ));
            return 0
        ;;
        -xvidopts)
            COMPREPLY=($( compgen -W 'dr2 nodr2' -- "$cur" ));
            return 0
        ;;
        -xvidencopts)
            COMPREPLY=($( compgen -W 'pass= bitrate= fixed_quant= me_quality= \
                4mv rc_reaction_delay_factor= rc_averaging_period= rc_buffer= \
                quant_range= min_key_interval= max_key_interval= mpeg_quant \
                mod_quant lumi_mask hintedme hintfile debug keyframe_boost= \
                kfthreshold= kfreduction=' -- "$cur" ));
            return 0
        ;;
        -divx4opts)
            COMPREPLY=($( compgen -W 'br= key= deinterlace q= min_quant= \
                max_quant= rc_period= rc_reaction_period= crispness= \
                rc_reaction_ratio= pass= vbrpass= help' -- "$cur" ));
            return 0
        ;;
        -info)
            COMPREPLY=($( compgen -W 'name= artist= genre= subject= \
                copyright= srcform= comment= help' -- "$cur" ));
            return 0
        ;;
        -lameopts)
            COMPREPLY=($( compgen -W 'vbr= abr cbr br= q= aq= ratio= vol= \
                mode= padding= fast preset= help' -- "$cur" ));
            return 0
        ;;
        -rawaudio)
            COMPREPLY=($( compgen -W 'on channels= rate= samplesize= format='                 -- "$cur" ));
            return 0
        ;;
        -rawvideo)
            COMPREPLY=($( compgen -W 'on fps= sqcif qcif cif 4cif pal ntsc w= \
                h= y420 yv12 yuy2 y8 format= size=' -- "$cur" ));
            return 0
        ;;
        -aop)
            COMPREPLY=($( compgen -W 'list= delay= format= fout= volume= mul= \
                softclip' -- "$cur" ));
            return 0
        ;;
        -dxr2)
            COMPREPLY=($( compgen -W 'ar-mode= iec958-encoded iec958-decoded \
                mute ucode= 75ire bw color interlaced macrovision= norm= \
                square-pixel ccir601-pixel cr-left= cr-right= cr-top= cr-bot= \
                ck-rmin= ck-gmin= ck-bmin= ck-rmax= ck-gmax= ck-bmax= ck-r= \
                ck-g= ck-b= ignore-cache= ol-osd= olh-cor= olw-cor= olx-cor= \
                oly-cor= overlay overlay-ratio= update-cache' -- "$cur" ));
            return 0
        ;;
        -tv)
            COMPREPLY=($( compgen -W 'on noaudio driver= device= input= freq= \
                outfmt= width= height= buffersize= norm= channel= chanlist= \
                audiorate= forceaudio alsa amode= forcechan= adevice= audioid= \
                volume= bass= treble= balance= fps= channels= immediatemode='                 -- "$cur" ));
            return 0
        ;;
        -mf)
            COMPREPLY=($( compgen -W 'on w= h= fps= type=' -- "$cur" ));
            return 0
        ;;
        -cdda)
            COMPREPLY=($( compgen -W 'speed= paranoia= generic-dev= \
                sector-size= overlap= toc-bias toc-offset= skip noskip' \ 
                -- "$cur" ));
            return 0
        ;;
        -input)
            COMPREPLY=($( compgen -W 'conf= ar-delay ar-rate keylist cmdlist \
                js-dev file' -- "$cur" ));
            return 0
        ;;
        -af)
            COMPREPLY=($( compgen -W 'resample resample= channels channels= \
                format format= volume volume= delay delay= pan pan= sub sub= \
                surround surround=' -- "$cur" ));
            return 0
        ;;
        -af-adv)
            COMPREPLY=($( compgen -W 'force= list=' -- "$cur" ));
            return 0
        ;;
        -noconfig)
            COMPREPLY=($( compgen -W 'all gui system user' -- "$cur" ));
            return 0
        ;;
    esac;
    case $cur in 
        -*)
            COMPREPLY=($( compgen -W '$( $cmd -nomsgcolor -nomsgmodule -list-options 2>/dev/null | \
                sed -ne '1,/^[[:space:]]*Name/d' \
                    -e "s/^[[:space:]]*/-/" -e "s/[[:space:]:].*//" \
                    -e "/^-\(Total\|.*\*\)\{0,1\}$/!p" )' -- "$cur" ))
        ;;
        *)
            _filedir '@(mp?(e)g|MP?(E)G|wm[av]|WM[AV]|avi|AVI|asf|ASF|vob|VOB|bin|BIN|dat|DAT|vcd|VCD|ps|PS|pes|PES|fl[iv]|FL[IV]|fxm|FXM|viv|VIV|rm?(j)|RM?(J)|ra?(m)|RA?(M)|yuv|YUV|mov|MOV|qt|QT|mp[234]|MP[234]|m4[av]|M4[AV]|og[gmavx]|OG[GMAVX]|w?(a)v|W?(A)V|dump|DUMP|mk[av]|MK[AV]|m4a|M4A|aac|AAC|m[24]v|M[24]V|dv|DV|rmvb|RMVB|mid|MID|t[ps]|T[PS]|3g[p2]|3gpp?(2)|mpc|MPC|flac|FLAC|vro|VRO|divx|DIVX|aif?(f)|AIF?(F)|m2t?(s)|M2T?(S)|vdr|VDR|xvid|XVID|ape|APE|gif|GIF|nut|NUT|bik|BIK|webm|WEBM|amr|AMR|awb|AWB|iso|ISO)?(.part)'
        ;;
    esac;
    return 0
}
_mplayer_options_list () 
{ 
    cur=${cur%\\};
    COMPREPLY=($( compgen -W "$( $1 -nomsgcolor -nomsgmodule $2 help 2>/dev/null |         sed -e '/^Available/,/^$/!d' -e '/^Available/d' | awk '{print $1}' |         sed -e 's/:$//' -e 's/^'${2#-}'$//' -e 's/<.*//' )" -- "$cur" ))
}
_mutt () 
{ 
    local cur prev;
    _get_comp_words_by_ref -n =+! cur prev;
    COMPREPLY=();
    case $cur in 
        -*)
            COMPREPLY=($( compgen -W '-A -a -b -c -e -f -F -H -i -m -n \
            -p -Q -R -s -v -x -y -z -Z -h' -- "$cur" ));
            return 0
        ;;
        *)
            case $prev in 
                -a | -f | -F | -H | -i)
                    _muttfiledir "$cur";
                    return 0
                ;;
                -A)
                    _muttaliases "$cur";
                    return 0
                ;;
                -e | -m | -Q | -s | -h | -p | -R | -v | -y | -z | -Z)
                    return 0
                ;;
                *)
                    _muttaddr "$cur";
                    return 0
                ;;
            esac
        ;;
    esac
}
_muttaddr () 
{ 
    _muttaliases "$1";
    _muttquery "$1";
    COMPREPLY=("${COMPREPLY[@]}" $( compgen -u -- "$1" ));
    return 0
}
_muttaliases () 
{ 
    local cur=$1 muttrc muttcmd=${COMP_WORDS[0]};
    local -a conffiles aliases;
    muttrc=$(_muttrc);
    [ -z "$muttrc" ] && return 0;
    conffiles=($(eval _muttconffiles $muttrc $muttrc));
    aliases=($( sed -n 's|^alias[[:space:]]\{1,\}\([^[:space:]]\{1,\}\).*$|\1|p'         $(eval echo "${conffiles[@]}") ));
    COMPREPLY=("${COMPREPLY[@]}" $( compgen -W "${aliases[*]}" -- "$cur" ));
    return 0
}
_muttconffiles () 
{ 
    local file sofar;
    local -a newconffiles;
    sofar=" $1 ";
    shift;
    while [[ -n "$1" ]]; do
        newconffiles=($(sed -n 's|^source[[:space:]]\{1,\}\([^[:space:]]\{1,\}\).*$|\1|p' $(eval echo $1) ));
        for file in "${newconffiles[@]}";
        do
            [[ ! -f "$file" || "${sofar/ ${file} / }" != "$sofar" ]] && continue;
            sofar="$sofar $file";
            sofar=" $(eval _muttconffiles \"$sofar\" $file) ";
        done;
        shift;
    done;
    printf '%s\n' $sofar
}
_muttfiledir () 
{ 
    local cur=$1 folder muttrc spoolfile muttcmd=${COMP_WORDS[0]};
    muttrc=$(_muttrc);
    if [[ $cur == [=+]* ]]; then
        folder="$( $muttcmd -F "$muttrc" -Q folder | sed -e 's|^folder=\"\(.*\)\"$|\1|' )";
        : folder:=~/Mail;
        _compopt_o_filenames;
        COMPREPLY=($( compgen -f -- "$folder/${cur:1}" ));
        COMPREPLY=(${COMPREPLY[@]#$folder/});
        return 0;
    else
        if [ "$cur" == !* ]; then
            spoolfile="$( $muttcmd -F "$muttrc" -Q spoolfile |             sed -e 's|^spoolfile=\"\(.*\)\"$|\1|' )";
            [ ! -z "$spoolfile" ] && eval cur="${cur/^!/$spoolfile}";
        fi;
    fi;
    _filedir;
    return 0
}
_muttquery () 
{ 
    local cur=$1 querycmd muttcmd=${COMP_WORDS[0]};
    local -a queryresults;
    querycmd="$( $muttcmd -Q query_command | sed -e 's|^query_command=\"\(.*\)\"$|\1|' -e 's|%s|'$cur'|' )";
    if [[ -z "$cur" || -z "$querycmd" ]]; then
        queryresults=();
    else
        queryresults=($( $querycmd |             sed -n '2,$s|^\([^[:space:]]\{1,\}\).*|\1|p' ));
    fi;
    COMPREPLY=("${COMPREPLY[@]}" $( compgen -W "${queryresults[*]}"         -- "$cur" ));
    return 0
}
_muttrc () 
{ 
    set -- "${COMP_WORDS[@]}";
    while [ $# -gt 0 ]; do
        if [ "${1:0:2}" = -F ]; then
            if [ ${#1} -gt 2 ]; then
                muttrc="$(dequote "${1:2}")";
            else
                shift;
                [ "$1" ] && muttrc="$(dequote "$1")";
            fi;
            break;
        fi;
        shift;
    done;
    if [ -z "$muttrc" ]; then
        if [ -f ~/.${muttcmd}rc ]; then
            muttrc="~/.${muttcmd}rc";
        else
            if [ -f ~/.${muttcmd}/${muttcmd}rc ]; then
                muttrc="~/.${muttcmd}/${muttcmd}rc";
            fi;
        fi;
    fi;
    printf "%s" "$muttrc"
}
_mysqladmin () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case $prev in 
        -u | --user)
            COMPREPLY=($( compgen -u -- "$cur" ));
            return 0
        ;;
        -h | --host)
            _known_hosts_real "$cur";
            return 0
        ;;
        --character-sets-dir | --ssl-capath)
            _filedir -d;
            return 0
        ;;
        -S | --socket)
            _filedir sock;
            return 0
        ;;
        --defaults-file | --defaults-extra-file)
            _filedir;
            return 0
        ;;
        -c | --count | --default-character-set | -P | --port | -O | --set-variable | -i | --sleep | --ssl-ca | --ssl-cert | --ssl-cipher | --ssl-key | -w | --wait | --connect_timeout | --shutdown_timeout)
            return 0
        ;;
        '-?' | --help | -V | --version)
            return 0
        ;;
    esac;
    $split && return 0;
    COMPREPLY=($( compgen -W '--count --debug-check --debug-info --force \
        --compress --character-sets-dir --default-character-set --help --host \
        --no-beep --password --port --protocol --relative --set-variable \
        --silent --socket --sleep --ssl --ssl-ca --ssl-capath --ssl-cert \
        --ssl-cipher --ssl-key --ssl-verify-server-cert --user --verbose \
        --version --vertical --wait --connect_timeout --shutdown_timeout \
        --print-defaults --no-defaults --defaults-file --defaults-extra-file'         -- "$cur" ));
    COMPREPLY=("${COMPREPLY[@]}" $( compgen -W 'create debug drop extended-status flush-hosts \
        flush-logs flush-status flush-tables flush-threads flush-privileges \
        kill password old-password ping processlist reload refresh shutdown \
        status start-slave stop-slave variables version' -- "$cur" ))
}
_netcfg () 
{ 
    local cur prev opts lopts cmds prfls;
    COMPREPLY=();
    cur="${COMP_WORDS[COMP_CWORD]}";
    prev="${COMP_WORDS[COMP_CWORD-1]}";
    opts="-c -d -a -i -h -v";
    lopts="--help --version";
    cmds="check-iface down all-down iface-down all-resume all-suspend";
    prfls="`find /etc/network.d -maxdepth 1 -not -type d -printf '%f\n'`";
    case "${cur}" in 
        --*)
            COMPREPLY=($( compgen -W "${lopts}" -- $cur ));
            return 0
        ;;
        -*)
            COMPREPLY=($( compgen -W "${opts} ${lopts}" -- $cur ));
            return 0
        ;;
        *)
            if [ $COMP_CWORD -eq 1 ]; then
                COMPREPLY=($( compgen -W "${opts} ${lopts} ${cmds} ${prfls}" -- $cur ));
            fi
        ;;
    esac;
    case "${prev}" in 
        -c | check-iface | -i | iface-down)
            _connected_intfs;
            return 0
        ;;
        -d | down)
            _connected_prfls;
            return 0
        ;;
        *)

        ;;
    esac;
    return 0
}
_newgrp () 
{ 
    COMPREPLY=();
    if [[ "`_get_cword`" == "-" ]]; then
        COMPREPLY=(-);
    else
        _allowed_groups;
    fi
}
_newusers () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case $prev in 
        -c | --crypt)
            COMPREPLY=($( compgen -W 'DES MD5 NONE SHA256 SHA512'                 -- "$cur" ));
            return 0
        ;;
        -s | --sha-rounds)
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--crypt-method --help --system \
            --sha-rounds' -- "$cur" ));
        return 0;
    fi;
    _filedir
}
_ntpdate () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -k)
            _filedir;
            return 0
        ;;
        -U)
            COMPREPLY=($( compgen -u "$cur"  ));
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-4 -6 -b -B -d -Q -q -s -u -v -a\
            -e -k -p -o -r -t' -- "$cur" ));
    else
        _known_hosts_real "$cur";
    fi
}
_openssl () 
{ 
    local cur prev commands command options formats;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    commands='asn1parse ca ciphers crl crl2pkcs7 dgst dh dhparam dsa \
        dsaparam ec ecparam enc engine errstr gendh gendsa genrsa \
        nseq ocsp passwd pkcs12 pkcs7 pkcs8 prime rand req rsa \
        rsautl s_client s_server s_time sess_id smime speed spkac \
        verify version x509 md2 md4 md5 rmd160 sha sha1 aes-128-cbc \
        aes-128-ecb aes-192-cbc aes-192-ecb aes-256-cbc aes-256-ecb \
        base64 bf bf-cbc bf-cfb bf-ecb bf-ofb camellia-128-cbc \
        camellia-128-ecb camellia-192-cbc camellia-192-ecb \
        camellia-256-cbc camellia-256-ecb cast cast-cbc cast5-cbc \
        cast5-cfb cast5-ecb cast5-ofb des des-cbc des-cfb des-ecb \
        des-ede des-ede-cbc des-ede-cfb des-ede-ofb des-ede3 \
        des-ede3-cbc des-ede3-cfb des-ede3-ofb des-ofb des3 desx rc2 \
        rc2-40-cbc rc2-64-cbc rc2-cbc rc2-cfb rc2-ecb rc2-ofb rc4 \
        rc4-40';
    if [ $COMP_CWORD -eq 1 ]; then
        COMPREPLY=($( compgen -W "$commands" -- "$cur" ));
    else
        command=${COMP_WORDS[1]};
        case $prev in 
            -CA | -CAfile | -CAkey | -CAserial | -cert | -certfile | -config | -content | -dcert | -dkey | -dhparam | -extfile | -in | -inkey | -kfile | -key | -keyout | -out | -oid | -prvrify | -rand | -recip | -revoke | -sess_in | -sess_out | -spkac | -sign | -signkey | -signer | -signature | -ss_cert | -untrusted | -verify)
                _filedir;
                return 0
            ;;
            -outdir | -CApath)
                _filedir -d;
                return 0
            ;;
            -name | -crlexts | -extensions)
                _openssl_sections;
                return 0
            ;;
            -inform | -outform | -keyform | -certform | -CAform | -CAkeyform | -dkeyform | -dcertform)
                formats='DER PEM';
                case $command in 
                    x509)
                        formats="$formats NET"
                    ;;
                    smime)
                        formats="$formats SMIME"
                    ;;
                esac;
                COMPREPLY=($( compgen -W "$formats" -- "$cur" ));
                return 0
            ;;
            -connect)
                _known_hosts_real "$cur";
                return 0
            ;;
            -starttls)
                COMPREPLY=($( compgen -W 'smtp pop3 imap ftp'                     -- "$cur" ));
                return 0
            ;;
            -cipher)
                COMPREPLY=($( compgen -W "$(openssl ciphers |                     tr ':' '\n')" -- "$cur" ));
                return 0
            ;;
        esac;
        if [[ "$cur" == -* ]]; then
            case $command in 
                asn1parse)
                    options='-inform -in -out -noout -offset -length -i -oid \
                        -strparse'
                ;;
                ca)
                    options='-verbose -config -name -gencrl -revoke \
                        -crl_reason -crl_hold -crl_compromise \
                        -crl_CA_compromise -crldays -crlhours -crlexts \
                        -startdate -enddate -days -md -policy -keyfile -key \
                        -passin -cert -selfsig -in -out -notext -outdir \
                        -infiles -spkac -ss_cert -preserveDN -noemailDN \
                        -batch -msie_hack -extensions -extfile -engine \
                        -subj -utf8 -multivalue-rdn'
                ;;
                ciphers)
                    options='-v -ssl2 -ssl3 -tls1'
                ;;
                crl)
                    options='-inform -outform -text -in -out -noout -hash \
                        -issuer -lastupdate -nextupdate -CAfile -CApath'
                ;;
                crl2pkcs7)
                    options='-inform -outform -in -out -print_certs'
                ;;
                dgst)
                    options='-md5 -md4 -md2 -sha1 -sha -mdc2 -ripemd160 -dss1 \
                        -c -d -hex -binary -out -sign -verify -prverify \
                        -signature'
                ;;
                dsa)
                    options='-inform -outform -in -passin -out -passout -des \
                        -des3 -idea -text -noout -modulus -pubin -pubout'
                ;;
                dsaparam)
                    options='-inform -outform -in -out -noout -text -C -rand \
                        -genkey'
                ;;
                enc)
                    options='-ciphername -in -out -pass -e -d -a -A -k -kfile \
                        -S -K -iv -p -P -bufsize -debug'
                ;;
                dhparam)
                    options='-inform -outform -in -out -dsaparam -noout -text \
                        -C -2 -5 -rand'
                ;;
                gendsa)
                    options='-out -des -des3 -idea -rand'
                ;;
                genrsa)
                    options='-out -passout -des -des3 -idea -f4 -3 -rand'
                ;;
                pkcs7)
                    options='-inform -outform -in -out -print_certs -text \
                        -noout'
                ;;
                rand)
                    options='-out -rand -base64'
                ;;
                req)
                    options='-inform -outform -in -passin -out -passout -text \
                        -noout -verify -modulus -new -rand -newkey -newkey \
                        -nodes -key -keyform -keyout -md5 -sha1 -md2 -mdc2 \
                        -config -x509 -days -asn1-kludge -newhdr -extensions \
                        -reqexts section'
                ;;
                rsa)
                    options='-inform -outform -in -passin -out -passout \
                        -sgckey -des -des3 -idea -text -noout -modulus -check \
                        -pubin -pubout -engine'
                ;;
                rsautl)
                    options='-in -out -inkey -pubin -certin -sign -verify \
                        -encrypt -decrypt -pkcs -ssl -raw -hexdump -asn1parse'
                ;;
                s_client)
                    options='-connect -verify -cert -certform -key -keyform \
                        -pass -CApath -CAfile -reconnect -pause -showcerts \
                        -debug -msg -nbio_test -state -nbio -crlf -ign_eof \
                        -quiet -ssl2 -ssl3 -tls1 -no_ssl2 -no_ssl3 -no_tls1 \
                        -bugs -cipher -starttls -engine -tlsextdebug \
                        -no_ticket -sess_out -sess_in -rand'
                ;;
                s_server)
                    options='-accept -context -verify -Verify -crl_check \
                        -crl_check_all -cert -certform -key -keyform -pass \
                        -dcert -dcertform -dkey -dkeyform -dpass -dhparam \
                        -nbio -nbio_test -crlf -debug -msg -state -CApath \
                        -CAfile -nocert -cipher -quiet -no_tmp_rsa -ssl2 \
                        -ssl3 -tls1 -no_ssl2 -no_ssl3 -no_tls1 -no_dhe \
                        -bugs -hack -www -WWW -HTTP -engine -tlsextdebug \
                        -no_ticket -id_prefix -rand'
                ;;
                s_time)
                    options='-connect -www -cert -key -CApath -CAfile -reuse \
                        -new -verify -nbio -time -ssl2 -ssl3 -bugs -cipher'
                ;;
                sess_id)
                    options='-inform -outform -in -out -text -noout -context \
                        ID'
                ;;
                smime)
                    options='-encrypt -decrypt -sign -verify -pk7out -des \
                        -des3 -rc2-40 -rc2-64 -rc2-128 -aes128 -aes192 -aes256 \
                        -in -certfile -signer -recip -inform -passin -inkey \
                        -out -outform -content -to -from -subject -text -rand'
                ;;
                speed)
                    options='-engine'
                ;;
                verify)
                    options='-CApath -CAfile -purpose -untrusted -help \
                        -issuer_checks -verbose -certificates'
                ;;
                x509)
                    options='-inform -outform -keyform -CAform -CAkeyform -in \
                        -out -serial -hash -subject_hash -issuer_hash -subject \
                        -issuer -nameopt -email -startdate -enddate -purpose \
                        -dates -modulus -fingerprint -alias -noout -trustout \
                        -clrtrust -clrreject -addtrust -addreject -setalias \
                        -days -set_serial -signkey -x509toreq -req -CA -CAkey \
                        -CAcreateserial -CAserial -text -C -md2 -md5 -sha1 \
                        -mdc2 -clrext -extfile -extensions -engine'
                ;;
                md5 | md4 | md2 | sha1 | sha | mdc2 | ripemd160)
                    options='-c -d'
                ;;
            esac;
            COMPREPLY=($( compgen -W "$options" -- "$cur" ));
        else
            if [[ "$command" == speed ]]; then
                COMPREPLY=($( compgen -W 'md2 mdc2 md5 hmac sha1 rmd160 \
                    idea-cbc rc2-cbc rc5-cbc bf-cbc des-cbc des-ede3 rc4 \
                    rsa512 rsa1024 rsa2048 rsa4096 dsa512 dsa1024 dsa2048 idea \
                    rc2 des rsa blowfish' -- "$cur" ));
            else
                _filedir;
            fi;
        fi;
    fi
}
_openssl_sections () 
{ 
    local config f;
    for ((i=2; i < COMP_CWORD; i++ ))
    do
        if [[ "${COMP_WORDS[i]}" == -config ]]; then
            config=${COMP_WORDS[i+1]};
            break;
        fi;
    done;
    if [ -z "$config" ]; then
        for f in /etc/ssl/openssl.cnf /etc/pki/tls/openssl.cnf /usr/share/ssl/openssl.cnf;
        do
            [ -f $f ] && config=$f && break;
        done;
    fi;
    [ ! -f "$config" ] && return 0;
    COMPREPLY=($( compgen -W "$( awk '/\[.*\]/ {print $2}' $config )"         -- "$cur" ))
}
_pack200 () 
{ 
    COMPREPLY=();
    local cur prev;
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -S | --segment-limit | -P | --pass-file | -C | --class-attribute | -F | --field-attribute | -M | --method-attribute | -D | --code-attribute | '-?' | -h | --help | -V | --version | -J)
            return 0
        ;;
        -E | --effort)
            COMPREPLY=($( compgen -W '0 1 2 3 4 5 6 7 8 9' -- "$cur" ));
            return 0
        ;;
        -H | --deflate-hint)
            COMPREPLY=($( compgen -W 'true false keep' -- "$cur" ));
            return 0
        ;;
        -m | --modification-time)
            COMPREPLY=($( compgen -W 'latest keep' -- "$cur" ));
            return 0
        ;;
        -U | --unknown-attribute)
            COMPREPLY=($( compgen -W 'error strip pass' -- "$cur" ));
            return 0
        ;;
        -f | --config-file)
            _filedir properties;
            return 0
        ;;
        -l | --log-file)
            COMPREPLY=($( compgen -W '-' -- "$cur" ));
            _filedir log;
            return 0
        ;;
        -r | --repack)
            _filedir jar;
            return 0
        ;;
    esac;
    local i pack=false jar=false;
    for ((i=0; i < ${#COMP_WORDS[@]}-1; i++ ))
    do
        case ${COMP_WORDS[i]} in 
            *.pack | *.pack.gz)
                pack=true
            ;;
            *.jar)
                jar=true
            ;;
        esac;
    done;
    if ! $pack; then
        if [[ "$cur" == -* ]]; then
            COMPREPLY=($( compgen -W '--no-gzip --gzip --strip-debug \
                --no-keep-file-order --segment-limit= --effort= \
                --deflate-hint= --modification-time= --pass-file= \
                --unknown-attribute= --class-attribute= --field-attribute= \
                --method-attribute= --code-attribute= --config-file= \
                --verbose --quiet --log-file= --help --version -J \
                --repack' -- "$cur" ));
            [[ ${#COMPREPLY[@]} -eq 1 && ${COMPREPLY[0]} == *= ]] && type compopt &>/dev/null && compopt -o nospace;
        else
            _filedir 'pack?(.gz)';
        fi;
    else
        if ! $jar; then
            _filedir jar;
        fi;
    fi
}
_pacman () 
{ 
    local common core cur database prev query remove sync upgrade o;
    COMPREPLY=();
    cur=$(_get_cword);
    prev=${COMP_WORDS[COMP_CWORD-1]};
    database=('asdeps asexplicit');
    query=('changelog check deps explicit file foreign groups info list owns
          search unrequired upgrades' 'c e g i k l m o p s t u');
    remove=('cascade dbonly nodeps nosave print recursive unneeded' 'c k n p s u');
    sync=('asdeps asexplicit clean downloadonly force groups ignore ignoregroup
         info list needed nodeps print refresh search sysupgrade' 'c f g i l p s u w y');
    upgrade=('asdeps asexplicit force nodeps print' 'f p');
    common=('arch cachedir config dbpath debug help logfile noconfirm
           noprogressbar noscriptlet quiet root verbose' 'b d h q r v');
    core=('database help query remove sync upgrade version' 'D Q R S U V h');
    for o in 'D database' 'Q query' 'R remove' 'S sync' 'U upgrade';
    do
        _arch_incomp "$o" && break;
    done;
    if [[ $? != 0 ]]; then
        _arch_ptr2comp core;
    else
        if [[ ! $prev =~ ^-\w*[Vbhr] && ! $prev = --@(cachedir|config|dbpath|help|logfile|root|version) ]]; then
            [[ $cur = -* ]] && _arch_ptr2comp ${o#* } common || case ${o% *} in 
                D | R)
                    _pacman_pkg Qq
                ;;
                Q)
                    { 
                        _arch_incomp 'g groups' && _pacman_pkg Qg sort
                    } || { 
                        _arch_incomp 'p file' && _pacman_file
                    } || _arch_incomp 'o owns' || _arch_incomp 'u upgrades' || _pacman_pkg Qq
                ;;
                S)
                    { 
                        _arch_incomp 'g groups' && _pacman_pkg Sg
                    } || { 
                        _arch_incomp 'l list' && _pacman_pkg Sl sort
                    } || _pacman_pkg Slq
                ;;
                U)
                    _pacman_file
                ;;
            esac;
        fi;
    fi;
    true
}
_pacman_file () 
{ 
    compopt -o filenames;
    _filedir 'pkg.tar.*'
}
_pacman_pkg () 
{ 
    _arch_compgen "$(
    if [[ $2 ]]; then
      \pacman -$1 | \cut -d' ' -f1 | \sort -u
    else
      \pacman -$1
    fi
  )"
}
_parse_help () 
{ 
    $1 ${2:---help} 2>&1 | sed -e '/^[[:space:]]*-/!d' -e 's|[,/]| |g' | awk '{ print $1; if ($2 ~ /^-/) { print $2 } }' | sed -e 's|[<=].*||'
}
_passwd () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -n | -x | -w | -i | -\? | --help | --usage)
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-k -l --stdin -u -d -n -x -w -i -S \
            -? --help --usage' -- "$cur" ));
        return 0;
    fi;
    _allowed_users
}
_pci_ids () 
{ 
    COMPREPLY=(${COMPREPLY[@]:-} $( compgen -W         "$( PATH="$PATH:/sbin" lspci -n | awk '{print $3}')" -- "$cur" ))
}
_perl () 
{ 
    local cur prev prefix temp;
    local optPrefix optSuffix;
    COMPREPLY=();
    _get_comp_words_by_ref -n : cur prev;
    prefix="";
    if [[ "$cur" == -?* ]]; then
        temp=$cur;
        prev=${temp:0:2};
        cur=${temp:2};
        optPrefix=-P$prev;
        optSuffix=-S/;
        prefix=$prev;
    fi;
    case $prev in 
        -D | -e | -E | -i | -F | -l)
            return 0
        ;;
        -I | -x)
            local IFS='
';
            _compopt_o_filenames;
            COMPREPLY=($( compgen -d $optPrefix $optSuffix -- "$cur" ));
            return 0
        ;;
        -m | -M)
            temp="${cur#-}";
            prefix="$prefix${cur%$temp}";
            cur="$temp";
            _perlmodules $1;
            return 0
        ;;
        -V)
            if [[ $cur == :* ]]; then
                temp="${cur##+(:)}";
                prefix="$prefix${cur%$temp}";
                local IFS='
';
                COMPREPLY=($( compgen -P "$prefix" -W                     '$( $1 -MConfig -e "print join \"\\n\",
                        keys %Config::Config" 2>/dev/null )' -- "$temp" ));
                __ltrim_colon_completions "$prefix$temp";
            fi;
            return 0
        ;;
        -d | -dt)
            if [[ $cur == :* ]]; then
                temp="${cur#:}";
                prefix="$prefix${cur%$temp}";
                cur="Devel::$temp";
                _perlmodules $1;
            fi;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-C -s -T -u -U -W -X -h -v -V -c -w -d \
            -D -p -n -a -F -l -0 -I -m -M -P -S -x -i -e ' -- "$cur" ));
    else
        _filedir;
    fi
}
_perldoc () 
{ 
    local cur prev prefix temp;
    COMPREPLY=();
    _get_comp_words_by_ref -n : cur prev;
    prefix="";
    if [[ "$cur" == -?* ]]; then
        temp=$cur;
        prev=${temp:0:2};
        cur=${temp:2};
        prefix=$prev;
    fi;
    case $prev in 
        -f)
            _perlfunctions "$cur";
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-h -v -t -u -m -l -F -X -f -q' -- "$cur" ));
    else
        if [[ "$cur" != */* ]]; then
            _perlmodules;
            COMPREPLY=("${COMPREPLY[@]}" $( compgen -W                 '$( PAGER=/bin/cat man perl |  \
                sed -ne "/perl.*Perl overview/,/perlwin32/p" | \
                awk "\$NF=2 { print \$1}" | command grep perl )' -- "$cur" ));
        fi;
        _filedir 'p@(l|m|od)';
    fi
}
_perlfunctions () 
{ 
    COMPREPLY=($( compgen -P "$prefix" -W "$( ${BASH_SOURCE[0]%/*}/helpers/perl functions $cur )" -- "$cur" ))
}
_perlmodules () 
{ 
    COMPREPLY=($( compgen -P "$prefix" -W "$( $1 ${BASH_SOURCE[0]%/*}/helpers/perl modules $cur )" -- "$cur" ));
    __ltrim_colon_completions "$prefix$cur"
}
_pgids () 
{ 
    COMPREPLY=($( compgen -W '$( command ps axo pgid= )' -- "$cur" ))
}
_pgrep () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    _pnames;
    return 0
}
_physicalvolumes () 
{ 
    COMPREPLY=($(compgen -W "$( pvscan 2>/dev/null |         sed -n -e 's|^.*PV \(.*\) VG.*$|\1|p' )" -- "$cur" ))
}
_pids () 
{ 
    COMPREPLY=($( compgen -W '$( command ps axo pid= )' -- "$cur" ))
}
_pkg_config () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case $prev in 
        --variable | --define-variable | --atleast-version | --atleast-pkgconfig-version | --exact-version | --max-version)
            return 0
        ;;
        -\? | --help | --version | --usage)
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--version --modversion \
            --atleast-pkgconfig-version --libs --static \
            --short-errors --libs-only-l --libs-only-other \
            --libs-only-L --cflags --cflags-only-I \
            --cflags-only-other --variable --define-variable \
            --exists --uninstalled --atleast-version \
            --exact-version --max-version --list-all --debug \
            --print-errors --silence-errors --errors-to-stdout \
            --print-provides --print-requires --help --usage' -- "$cur"));
    else
        COMPREPLY=($( compgen -W "$( pkg-config --list-all             2>/dev/null | awk '{print $1}' )" -- "$cur" ));
    fi
}
_pm_action () 
{ 
    local cur;
    _get_comp_words_by_ref cur;
    COMPREPLY=($( compgen -W "--help $( _parse_help "$1" )" -- "$cur" ))
}
_pm_is_supported () 
{ 
    local cur;
    _get_comp_words_by_ref cur;
    COMPREPLY=($( compgen -W '--help --suspend --hibernate --suspend-hybrid'         -- "$cur" ))
}
_pm_powersave () 
{ 
    local cur;
    _get_comp_words_by_ref cur;
    COMPREPLY=($( compgen -W "true false" -- "$cur" ))
}
_pnames () 
{ 
    COMPREPLY=($( compgen -X '<defunct>' -W '$( command ps axo command= | \
        sed -e "s/ .*//" -e "s:.*/::" -e "s/:$//" -e "s/^[[(-]//" \
            -e "s/[])]$//" | sort -u )' -- "$cur" ))
}
_pvchange () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -A | -x | --autobackup | --allocatable)
            COMPREPLY=($( compgen -W 'y n' -- "$cur" ));
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--all --autobackup \
            --debug --help --test --uuid \
            --allocatable --verbose --addtag --deltag \
            --version' -- "$cur" ));
    else
        _physicalvolumes;
    fi
}
_pvcreate () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        --restorefile)
            _filedir;
            return 0
        ;;
        -M | --metadatatype)
            COMPREPLY=($( compgen -W '1 2' -- "$cur" ));
            return 0
        ;;
        --metadatacopies)
            COMPREPLY=($( compgen -W '0 1 2' -- "$cur" ));
            return 0
        ;;
        --metadatasize | --setphysicalvolumesize)
            _sizes;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--restorefile --debug \
            --force --help --labelsector --metadatatype \
            --metadatacopies --metadatasize \
            --setphysicalvolumesize --test --uuid \
            --verbose --yes --version' -- "$cur" ));
    else
        _physicalvolumes;
    fi
}
_pvdisplay () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        --units)
            _units;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--colon --columns --units \
            --verbose --debug --help --version' -- "$cur" ));
    else
        _physicalvolumes;
    fi
}
_pvmove () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -A | --autobackup)
            COMPREPLY=($( compgen -W 'y n' -- "$cur" ));
            return 0
        ;;
        -n | --name)
            _logicalvolumes;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--abort --autobackup \
            --background --debug --force --help --interval --test --verbose \
            --version --name' -- "$cur" ));
    else
        _physicalvolumes;
    fi
}
_pvremove () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--debug --force \
            --help --yes --test --verbose --version' -- "$cur" ));
    else
        _physicalvolumes;
    fi
}
_pvs () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -o | -O | --options | --sort)
            COMPREPLY=($( compgen -W 'pv_fmt pv_uuid \
                pv_size pv_free pv_used pv_name \
                pv_attr pv_pe_count \
                pv_pe_alloc_count' -- "$cur" ));
            return 0
        ;;
        --units)
            _units;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--aligned --all --debug \
            --help --ignorelockingfailure --noheadings \
            --nosuffix --options --sort --separator --unbuffered --units \
            --verbose --version' -- "$cur" ));
    else
        _physicalvolumes;
    fi
}
_pvscan () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--debug --exported --novolumegroup \
            --help --ignorelockingfailure --partial --short --uuid \
            --verbose --version' -- "$cur" ));
    fi
}
_pwck () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-q -r -s' -- "$cur" ));
        return 0;
    fi;
    _filedir
}
_python () 
{ 
    local prev cur i;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -'?' | -h | --help | -V | --version | -c | -m)
            return 0
        ;;
        -Q)
            COMPREPLY=($( compgen -W "old new warn warnall" -- "$cur" ));
            return 0
        ;;
        -W)
            COMPREPLY=($( compgen -W "ignore default all module once error"                 -- "$cur" ));
            return 0
        ;;
        !(?(*/)python*([0-9.])|-?))
            [[ $COMP_CWORD -lt 2 || ${COMP_WORDS[COMP_CWORD-2]} != -@(Q|W) ]] && _filedir
        ;;
    esac;
    for ((i=0; i < ${#COMP_WORDS[@]}-1; i++ ))
    do
        if [[ ${COMP_WORDS[i]} == -c ]]; then
            _filedir;
        fi;
    done;
    if [[ "$cur" != -* ]]; then
        _filedir 'py?([co])';
    else
        COMPREPLY=($( compgen -W "$( _parse_help $1 -h )" -- "$cur" ));
    fi;
    return 0
}
_python_django_completion () 
{ 
    if [[ ${COMP_CWORD} -ge 2 ]]; then
        PYTHON_EXE=$( basename -- ${COMP_WORDS[0]} );
        echo $PYTHON_EXE | egrep "python([2-9]\.[0-9])?" > /dev/null 2>&1;
        if [[ $? == 0 ]]; then
            PYTHON_SCRIPT=$( basename -- ${COMP_WORDS[1]} );
            echo $PYTHON_SCRIPT | egrep "manage\.py|django-admin(\.py)?" > /dev/null 2>&1;
            if [[ $? == 0 ]]; then
                COMPREPLY=($( COMP_WORDS="${COMP_WORDS[*]:1}"                                COMP_CWORD=$(( COMP_CWORD-1 ))                                DJANGO_AUTO_COMPLETE=1 ${COMP_WORDS[*]} ));
            fi;
        fi;
    fi
}
_qdbus () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    [ -n "$cur" ] && unset COMP_WORDS[${#COMP_WORDS[@]}-1];
    COMPREPLY=($( compgen -W '$( command ${COMP_WORDS[@]} 2>/dev/null | \
        sed s/\(.*\)// )' -- "$cur" ))
}
_quote_readline_by_ref () 
{ 
    if [[ ${1:0:1} == "'" ]]; then
        if [[ ${BASH_VERSINFO[0]} -ge 4 ]]; then
            printf -v $2 %s "${1:1}";
        else
            printf -v $2 %q "${1:1}";
            printf -v $2 %q ${!2};
        fi;
    else
        if [[ ${BASH_VERSINFO[0]} -le 3 && ${1:0:1} == '"' ]]; then
            printf -v $2 %q "${1:1}";
        else
            printf -v $2 %q "$1";
        fi;
    fi;
    [[ ${!2:0:1} == '$' ]] && eval $2=${!2}
}
_realcommand () 
{ 
    type -P "$1" > /dev/null && { 
        if type -p realpath > /dev/null; then
            realpath "$(type -P "$1")";
        else
            if type -p readlink > /dev/null; then
                readlink -f "$(type -P "$1")";
            else
                type -P "$1";
            fi;
        fi
    }
}
_renice () 
{ 
    local command cur curopt i;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    command=$1;
    i=0;
    while [[ $i -le $COMP_CWORD && ${#COMPREPLY[@]} -eq 0 ]]; do
        curopt=${COMP_WORDS[COMP_CWORD-$i]};
        case "$curopt" in 
            -u)
                _allowed_users
            ;;
            -g)
                _pgids
            ;;
            -p | $command)
                _pids
            ;;
        esac;
        i=$(( ++i ));
    done
}
_reply_compgen_array () 
{ 
    local i wlist;
    for i in ${!COMPREPLY[*]};
    do
        local q=$(quote "$(printf %q "${COMPREPLY[$i]}")");
        wlist+=$q'
';
    done;
    local ecur="$cur";
    ecur="${ecur//\\/\\\\}";
    ecur="${ecur//\'/\'}";
    local oldifs=$IFS;
    IFS='
' eval 'COMPREPLY=(`compgen -W "$wlist" -- "${ecur}"`)';
    IFS=$oldifs
}
_rl_enabled () 
{ 
    [[ "$( bind -v )" = *$1+([[:space:]])on* ]]
}
_rmmod () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    _installed_modules "$cur";
    return 0
}
_root_command () 
{ 
    local PATH=$PATH:/sbin:/usr/sbin:/usr/local/sbin;
    local root_command=$1;
    _command $1 $2 $3
}
_route () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    if [ "$prev" = dev ]; then
        _available_interfaces;
        return 0;
    fi;
    local i found;
    for opt in add del -host -net netmask metric mss window irtt reject mod dyn reinstate dev default gw;
    do
        found=false;
        for ((i=1; i < ${#COMP_WORDS[@]}-1; i++ ))
        do
            [ "${COMP_WORDS[i]}" = "$opt" ] && found=true && break;
        done;
        $found || COMPREPLY[${#COMPREPLY[@]}]="$opt";
    done;
    COMPREPLY=($( compgen -W '"${COMPREPLY[@]}"' -- "$cur" ))
}
_rrdtool () 
{ 
    local cur;
    _get_comp_words_by_ref cur;
    COMPREPLY=($( compgen -W 'create update updatev graph dump restore last \
        lastupdate first info fetch tune resize xport' -- "$cur" ))
}
_rtcwake () 
{ 
    COMPREPLY=();
    local cur prev split=false;
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case "$prev" in 
        --help | -h | --version | -V | --seconds | -s | --time | -t)
            return 0
        ;;
        --mode | -m)
            COMPREPLY=($( compgen -W 'standby mem disk on no off' -- "$cur" ));
            return 0
        ;;
        --device | -d)
            COMPREPLY=($( command ls -d /dev/rtc?* 2>/dev/null ));
            COMPREPLY=($( compgen -W '${COMPREPLY[@]#/dev/}' -- "$cur" ));
            return 0
        ;;
    esac;
    $split && return 0;
    COMPREPLY=($( compgen -W '--device --local --mode --seconds --time --utc \
        --verbose --version --help' -- "$cur" ))
}
_samba_debuglevel () 
{ 
    COMPREPLY=($( compgen -W '0 1 2 3 4 5 6 7 8 9 10' -- "$cur" ))
}
_samba_domains () 
{ 
    if [ -n "${COMP_SAMBA_SCAN:-}" ]; then
        COMPREPLY=($( compgen -W '$( smbtree -N -D )' -- "$cur" ));
    fi
}
_samba_hosts () 
{ 
    if [ -n "${COMP_SAMBA_SCAN:-}" ]; then
        COMPREPLY=($( compgen -W "$( smbtree -N -S |             sed -ne 's/^[[:space:]]*\\\\*\([^[:space:]]*\).*/\1/p'             )" -- $cur ));
    fi
}
_samba_resolve_order () 
{ 
    COMPREPLY=($( compgen -W 'lmhosts host wins bcast' -- "$cur" ))
}
_scp () 
{ 
    local configfile cur prev prefix;
    COMPREPLY=();
    _get_comp_words_by_ref -n : cur prev;
    _ssh_suboption_check && { 
        COMPREPLY=("${COMPREPLY[@]/%/ }");
        return 0
    };
    case $prev in 
        -l | -P)
            return 0
        ;;
        -F | -i | -S)
            _filedir;
            type compopt &>/dev/null && compopt +o nospace;
            return 0
        ;;
        -c)
            _ssh_ciphers;
            COMPREPLY=("${COMPREPLY[@]/%/ }");
            return 0
        ;;
        -o)
            _ssh_options;
            return 0
        ;;
    esac;
    _expand || return 0;
    if [[ "$cur" == *:* ]]; then
        _scp_remote_files;
        return 0;
    fi;
    if [[ "$cur" == -F* ]]; then
        cur=${cur#-F};
        prefix=-F;
    else
        set -- "${COMP_WORDS[@]}";
        while [ $# -gt 0 ]; do
            if [ "${1:0:2}" = -F ]; then
                if [ ${#1} -gt 2 ]; then
                    configfile="$(dequote "${1:2}")";
                else
                    shift;
                    [ "$1" ] && configfile="$(dequote "$1")";
                fi;
                break;
            fi;
            shift;
        done;
        case $cur in 
            -*)
                COMPREPLY=($( compgen -W '-1 -2 -4 -6 -B -C -c -F -i -l -o \
                    -P -p -q -r -S -v' -- "$cur" ));
                COMPREPLY=("${COMPREPLY[@]/%/ }");
                return 0
            ;;
            */*)

            ;;
            *)
                _known_hosts_real -c -a -F "$configfile" "$cur"
            ;;
        esac;
    fi;
    _scp_local_files "$prefix";
    return 0
}
_scp_local_files () 
{ 
    local IFS='
';
    local dirsonly=false;
    if [ "$1" = -d ]; then
        dirsonly=true;
        shift;
    fi;
    if $dirsonly; then
        COMPREPLY=("${COMPREPLY[@]}" $( command ls -aF1d $cur* 2>/dev/null |             sed -e "s/$_scp_path_esc/\\\\&/g" -e '/[^\/]$/d' -e "s/^/$1/"));
    else
        COMPREPLY=("${COMPREPLY[@]}" $( command ls -aF1d $cur* 2>/dev/null |             sed -e "s/$_scp_path_esc/\\\\&/g" -e 's/[*@|=]$//g'             -e 's/[^\/]$/& /g' -e "s/^/$1/"));
    fi
}
_scp_remote_files () 
{ 
    local IFS='
';
    cur=${cur/\\:/:};
    local userhost=${cur%%?(\\):*};
    local path=${cur#*:};
    path=$( sed -e 's/\\\\\\\('$_scp_path_esc'\)/\\\1/g' <<<"$path" );
    if [ -z "$path" ]; then
        path=$(ssh -o 'Batchmode yes' $userhost pwd 2>/dev/null);
    fi;
    local files;
    if [ "$1" = -d ]; then
        files=$( ssh -o 'Batchmode yes' $userhost             command ls -aF1d "$path*" 2>/dev/null |             sed -e 's/'$_scp_path_esc'/\\\\\\&/g' -e '/[^\/]$/d' );
    else
        files=$( ssh -o 'Batchmode yes' $userhost             command ls -aF1d "$path*" 2>/dev/null |             sed -e 's/'$_scp_path_esc'/\\\\\\&/g' -e 's/[*@|=]$//g'             -e 's/[^\/]$/& /g' );
    fi;
    COMPREPLY=("${COMPREPLY[@]}" $files)
}
_services () 
{ 
    local sysvdir famdir;
    [ -d /etc/rc.d/init.d ] && sysvdir=/etc/rc.d/init.d || sysvdir=/etc/init.d;
    famdir=/etc/xinetd.d;
    COMPREPLY=($( printf '%s\n'         $sysvdir/!(*.rpm@(orig|new|save)|*~|functions) ));
    if [ -d $famdir ]; then
        COMPREPLY=("${COMPREPLY[@]}" $( printf '%s\n'             $famdir/!(*.rpm@(orig|new|save)|*~) ));
    fi;
    COMPREPLY=($( compgen -W '${COMPREPLY[@]#@($sysvdir|$famdir)/}' -- "$cur" ))
}
_sftp () 
{ 
    local cur prev configfile;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    _ssh_suboption_check && return 0;
    case $prev in 
        -b | -F | -P)
            _filedir;
            return 0
        ;;
        -o)
            _ssh_options;
            return 0
        ;;
    esac;
    if [[ "$cur" == -F* ]]; then
        cur=${cur#-F};
        _filedir;
        COMPREPLY=("${COMPREPLY[@]/#/-F}");
        cur=-F$cur;
    else
        if [[ "$cur" == -* ]]; then
            COMPREPLY=($( compgen -W '-1 -C -v -B -b -F -o -P -R -S -s'             -- "$cur" ));
        else
            set -- "${COMP_WORDS[@]}";
            while [ $# -gt 0 ]; do
                if [ "${1:0:2}" = -F ]; then
                    if [ ${#1} -gt 2 ]; then
                        configfile="$(dequote "${1:2}")";
                    else
                        shift;
                        [ "$1" ] && configfile="$(dequote "$1")";
                    fi;
                    break;
                fi;
                shift;
            done;
            _known_hosts_real -a -F "$configfile" "$cur";
        fi;
    fi;
    return 0
}
_sh () 
{ 
    COMPREPLY=();
    local cur prev;
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -c)
            return 0
        ;;
        -o | +o)
            COMPREPLY=($( compgen -W 'allexport errexit ignoreeof monitor
                noclobber noglob noexec nolog notify nounset verbose vi
                xtrace' -- "$cur" ));
            return 0
        ;;
    esac;
    local opts="-a -b -C -e -f -h -i -m -n -o -u -v -x";
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W "$opts -c -s" -- "$cur" ));
        return 0;
    else
        if [[ "$cur" == +* ]]; then
            COMPREPLY=($( compgen -W "${opts//-/+}" -- "$cur" ));
            return 0;
        fi;
    fi;
    _filedir sh
}
_shells () 
{ 
    COMPREPLY=("${COMPREPLY[@]}" $( compgen -W         '$( command grep "^[[:space:]]*/" /etc/shells 2>/dev/null )'         -- "$cur" ))
}
_signals () 
{ 
    local i;
    COMPREPLY=($( compgen -A signal SIG${cur#-} ));
    for ((i=0; i < ${#COMPREPLY[@]}; i++ ))
    do
        COMPREPLY[i]=-${COMPREPLY[i]#SIG};
    done
}
_sizes () 
{ 
    COMPREPLY=($( compgen -W 'k K m M g G t T' -- "$cur" ))
}
_smbcacls () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case $prev in 
        -s)
            _filedir;
            return 0
        ;;
        -l | --log-basename)
            _filedir -d;
            return 0
        ;;
        -d | --debuglevel)
            _samba_debuglevel;
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-a -M -D -S -U -C -G --numeric -t \
            -h --help -V -s -d --debuglevel -l --log-basename' -- "$cur" ));
    fi
}
_smbclient () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case $prev in 
        -R)
            _samba_resolve_order;
            return 0
        ;;
        -t)
            COMPREPLY=($( compgen -W 'SJIS EUC JIS7 JIS8 JUNET HEX CAP'                 -- "$cur" ));
            return 0
        ;;
        -s | -A | --authentication-file)
            _filedir;
            return 0
        ;;
        -l | --log-basename | -D)
            _filedir -d;
            return 0
        ;;
        -O)
            COMPREPLY=($( compgen -W 'SO_KEEPALIVE SO_REUSEADDR \
                SO_BROADCAST TCP_NODELAY IPTOS_LOWDELAY \
                IPTOS_THROUGHPUT SO_SNDBUF SO_RCVBUF \
                SO_SNDLOWAT SO_RCVLOWAT' -- "$cur" ));
            return 0
        ;;
        -T)
            COMPREPLY=($( compgen -W 'c x I X F b g q r N a' -- "$cur" ));
            return 0
        ;;
        -W | --workgroup)
            _samba_domains;
            return 0
        ;;
        -d | --debuglevel)
            _samba_debuglevel;
            return 0
        ;;
        -p | --port | -M | -I | -b | -U | --user | -n | -i | -T | -c)
            return 0
        ;;
        -\? | --help | -V | --version)
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-b -d -L -U -I -M -m -A -N -i -O \
            -p -R -s -k -P -c -D -W -l -E --debuglevel \
            --log-basename --workgroup' -- "$cur" ));
    fi
}
_smbcquotas () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case $prev in 
        -s | -A | --authentication-file)
            _filedir;
            return 0
        ;;
        -l | --log-basename)
            _filedir -d;
            return 0
        ;;
        -d | --debuglevel)
            _samba_debuglevel;
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-u -L -F -S -n -t -v -h --help -V \
            -s --debuglevel --log-basename -N -k \
            --authentication-file --user' -- "$cur" ));
    fi
}
_smbget () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case $prev in 
        -o | -f | --outputfile | --rcfile)
            _filedir;
            return 0
        ;;
        -d | --debuglevel)
            _samba_debuglevel;
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-a --guest -r --resume -R --recursive -u \
            --username -p --password -w --workgroup -n --nonprompt -d \
            --debuglevel -D --dots -P --keep-permissions -o --outputfile -f \
            --rcfile -q --quiet -v --verbose -b --blocksize -? --help --usage'             -- "$cur" ));
    fi
}
_smbpasswd () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -r)
            _samba_hosts;
            return 0
        ;;
        -R)
            _samba_resolve_order;
            return 0
        ;;
        -c)
            _filedir;
            return 0
        ;;
        -D)
            _samba_debuglevel;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-a -c -x -d -e -D -n -r -R -m -U -h \
            -s -w -W -i -L' -- "$cur" ));
    fi
}
_smbtar () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -r | -t)
            _filedir tar;
            return 0
        ;;
        -s)
            _samba_hosts;
            return 0
        ;;
        -l)
            _samba_debuglevel;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-r -i -a -v -s -p -x -X -N -b -d -l -u -t'             -- "$cur" ));
    fi
}
_smbtree () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case $prev in 
        -s | -A | --authentication-file)
            _filedir;
            return 0
        ;;
        -l | --log-basename)
            _filedir -d;
            return 0
        ;;
        -d | --debuglevel)
            _samba_debuglevel;
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-b -D -S -V -s -d --debuglevel -l \
            --log-basename -N -k -A --authentication-file -U --user\
            -h --help' -- "$cur" ));
    fi
}
_split_longopt () 
{ 
    if [[ "$cur" == --?*=* ]]; then
        prev="${cur%%?(\\)=*}";
        cur="${cur#*=}";
        return 0;
    fi;
    return 1
}
_sqlite3 () 
{ 
    COMPREPLY=();
    local cur prev;
    _get_comp_words_by_ref cur prev;
    local dbexts='@(sqlite?(3)|?(s?(3))db)';
    case $prev in 
        -help | -version | -separator | -nullvalue | *.$dbexts)
            return 0
        ;;
        -init)
            _filedir;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-help -init -echo -header -noheader -bail
            -interactive -batch -column -csv -html -line -list -separator
            -nullvalue -version' -- "$cur" ));
        return 0;
    fi;
    _filedir $dbexts
}
_ssh () 
{ 
    local cur prev configfile;
    local -a config;
    COMPREPLY=();
    _get_comp_words_by_ref -n : cur prev;
    _ssh_suboption_check && return 0;
    case $prev in 
        -F | -i | -S)
            _filedir;
            return 0
        ;;
        -c)
            _ssh_ciphers;
            return 0
        ;;
        -m)
            _ssh_macs;
            return 0
        ;;
        -l)
            COMPREPLY=($( compgen -u -- "$cur" ));
            return 0
        ;;
        -o)
            _ssh_options;
            return 0
        ;;
        -w)
            _available_interfaces;
            return 0
        ;;
        -b)
            _ssh_bindaddress;
            return 0
        ;;
    esac;
    if [[ "$cur" == -F* ]]; then
        cur=${cur#-F};
        _filedir;
        COMPREPLY=("${COMPREPLY[@]/#/-F}");
        cur=-F$cur;
    else
        if [[ "$cur" == -* ]]; then
            COMPREPLY=($( compgen -W '-1 -2 -4 -6 -A -a -C -f -g -K -k -M \
            -N -n -q -s -T -t -V -v -X -v -Y -y -b -b -c -D -e -F \
            -i -L -l -m -O -o -p -R -S -w' -- "$cur" ));
        else
            set -- "${COMP_WORDS[@]}";
            while [ $# -gt 0 ]; do
                if [ "${1:0:2}" = -F ]; then
                    if [ ${#1} -gt 2 ]; then
                        configfile="$(dequote "${1:2}")";
                    else
                        shift;
                        [ "$1" ] && configfile="$(dequote "$1")";
                    fi;
                    break;
                fi;
                shift;
            done;
            _known_hosts_real -a -F "$configfile" "$cur";
            if [ $COMP_CWORD -ne 1 ]; then
                _compopt_o_filenames;
                COMPREPLY=("${COMPREPLY[@]}" $( compgen -c -- "$cur" ));
            fi;
        fi;
    fi;
    return 0
}
_ssh_bindaddress () 
{ 
    COMPREPLY=("${COMPREPLY[@]}" $( compgen -W         "$( PATH="$PATH:/sbin" ifconfig -a |         sed -ne 's/.*addr:\([^[:space:]]*\).*/\1/p'             -ne 's/.*inet[[:space:]]\{1,\}\([^[:space:]]*\).*/\1/p' )"         -- "$cur" ))
}
_ssh_ciphers () 
{ 
    COMPREPLY=("${COMPREPLY[@]}" $( compgen -W '3des-cbc aes128-cbc \
        aes192-cbc aes256-cbc aes128-ctr aes192-ctr aes256-ctr arcfour128 \
        arcfour256 arcfour blowfish-cbc cast128-cbc' -- "$cur" ))
}
_ssh_copy_id () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -i)
            _filedir;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-i' -- "$cur" ));
    else
        _known_hosts_real -a "$cur";
    fi;
    return 0
}
_ssh_macs () 
{ 
    COMPREPLY=("${COMPREPLY[@]}" $( compgen -W 'hmac-md5 hmac-sha1 \
        umac-64@openssh.com hmac-ripemd160 hmac-sha1-96 hmac-md5-96'         -- "$cur" ))
}
_ssh_options () 
{ 
    type compopt &>/dev/null && compopt -o nospace;
    COMPREPLY=($( compgen -S = -W 'AddressFamily BatchMode BindAddress \
        ChallengeResponseAuthentication CheckHostIP Cipher Ciphers \
        ClearAllForwardings Compression CompressionLevel ConnectionAttempts \
        ConnectTimeout ControlMaster ControlPath DynamicForward EscapeChar \
        ExitOnForwardFailure ForwardAgent ForwardX11 ForwardX11Trusted \
        GatewayPorts GlobalKnownHostsFile GSSAPIAuthentication \
        GSSAPIDelegateCredentials HashKnownHosts Host HostbasedAuthentication \
        HostKeyAlgorithms HostKeyAlias HostName IdentityFile IdentitiesOnly \
        KbdInteractiveDevices LocalCommand LocalForward LogLevel MACs \
        NoHostAuthenticationForLocalhost NumberOfPasswordPrompts \
        PasswordAuthentication PermitLocalCommand Port \
        PreferredAuthentications Protocol ProxyCommand PubkeyAuthentication \
        RekeyLimit RemoteForward RhostsRSAAuthentication RSAAuthentication \
        SendEnv ServerAliveInterval ServerAliveCountMax SmartcardDevice \
        StrictHostKeyChecking TCPKeepAlive Tunnel TunnelDevice \
        UsePrivilegedPort User UserKnownHostsFile VerifyHostKeyDNS \
        VisualHostKey XAuthLocation' -- "$cur" ))
}
_ssh_suboption () 
{ 
    local prev=${1%%=*} cur=${1#*=};
    case $prev in 
        BatchMode | ChallengeResponseAuthentication | CheckHostIP | ClearAllForwardings | Compression | ExitOnForwardFailure | ForwardAgent | ForwardX11 | ForwardX11Trusted | GatewayPorts | GSSAPIAuthentication | GSSAPIKeyExchange | GSSAPIDelegateCredentials | GSSAPITrustDns | HashKnownHosts | HostbasedAuthentication | IdentitiesOnly | KbdInteractiveAuthentication | KbdInteractiveDevices | NoHostAuthenticationForLocalhost | PasswordAuthentication | PubkeyAuthentication | RhostsRSAAuthentication | RSAAuthentication | StrictHostKeyChecking | TCPKeepAlive | UsePrivilegedPort | VerifyHostKeyDNS | VisualHostKey)
            COMPREPLY=($( compgen -W 'yes no' -- "$cur"))
        ;;
        AddressFamily)
            COMPREPLY=($( compgen -W 'any inet inet6' -- "$cur" ))
        ;;
        BindAddress)
            _ssh_bindaddress
        ;;
        Cipher)
            COMPREPLY=($( compgen -W 'blowfish des 3des' -- "$cur" ))
        ;;
        Protocol)
            COMPREPLY=($( compgen -W '1 2 1,2 2,1' -- "$cur" ))
        ;;
        Tunnel)
            COMPREPLY=($( compgen -W 'yes no point-to-point ethernet'                     -- "$cur" ))
        ;;
        PreferredAuthentications)
            COMPREPLY=($( compgen -W 'gssapi-with-mic host-based \
                    publickey keyboard-interactive password' -- "$cur" ))
        ;;
        MACs)
            _ssh_macs
        ;;
        Ciphers)
            _ssh_ciphers
        ;;
    esac;
    return 0
}
_ssh_suboption_check () 
{ 
    local cureq=`_get_cword :=` preveq=`_get_pword :=`;
    if [[ $cureq == *=* && $preveq == -o ]]; then
        _ssh_suboption $cureq;
        return $?;
    fi;
    return 1
}
_stream () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    _ImageMagick;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-authenticate -channel -colorspace \
            -compress -debug -define -density -depth -extract \
            -help -identify -interlace -interpolate -limit -list \
            -log -map -monitor -quantize -quiet -regard-warnings \
            -respect-parenthesis -sampling-factor -seed -set \
            -size -storage-type -transparent-color -verbose \
            -version -virtual-pixel' -- "$cur" ));
    else
        if [[ "$cur" == +* ]]; then
            COMPREPLY=($( compgen -W '+debug' -- "$cur" ));
        else
            _filedir;
        fi;
    fi
}
_svn () 
{ 
    local cur cmds cmdOpts pOpts mOpts rOpts qOpts nOpts optsParam opt;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    cmds='add blame annotate praise cat changelist cl checkout co cleanup';
    cmds="$cmds commit ci copy cp delete remove rm diff export help import";
    cmds="$cmds info list ls lock log merge mergeinfo mkdir move mv rename";
    cmds="$cmds propdel pdel propedit pedit propget pget proplist plist";
    cmds="$cmds propset pset resolve resolved revert status switch unlock";
    cmds="$cmds update";
    local helpOpts='--help -h';
    local specOpts="--version $helpOpts";
    optsParam="-r|--revision|--username|--password|--targets";
    optsParam="$optsParam|-x|--extensions|-m|--message|-F|--file";
    optsParam="$optsParam|--encoding|--diff-cmd|--diff3-cmd|--editor-cmd";
    optsParam="$optsParam|--old|--new|--config-dir|--config-option";
    optsParam="$optsParam|--native-eol|-l|--limit|-c|--change";
    optsParam="$optsParam|--depth|--set-depth|--with-revprop";
    optsParam="$optsParam|--changelist|--accept|--show-revs";
    local svnProps revProps allProps psCmds propCmds;
    svnProps="svn:keywords svn:executable svn:needs-lock svn:externals
	          svn:ignore svn:eol-style svn:mime-type $SVN_BASH_FILE_PROPS";
    revProps="svn:author svn:log svn:date $SVN_BASH_REV_PROPS";
    allProps=($svnProps $revProps);
    psCmds='propset|pset|ps';
    propCmds="$psCmds|propget|pget|pg|propedit|pedit|pe|propdel|pdel|pd";
    local cmd= isPropCmd= isPsCmd= isHelpCmd= nExpectArgs= isCur= i=0;
    local prev= help= prop= val= isRevProp= last='none' nargs=0 stat=;
    local options= hasRevPropOpt= hasRevisionOpt= hasRelocateOpt=;
    local acceptOpt= URL= hasReintegrateOpt=;
    for opt in "${COMP_WORDS[@]}";
    do
        [[ -n $isCur ]] && stat=$last;
        isCur=;
        [[ $i -eq $COMP_CWORD ]] && isCur=1;
        let i++;
        [ $last = 'none' ] && { 
            last='first';
            continue
        };
        if [[ $prev == @($optsParam) ]]; then
            [[ $prev = '--accept' ]] && acceptOpt=$opt;
            prev='';
            last='skip';
            continue;
        fi;
        if [[ $prev == @(<|>|>>|[12]>|[12]>>) ]]; then
            prev='';
            last='skip';
            continue;
        fi;
        prev=$opt;
        if [[ ! -n $cmd && -n $opt && ( $opt != -* || $opt == @(${specOpts// /|}) ) ]]; then
            cmd=$opt;
            [[ $cmd == @($propCmds) ]] && isPropCmd=1;
            [[ $cmd == @($psCmds) ]] && isPsCmd=1;
            [[ $cmd == @(${helpOpts// /|}) ]] && cmd='help';
            [[ $cmd = 'help' ]] && isHelpCmd=1;
            if [[ -n $isHelpCmd && -n $cmd && $cmd != 'help' && ! -n $help ]]; then
                help=$cmd;
                cmd='help';
            fi;
            last='cmd';
            continue;
        fi;
        if [[ -n $isHelpCmd && ! -n $help && -n $opt && $opt != -* ]]; then
            help=$opt;
            last='help';
            continue;
        fi;
        if [[ -n $isPropCmd && ! -n $prop && -n $opt && $opt != -* ]]; then
            prop=$opt;
            [[ $prop == @(${revProps// /|}) ]] && isRevProp=1;
            last='prop';
            continue;
        fi;
        if [[ -n $isPsCmd && -n $prop && ! -n $val && $opt != -* ]]; then
            val=$opt;
            last='val';
            continue;
        fi;
        if [[ $last != 'onlyarg' ]]; then
            case $opt in 
                -r | --revision | --revision=*)
                    hasRevisionOpt=1
                ;;
                --revprop)
                    hasRevPropOpt=1;
                    allProps=($revProps);
                    nExpectArgs=1
                ;;
                -h | --help)
                    isHelpCmd=1
                ;;
                -F | --file)
                    val='-F'
                ;;
                --relocate)
                    hasRelocateOpt=1
                ;;
                --reintegrate)
                    hasReintegrateOpt=1
                ;;
            esac;
            if [[ $opt = '--' && ! -n $isCur ]]; then
                last='onlyarg';
                continue;
            fi;
            if [[ $opt == -* ]]; then
                [[ ! -n $isCur ]] && options="$options $opt ";
                last='opt';
                continue;
            fi;
        else
            let nargs++;
            continue;
        fi;
        if [[ $cmd = 'merge' && ! -n $URL ]]; then
            URL=$opt;
        fi;
        last='arg';
        let nargs++;
    done;
    [[ -n $stat ]] || stat=$last;
    if [[ ! -n $cmd || $stat = 'cmd' ]]; then
        COMPREPLY=($( compgen -W "$cmds $specOpts" -- $cur ));
        return 0;
    fi;
    if [[ $stat = 'help' || ( -n $isHelpCmd && ! -n $help ) ]]; then
        COMPREPLY=($( compgen -W "$cmds" -- $cur ));
        return 0;
    fi;
    if [[ $cmd = 'merge' || $cmd = 'mergeinfo' ]]; then
        local here=$(_svn_info URL);
        if [[ ! -n $URL && $stat = 'arg' ]]; then
            if [[ "$here" == */branches/* ]]; then
                COMPREPLY=($(compgen -W ${here/\/branches\/*/\/trunk} -- $cur ));
                return 0;
            else
                if [[ "$here" == */trunk* ]]; then
                    COMPREPLY=($(compgen -W ${here/\/trunk*/\/branches\/} -- $cur ));
                    return 0;
                else
                    COMPREPLY=($(compgen -W $(_svn_info Root) -- $cur ));
                    return 0;
                fi;
            fi;
        else
            if [[ $URL == */branches/* && $here == */trunk* && ! -n $hasReintegrateOpt && $cur = '' && $stat = 'arg' ]]; then
                COMPREPLY=($(compgen -W '--reintegrate' -- $cur ));
                return 0;
            fi;
        fi;
    fi;
    if [[ $stat = 'skip' ]]; then
        local previous=${COMP_WORDS[COMP_CWORD-1]};
        local values= dirs= beep= exes=;
        [[ $previous = '--config-dir' ]] && dirs=1;
        [[ $previous = --*-cmd ]] && exes=1;
        [[ $previous = '--native-eol' ]] && values='LF CR CRLF';
        [[ $previous = '--limit' ]] && values='0 1 2 3 4 5 6 7 8 9';
        [[ $previous = '--revision' || $previous = '-r' ]] && values='HEAD BASE PREV COMMITTED 0 {';
        [[ $previous = '--encoding' ]] && values="latin1 utf8 $SVN_BASH_ENCODINGS";
        [[ $previous = '--extensions' || $previous = '-x' ]] && values="--unified --ignore-space-change    		        --ignore-all-space --ignore-eol-style";
        [[ $previous = '--depth' ]] && values='empty files immediates infinity';
        [[ $previous = '--set-depth' ]] && values='empty exclude files immediates infinity';
        [[ $previous = '--accept' ]] && { 
            if [[ $cmd = 'resolve' ]]; then
                values='base working mine-full theirs-full';
            else
                values='postpone base mine-full theirs-full edit launch';
            fi
        };
        [[ $previous = '--show-revs' ]] && values='merged eligible';
        if [[ $previous = '--username' ]]; then
            values="$SVN_BASH_USERNAME";
            if [[ $SVN_BASH_COMPL_EXT == *username* ]]; then
                local file=;
                for file in ~/.subversion/auth/svn.simple/*;
                do
                    if [ -r $file ]; then
                        values="$values $(_svn_read_hashfile username < $file)";
                    fi;
                done;
            fi;
            [[ ! -n "$values" ]] && beep=1;
        fi;
        [[ $previous = '--password' ]] && beep=1;
        [[ -n $values ]] && COMPREPLY=($( compgen -W "$values" -- $cur ));
        [[ -n $dirs ]] && COMPREPLY=($( compgen -o dirnames -- $cur ));
        [[ -n $exes ]] && COMPREPLY=($( compgen -c -- $cur ));
        [[ -n $beep ]] && { 
            echo -en "\a";
            COMPREPLY=('')
        };
        return 0;
    fi;
    if [[ -n $isPropCmd && ( ! -n $prop || $stat = 'prop' ) && $cur != -* ]]; then
        local choices=;
        if [[ $cur == *:* ]]; then
            local prefix=${cur%:*} suffix=${cur#*:} c=;
            for c in ${allProps[@]};
            do
                [[ $c == $prefix:* ]] && choices="$choices ${c#*:}";
            done;
            cur=$suffix;
        else
            COMPREPLY=($( compgen -W "${allProps[*]}" -- $cur ));
            [ ${#COMPREPLY[@]} -eq 1 ] && return 0;
            local seen= n=0 last= c=;
            for c in ${allProps[@]%:*};
            do
                if [[ $c == $cur* && ( ! -n $seen || $c != @($seen) ) ]]; then
                    let n++;
                    last=$c;
                    choices="$choices $c:";
                    if [[ -n $seen ]]; then
                        seen="$seen|$c*";
                    else
                        seen="$c*";
                    fi;
                fi;
            done;
            [[ $n -eq 1 ]] && choices="$last:1 $last:2";
        fi;
        COMPREPLY=($( compgen -W "$choices" -- $cur ));
        return 0;
    fi;
    if [[ -n $isRevProp && ! -n $hasRevPropOpt ]]; then
        COMPREPLY=($( compgen -W '--revprop' -- $cur ));
        return 0;
    fi;
    if [[ -n $isRevProp && -n $hasRevPropOpt && ! -n $hasRevisionOpt ]]; then
        COMPREPLY=($( compgen -W '--revision' -- $cur ));
        return 0;
    fi;
    if [[ -n $isPsCmd && -n $prop && ( ! -n $val || $stat = 'val' ) ]]; then
        local values="\' --file";
        case $prop in 
            svn:keywords)
                values="Id Rev URL Date Author Header \' $SVN_BASH_KEYWORDS"
            ;;
            svn:executable | svn:needs-lock)
                values='\\*'
            ;;
            svn:eol-style)
                values='native LF CR CRLF'
            ;;
            svn:mime-type)
                values="text/ text/plain text/html text/xml text/rtf
                       image/ image/png image/gif image/jpeg image/tiff
                       audio/ audio/midi audio/mpeg
                       video/ video/mpeg video/mp4
                       application/ application/octet-stream
                       $SVN_BASH_MIME_TYPE"
            ;;
        esac;
        COMPREPLY=($( compgen -W "$values" -- $cur ));
        [[ -n ${COMPREPLY} ]] && return 0;
    fi;
    if [[ $cmd = 'resolve' && ! -n $acceptOpt ]]; then
        COMPREPLY=($( compgen -W '--accept' -- $cur ));
        return 0;
    fi;
    case $cmd in 
        merge)
            nExpectArgs=3
        ;;
        mergeinfo)
            nExpectArgs=1
        ;;
        copy | cp | move | mv | rename | ren | export | import)
            nExpectArgs=2
        ;;
        switch | sw)
            [[ ! -n $hasRelocateOpt ]] && nExpectArgs=2
        ;;
        help | h)
            nExpectArgs=0
        ;;
        --version)
            nExpectArgs=0
        ;;
    esac;
    if [[ -n $nExpectArgs && $nargs -gt $nExpectArgs ]]; then
        echo -en "\a";
        COMPREPLY=('');
        return 0;
    fi;
    if [[ $cur != -* || $stat = 'onlyarg' ]]; then
        if [[ $SVN_BASH_COMPL_EXT == *svnstatus* ]]; then
            local status='svn status --non-interactive';
            [[ $SVN_BASH_COMPL_EXT == *recurse* ]] || status="$status --non-recursive";
            [[ $SVN_BASH_COMPL_EXT == *externals* ]] || status="$status --ignore-externals";
            local cs= files=;
            [[ -n $cur ]] && cs=$cur*;
            case $cmd in 
                st*)
                    files=$cur*
                ;;
                ci | commit | revert | di*)
                    files=$($status $cs| _svn_grcut '@([MADR!]*| M*|_M*)')
                ;;
                add)
                    files=$($status $cs| _svn_grcut '\?*')
                ;;
                unlock)
                    files=$($status $cs| _svn_grcut '@(??L*|?????[KOTB]*)')
                ;;
                resolve*)
                    files=$($status $cs| _svn_grcut '@(?C*|C*)')
                ;;
                praise | blame | ann*)
                    files=$( _svn_lls all $cur* )
                ;;
                p*)
                    if [[ $cmd == @($propCmds) && $prop == @(svn:ignore|svn:externals) ]]; then
                        files=$( _svn_lls dir . $cur* );
                    else
                        files="$( _svn_lls all $cur* )
                                   $($status $cs | _svn_grcut 'A*' )";
                    fi
                ;;
                info)
                    files="$( _svn_lls all $cur* )
                               $($status $cs | _svn_grcut 'A*' )"
                ;;
                remove | rm | del* | move | mv | rename)
                    files=$( _svn_lls all $cur* )
                ;;
                mkdir)
                    files=$( _svn_lls dir $cur* )
                ;;
                log | lock | up* | cl* | switch)
                    files=$( _svn_lls all $cur* )
                ;;
                merge)
                    files=$( _svn_lls all $cur* )
                ;;
                ls | list)
                    files=$( _svn_lls all $cur* )
                ;;
                *)
                    local fallback=1
                ;;
            esac;
            if [[ $SVN_BASH_COMPL_EXT != *recurse* ]]; then
                files="$files $( _svn_lls dir $cur* )";
            fi;
            if [[ -n $files ]]; then
                COMPREPLY=($( compgen -W "$files" -- $cur ));
                [[ -n "${COMPREPLY[*]}" ]] || COMPREPLY=('');
            else
                if [[ ! -n $fallback ]]; then
                    echo -en "\a";
                    COMPREPLY=('');
                fi;
            fi;
        fi;
        return 0;
    fi;
    pOpts="--username --password --no-auth-cache --non-interactive";
    mOpts="-m --message -F --file --encoding --force-log --with-revprop";
    rOpts="-r --revision";
    qOpts="-q --quiet";
    nOpts="-N --non-recursive --depth";
    gOpts="-g --use-merge-history";
    cmdOpts=;
    case $cmd in 
        --version)
            cmdOpts="$qOpts"
        ;;
        add)
            cmdOpts="--auto-props --no-auto-props --force --targets 		         --no-ignore --parents $nOpts $qOpts $pOpts"
        ;;
        blame | annotate | ann | praise)
            cmdOpts="$rOpts $pOpts -v --verbose --incremental --xml 		         -x --extensions --force $gOpts"
        ;;
        cat)
            cmdOpts="$rOpts $pOpts"
        ;;
        changelist | cl)
            cmdOpts="--targets $pOpts $qOpts --changelist                          -R --recursive --depth --remove"
        ;;
        checkout | co)
            cmdOpts="$rOpts $qOpts $nOpts $pOpts --ignore-externals                          --force --accept"
        ;;
        cleanup)
            cmdOpts="--diff3-cmd $pOpts"
        ;;
        commit | ci)
            cmdOpts="$mOpts $qOpts $nOpts --targets --editor-cmd $pOpts 		         --no-unlock --changelist --keep-changelists"
        ;;
        copy | cp)
            cmdOpts="$mOpts $rOpts $qOpts --editor-cmd $pOpts --parents"
        ;;
        delete | del | remove | rm)
            cmdOpts="--force $mOpts $qOpts --targets --editor-cmd $pOpts                          --keep-local"
        ;;
        diff | di)
            cmdOpts="$rOpts -x --extensions --diff-cmd --no-diff-deleted 		         $nOpts $pOpts --force --old --new --notice-ancestry 		         -c --change --summarize --changelist --xml"
        ;;
        export)
            cmdOpts="$rOpts $qOpts $pOpts $nOpts --force --native-eol                          --ignore-externals"
        ;;
        help | h | \?)
            cmdOpts=
        ;;
        import)
            cmdOpts="--auto-props --no-auto-props $mOpts $qOpts $nOpts 		         --no-ignore --editor-cmd $pOpts --force"
        ;;
        info)
            cmdOpts="$pOpts $rOpts --targets -R --recursive --depth                          --incremental --xml --changelist"
        ;;
        list | ls)
            cmdOpts="$rOpts -v --verbose -R --recursive $pOpts                          --incremental --xml --depth"
        ;;
        lock)
            cmdOpts="-m --message -F --file --encoding --force-log                          --targets --force $pOpts"
        ;;
        log)
            cmdOpts="$rOpts -v --verbose --targets $pOpts --stop-on-copy 		         --incremental --xml $qOpts -l --limit -c --change                          $gOpts --with-all-revprops --with-revprop"
        ;;
        merge)
            cmdOpts="$rOpts $nOpts $qOpts --force --dry-run --diff3-cmd 		         $pOpts --ignore-ancestry -c --change -x --extensions                          --record-only --accept --reintegrate"
        ;;
        mergeinfo)
            cmdOpts="$rOpts $pOpts --show-revs"
        ;;
        mkdir)
            cmdOpts="$mOpts $qOpts --editor-cmd $pOpts --parents"
        ;;
        move | mv | rename | ren)
            cmdOpts="$mOpts $rOpts $qOpts --force --editor-cmd $pOpts                          --parents"
        ;;
        propdel | pdel | pd)
            cmdOpts="$qOpts -R --recursive $rOpts $pOpts --changelist                          --depth";
            [[ -n $isRevProp || ! -n $prop ]] && cmdOpts="$cmdOpts --revprop"
        ;;
        propedit | pedit | pe)
            cmdOpts="--editor-cmd $pOpts $mOpts --force";
            [[ -n $isRevProp || ! -n $prop ]] && cmdOpts="$cmdOpts --revprop $rOpts"
        ;;
        propget | pget | pg)
            cmdOpts="-v --verbose -R --recursive $rOpts --strict $pOpts --changelist                          --depth --xml";
            [[ -n $isRevProp || ! -n $prop ]] && cmdOpts="$cmdOpts --revprop"
        ;;
        proplist | plist | pl)
            cmdOpts="-v --verbose -R --recursive $rOpts --revprop $qOpts 		         $pOpts --changelist --depth --xml"
        ;;
        propset | pset | ps)
            cmdOpts="$qOpts --targets -R --recursive 		         --encoding $pOpts --force --changelist --depth";
            [[ -n $isRevProp || ! -n $prop ]] && cmdOpts="$cmdOpts --revprop $rOpts";
            [[ -n $val ]] || cmdOpts="$cmdOpts -F --file"
        ;;
        resolve)
            cmdOpts="--targets -R --recursive $qOpts $pOpts --accept                          --depth"
        ;;
        resolved)
            cmdOpts="--targets -R --recursive $qOpts $pOpts --depth"
        ;;
        revert)
            cmdOpts="--targets -R --recursive $qOpts --changelist                          --depth $pOpts"
        ;;
        status | stat | st)
            cmdOpts="-u --show-updates -v --verbose $nOpts $qOpts $pOpts 		         --no-ignore --ignore-externals --incremental --xml                          --changelist"
        ;;
        switch | sw)
            cmdOpts="--relocate $rOpts $nOpts $qOpts $pOpts --diff3-cmd                          --force --accept --ignore-externals --set-depth"
        ;;
        unlock)
            cmdOpts="--targets --force $pOpts"
        ;;
        update | up)
            cmdOpts="$rOpts $nOpts $qOpts $pOpts --diff3-cmd                          --ignore-externals --force --accept --changelist                          --editor-cmd --set-depth"
        ;;
        *)

        ;;
    esac;
    [[ "$cmd" != "--version" ]] && cmdOpts="$cmdOpts $helpOpts";
    cmdOpts="$cmdOpts --config-dir --config-option";
    if [[ $acceptOpt == @(edit|launch) ]]; then
        cmdOpts=${cmdOpts/ --non-interactive / };
    fi;
    for opt in $options;
    do
        local optBase;
        case $opt in 
            --*)
                optBase=${opt/=*/}
            ;;
            -*)
                optBase=${opt:0:2}
            ;;
        esac;
        cmdOpts=" $cmdOpts ";
        cmdOpts=${cmdOpts/ ${optBase} / };
        case $optBase in 
            -v)
                cmdOpts=${cmdOpts/ --verbose / }
            ;;
            --verbose)
                cmdOpts=${cmdOpts/ -v / }
            ;;
            -N)
                cmdOpts=${cmdOpts/ --non-recursive / }
            ;;
            --non-recursive)
                cmdOpts=${cmdOpts/ -N / }
            ;;
            -R)
                cmdOpts=${cmdOpts/ --recursive / }
            ;;
            --recursive)
                cmdOpts=${cmdOpts/ -R / }
            ;;
            -x)
                cmdOpts=${cmdOpts/ --extensions / }
            ;;
            --extensions)
                cmdOpts=${cmdOpts/ -x / }
            ;;
            -q)
                cmdOpts=${cmdOpts/ --quiet / }
            ;;
            --quiet)
                cmdOpts=${cmdOpts/ -q / }
            ;;
            -h)
                cmdOpts=${cmdOpts/ --help / }
            ;;
            --help)
                cmdOpts=${cmdOpts/ -h / }
            ;;
            -l)
                cmdOpts=${cmdOpts/ --limit / }
            ;;
            --limit)
                cmdOpts=${cmdOpts/ -l / }
            ;;
            -r)
                cmdOpts=${cmdOpts/ --revision / }
            ;;
            --revision)
                cmdOpts=${cmdOpts/ -r / }
            ;;
            -c)
                cmdOpts=${cmdOpts/ --change / }
            ;;
            --change)
                cmdOpts=${cmdOpts/ -c / }
            ;;
            --auto-props)
                cmdOpts=${cmdOpts/ --no-auto-props / }
            ;;
            --no-auto-props)
                cmdOpts=${cmdOpts/ --auto-props / }
            ;;
            -g)
                cmdOpts=${cmdOpts/ --use-merge-history / }
            ;;
            --use-merge-history)
                cmdOpts=${cmdOpts/ -g / }
            ;;
            -m | --message | -F | --file)
                cmdOpts=${cmdOpts/ --message / };
                cmdOpts=${cmdOpts/ -m / };
                cmdOpts=${cmdOpts/ --file / };
                cmdOpts=${cmdOpts/ -F / }
            ;;
        esac;
        if [ $isHelpCmd ]; then
            cmdOpts=${cmdOpts/ -h / };
            cmdOpts=${cmdOpts/ --help / };
        fi;
    done;
    COMPREPLY=($( compgen -W "$cmdOpts" -- $cur ));
    return 0
}
_svn_grcut () 
{ 
    local re=$1 line= old_IFS;
    old_IFS="$IFS";
    IFS='
';
    while read -r line; do
        [[ ! -n $re || $line == $re ]] && echo "${line/????????/}";
    done;
    IFS="$old_IFS"
}
_svn_info () 
{ 
    local what=$1 line=;
    LANG=C LC_MESSAGES=C svn info --non-interactive 2> /dev/null | while read line; do
        [[ $line == *"$what: "* ]] && echo ${line#*: };
    done
}
_svn_lls () 
{ 
    local opt=$1 f=;
    shift;
    for f in "$@";
    do
        if [[ $opt == @(dir|all) && -d "$f" ]]; then
            echo "$f/";
        else
            if [[ $opt == @(file|all) ]]; then
                local dn= fn="$f";
                [[ "$f" == */* ]] && dn=${f%\/*}/ fn=${f##*\/};
                [ -f "${dn}.svn/text-base/${fn}.svn-base" ] && echo "$f";
            fi;
        fi;
    done
}
_svn_read_hashfile () 
{ 
    local tkey=$1 key= val=;
    while true; do
        read tag len;
        [ $tag = 'END' ] && break;
        [ $tag != 'K' ] && { 
            return
        };
        read -r -n $len key;
        read;
        read tag len;
        [ $tag != 'V' ] && { 
            return
        };
        read -r -n $len val;
        read;
        if [[ $key = $tkey ]]; then
            echo "$val";
            return;
        fi;
    done
}
_svnadmin () 
{ 
    local cur cmds cmdOpts optsParam opt helpCmds optBase i;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    cmds='crashtest create deltify dump help hotcopy list-dblogs \
	      list-unused-dblogs load lslocks lstxns pack recover rmlocks \
	      rmtxns setlog setrevprop setuuid upgrade verify --version';
    if [[ $COMP_CWORD -eq 1 ]]; then
        COMPREPLY=($( compgen -W "$cmds" -- $cur ));
        return 0;
    fi;
    optsParam="-r|--revision|--parent-dir|--fs-type";
    helpCmds='help|--help|h|\?';
    if [[ ${COMP_WORDS[1]} != @($helpCmds) ]] && [[ "$cur" != -* ]] || [[ ${COMP_WORDS[COMP_CWORD-1]} == @($optsParam) ]]; then
        return 0;
    fi;
    cmdOpts=;
    case ${COMP_WORDS[1]} in 
        create)
            cmdOpts="--bdb-txn-nosync --bdb-log-keep --config-dir 		         --fs-type --pre-1.4-compatible --pre-1.5-compatible"
        ;;
        deltify)
            cmdOpts="-r --revision -q --quiet"
        ;;
        dump)
            cmdOpts="-r --revision --incremental -q --quiet --deltas"
        ;;
        help | h | \?)
            cmdOpts="$cmds"
        ;;
        hotcopy)
            cmdOpts="--clean-logs"
        ;;
        load)
            cmdOpts="--ignore-uuid --force-uuid --parent-dir -q --quiet 		         --use-pre-commit-hook --use-post-commit-hook"
        ;;
        recover)
            cmdOpts="--wait"
        ;;
        rmtxns)
            cmdOpts="-q --quiet"
        ;;
        setlog)
            cmdOpts="-r --revision --bypass-hooks"
        ;;
        setrevprop)
            cmdOpts="-r --revision --use-pre-revprop-change-hook 		         --use-post-revprop-change-hook"
        ;;
        verify)
            cmdOpts="-r --revision -q --quiet"
        ;;
        *)

        ;;
    esac;
    cmdOpts="$cmdOpts --help -h";
    for ((i=2; i<=$COMP_CWORD-1; ++i ))
    do
        opt=${COMP_WORDS[$i]};
        case $opt in 
            --*)
                optBase=${opt/=*/}
            ;;
            -*)
                optBase=${opt:0:2}
            ;;
        esac;
        cmdOpts=" $cmdOpts ";
        cmdOpts=${cmdOpts/ ${optBase} / };
        case $optBase in 
            -q)
                cmdOpts=${cmdOpts/ --quiet / }
            ;;
            --quiet)
                cmdOpts=${cmdOpts/ -q / }
            ;;
            -h)
                cmdOpts=${cmdOpts/ --help / }
            ;;
            --help)
                cmdOpts=${cmdOpts/ -h / }
            ;;
            -r)
                cmdOpts=${cmdOpts/ --revision / }
            ;;
            --revision)
                cmdOpts=${cmdOpts/ -r / }
            ;;
        esac;
        if [[ $opt == @($optsParam) ]]; then
            ((++i));
        fi;
    done;
    COMPREPLY=($( compgen -W "$cmdOpts" -- $cur ));
    return 0
}
_svndumpfilter () 
{ 
    local cur cmds cmdOpts optsParam opt helpCmds optBase i;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    cmds='exclude help include --version';
    if [[ $COMP_CWORD -eq 1 ]]; then
        COMPREPLY=($( compgen -W "$cmds" -- $cur ));
        return 0;
    fi;
    optsParam="--targets";
    helpCmds='help|--help|h|\?';
    if [[ ${COMP_WORDS[1]} != @($helpCmds) ]] && [[ "$cur" != -* ]] || [[ ${COMP_WORDS[COMP_CWORD-1]} == @($optsParam) ]]; then
        return 0;
    fi;
    cmdOpts=;
    case ${COMP_WORDS[1]} in 
        exclude | include)
            cmdOpts="--drop-empty-revs --renumber-revs
		         --skip-missing-merge-sources --targets
		         --preserve-revprops --quiet"
        ;;
        help | h | \?)
            cmdOpts="$cmds"
        ;;
        *)

        ;;
    esac;
    cmdOpts="$cmdOpts --help -h";
    for ((i=2; i<=$COMP_CWORD-1; ++i ))
    do
        opt=${COMP_WORDS[$i]};
        case $opt in 
            --*)
                optBase=${opt/=*/}
            ;;
            -*)
                optBase=${opt:0:2}
            ;;
        esac;
        cmdOpts=" $cmdOpts ";
        cmdOpts=${cmdOpts/ ${optBase} / };
        case $optBase in 
            -h)
                cmdOpts=${cmdOpts/ --help / }
            ;;
            --help)
                cmdOpts=${cmdOpts/ -h / }
            ;;
        esac;
        if [[ $opt == @($optsParam) ]]; then
            ((++i));
        fi;
    done;
    COMPREPLY=($( compgen -W "$cmdOpts" -- $cur ));
    return 0
}
_svnlook () 
{ 
    local cur cmds cmdOpts optsParam opt helpCmds optBase i;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    cmds='author cat changed date diff dirs-changed help history info \
	      lock log propget proplist tree uuid youngest --version';
    if [[ $COMP_CWORD -eq 1 ]]; then
        COMPREPLY=($( compgen -W "$cmds" -- $cur ));
        return 0;
    fi;
    optsParam="-r|--revision|-t|--transaction|-l|--limit|-x|--extensions";
    helpCmds='help|--help|h|\?';
    if [[ ${COMP_WORDS[1]} != @($helpCmds) ]] && [[ "$cur" != -* ]] || [[ ${COMP_WORDS[COMP_CWORD-1]} == @($optsParam) ]]; then
        return 0;
    fi;
    cmdOpts=;
    case ${COMP_WORDS[1]} in 
        author)
            cmdOpts="-r --revision -t --transaction"
        ;;
        cat)
            cmdOpts="-r --revision -t --transaction"
        ;;
        changed)
            cmdOpts="-r --revision -t --transaction --copy-info"
        ;;
        date)
            cmdOpts="-r --revision -t --transaction"
        ;;
        diff)
            cmdOpts="-r --revision -t --transaction --diff-copy-from 		         --no-diff-added --no-diff-deleted -x --extensions"
        ;;
        dirs-changed)
            cmdOpts="-r --revision -t --transaction"
        ;;
        help | h | \?)
            cmdOpts="$cmds"
        ;;
        history)
            cmdOpts="-r --revision -l --limit --show-ids"
        ;;
        info)
            cmdOpts="-r --revision -t --transaction"
        ;;
        lock)
            cmdOpts=
        ;;
        log)
            cmdOpts="-r --revision -t --transaction"
        ;;
        propget | pget | pg)
            cmdOpts="-r --revision -t --transaction --revprop"
        ;;
        proplist | plist | pl)
            cmdOpts="-r --revision -t --transaction --revprop -v --verbose --xml"
        ;;
        tree)
            cmdOpts="-r --revision -t --transaction --full-paths -N --non-recursive --show-ids"
        ;;
        uuid)
            cmdOpts=
        ;;
        youngest)
            cmdOpts=
        ;;
        *)

        ;;
    esac;
    cmdOpts="$cmdOpts --help -h";
    for ((i=2; i<=$COMP_CWORD-1; ++i ))
    do
        opt=${COMP_WORDS[$i]};
        case $opt in 
            --*)
                optBase=${opt/=*/}
            ;;
            -*)
                optBase=${opt:0:2}
            ;;
        esac;
        cmdOpts=" $cmdOpts ";
        cmdOpts=${cmdOpts/ ${optBase} / };
        case $optBase in 
            -N)
                cmdOpts=${cmdOpts/ --non-recursive / }
            ;;
            --non-recursive)
                cmdOpts=${cmdOpts/ -N / }
            ;;
            -h)
                cmdOpts=${cmdOpts/ --help / }
            ;;
            --help)
                cmdOpts=${cmdOpts/ -h / }
            ;;
            -l)
                cmdOpts=${cmdOpts/ --limit / }
            ;;
            --limit)
                cmdOpts=${cmdOpts/ -l / }
            ;;
            -r)
                cmdOpts=${cmdOpts/ --revision / }
            ;;
            --revision)
                cmdOpts=${cmdOpts/ -r / }
            ;;
            -t)
                cmdOpts=${cmdOpts/ --transaction / }
            ;;
            --transaction)
                cmdOpts=${cmdOpts/ -t / }
            ;;
            -v)
                cmdOpts=${cmdOpts/ --verbose / }
            ;;
            --verbose)
                cmdOpts=${cmdOpts/ -v / }
            ;;
            -x)
                cmdOpts=${cmdOpts/ --extensions / }
            ;;
            --extensions)
                cmdOpts=${cmdOpts/ -x / }
            ;;
        esac;
        if [[ $opt == @($optsParam) ]]; then
            ((++i));
        fi;
    done;
    COMPREPLY=($( compgen -W "$cmdOpts" -- $cur ));
    return 0
}
_svnsync () 
{ 
    local cur cmds cmdOpts optsParam opt helpCmds optBase i;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    cmds='copy-revprops help info initialize synchronize --version';
    if [[ $COMP_CWORD -eq 1 ]]; then
        COMPREPLY=($( compgen -W "$cmds" -- $cur ));
        return 0;
    fi;
    optsParam="--config-dir|--config-option|--source-username|--source-password";
    optsParam="$optsParam|--sync-username|--sync-password";
    helpCmds='help|--help|h|\?';
    if [[ ${COMP_WORDS[1]} != @($helpCmds) ]] && [[ "$cur" != -* ]] || [[ ${COMP_WORDS[COMP_CWORD-1]} == @($optsParam) ]]; then
        return 0;
    fi;
    cmdOpts=;
    case ${COMP_WORDS[1]} in 
        copy-revprops | initialize | init | synchronize | sync)
            cmdOpts="--non-interactive --no-auth-cache --trust-server-cert 		         --source-username --source-password --sync-username 		         --sync-password --config-dir --config-option -q --quiet"
        ;;
        help | h | \?)
            cmdOpts="$cmds"
        ;;
        info)
            cmdOpts="--non-interactive --no-auth-cache --trust-server-cert 		         --source-username --source-password --sync-username 		         --sync-password --config-dir --config-option"
        ;;
        *)

        ;;
    esac;
    cmdOpts="$cmdOpts --help -h";
    for ((i=2; i<=$COMP_CWORD-1; ++i ))
    do
        opt=${COMP_WORDS[$i]};
        case $opt in 
            --*)
                optBase=${opt/=*/}
            ;;
            -*)
                optBase=${opt:0:2}
            ;;
        esac;
        cmdOpts=" $cmdOpts ";
        cmdOpts=${cmdOpts/ ${optBase} / };
        case $optBase in 
            -h)
                cmdOpts=${cmdOpts/ --help / }
            ;;
            --help)
                cmdOpts=${cmdOpts/ -h / }
            ;;
            -q)
                cmdOpts=${cmdOpts/ --quiet / }
            ;;
            --quiet)
                cmdOpts=${cmdOpts/ -q / }
            ;;
        esac;
        if [[ $opt == @($optsParam) ]]; then
            ((++i));
        fi;
    done;
    COMPREPLY=($( compgen -W "$cmdOpts" -- $cur ));
    return 0
}
_sysctl () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    COMPREPLY=($( compgen -W         "$( PATH="$PATH:/sbin" sysctl -N -a 2>/dev/null )" -- "$cur" ));
    return 0
}
_tar () 
{ 
    local cur ext regex tar untar;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    if [ $COMP_CWORD -eq 1 ]; then
        COMPREPLY=($( compgen -W 'c t x u r d A' -- "$cur" ));
        return 0;
    fi;
    case ${COMP_WORDS[1]} in 
        ?(-)[cr]*f)
            _filedir;
            return 0
        ;;
        +([^IZzJjy])f)
            ext='@(@(tar|gem|spkg)?(.@(Z|[gx]z|bz?(2)|lzma))|t@([glx]z|bz?(2)))';
            regex='\(\(tar\|gem\|spkg\)\(\.\(Z\|[gx]z\|bz?(2)\|lzma\)\)\?\|t\([glx]z\|bz2\?\)\)'
        ;;
        *[Zz]*f)
            ext='@(t?(ar.)|gem.|spkg.)@(gz|Z)';
            regex='\(t\(ar\.\)\?\|gem\.\|spkg\.\)\(gz\|Z\)'
        ;;
        *[Ijy]*f)
            ext='@(@(t?(ar.)|gem.)bz?(2)|spkg)';
            regex='\(\(t\(ar\.\)\?\|gem\.\)bz2\?\|spkg\)'
        ;;
        *[J]*f)
            ext='@(t?(ar.)|gem.|spkg.)@(lz?(ma)|xz)';
            regex='\(t\(ar\.\)\?\|gem\.\|spkg\.\)\(lzma\|xz\)\?'
        ;;
        *)
            _filedir;
            return 0
        ;;
    esac;
    if [[ "$COMP_LINE" == *$ext' ' ]]; then
        tar=$( sed -e 's/^.* \([^ ]*'$regex'\) .*$/\1/' <<<"$COMP_LINE" );
        untar=t${COMP_WORDS[1]//[^Izjyf]/};
        local IFS='
';
        COMPREPLY=($( compgen -W "$( printf '%s\n' $( tar $untar $tar             2>/dev/null ) )" -- "$cur" ));
        return 0;
    fi;
    _filedir "$ext";
    return 0
}
_tilde () 
{ 
    local result=0;
    if [[ ${1:0:1} == "~" && $1 == ${1//\/} ]]; then
        _compopt_o_filenames;
        COMPREPLY=($( compgen -P '~' -u "${1#\~}" ));
        result=${#COMPREPLY[@]};
    fi;
    return $result
}
_tune2fs () 
{ 
    COMPREPLY=();
    local cur prev;
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -c | -C | -E | -i | -J | -L | -m | -r | -T)
            return 0
        ;;
        -e)
            COMPREPLY=($( compgen -W 'continue remount-ro panic' -- "$cur" ));
            return 0
        ;;
        -g)
            _gids;
            COMPREPLY=($( compgen -g -W '${COMPREPLY[@]}' -- "$cur" ));
            return 0
        ;;
        -M)
            _filedir -d
        ;;
        -o)
            local -a opts=(^debug ^bsdgroups ^user_xattr ^acl ^uid16 ^journal_data ^journal_data_ordered ^journal_data_writeback);
            COMPREPLY=($( compgen -W '${opts[@]} ${opts[@]#^}' -- "$cur" ));
            return 0
        ;;
        -O)
            local -a opts=(^dir_index ^dir_nlink ^extent ^extra_isize ^filetype ^flex_bg ^has_journal ^huge_file ^large_file ^resize_inode ^sparse_super ^uninit_bg);
            COMPREPLY=($( compgen -W '${opts[@]} ${opts[@]#^}' -- "$cur" ));
            return 0
        ;;
        -u)
            _uids;
            COMPREPLY=($( compgen -u -W '${COMPREPLY[@]}' -- "$cur" ));
            return 0
        ;;
        -U)
            COMPREPLY=($( compgen -W 'clear random time' -- "$cur" ));
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-c -C -e -E -f -g -i -j -J -l -L -m -M -o
            -O -r -T -u -U' -- "$cur" ));
    fi;
    cur=${cur:=/dev/};
    _filedir
}
_uids () 
{ 
    if type getent &>/dev/null; then
        COMPREPLY=($( compgen -W '$( getent passwd | cut -d: -f3 )' -- "$cur" ));
    else
        if type perl &>/dev/null; then
            COMPREPLY=($( compgen -W '$( perl -e '"'"'while (($uid) = (getpwent)[2]) { print $uid . "\n" }'"'"' )' -- "$cur" ));
        else
            COMPREPLY=($( compgen -W '$( cut -d: -f3 /etc/passwd )' -- "$cur" ));
        fi;
    fi
}
_umount () 
{ 
    local cur;
    _get_comp_words_by_ref cur;
    COMPREPLY=();
    if [[ $(uname -s) = Linux && -r /proc/mounts ]]; then
        _linux_fstab < /proc/mounts;
    else
        local IFS='
';
        COMPREPLY=($( compgen -W '$( mount | cut -d" " -f 3 )' -- "$cur" ));
    fi;
    return 0
}
_units () 
{ 
    COMPREPLY=($( compgen -W 'h s b k m g t H K M G T' -- "$cur" ))
}
_unpack200 () 
{ 
    COMPREPLY=();
    local cur prev;
    _get_comp_words_by_ref cur prev;
    case $prev in 
        '-?' | -h | --help | -V | --version | -J)
            return 0
        ;;
        -H | --deflate-hint)
            COMPREPLY=($( compgen -W 'true false keep' -- "$cur" ));
            return 0
        ;;
        -l | --log-file)
            COMPREPLY=($( compgen -W '-' -- "$cur" ));
            _filedir log;
            return 0
        ;;
    esac;
    local i pack=false jar=false;
    for ((i=0; i < ${#COMP_WORDS[@]}-1; i++ ))
    do
        case ${COMP_WORDS[i]} in 
            *.pack | *.pack.gz)
                pack=true
            ;;
            *.jar)
                jar=true
            ;;
        esac;
    done;
    if ! $pack; then
        if [[ "$cur" == -* ]]; then
            COMPREPLY=($( compgen -W '--deflate-hint= --remove-pack-file \
                --verbose --quiet --log-file= --help --version' -- "$cur" ));
            [[ ${#COMPREPLY[@]} -eq 1 && ${COMPREPLY[0]} == *= ]] && type compopt &>/dev/null && compopt -o nospace;
        else
            _filedir 'pack?(.gz)';
        fi;
    else
        if ! $jar; then
            _filedir jar;
        fi;
    fi
}
_unrar () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-ad -ap -av- -c- -cfg- -cl -cu \
            -dh -ep -f -idp -ierr -inul -kb -o+ -o- -ow -p -p- -r -ta \
            -tb -tn -to -u -v -ver -vp -x -x@ -y' -- "$cur" ));
    else
        if [ $COMP_CWORD -eq 1 ]; then
            COMPREPLY=($( compgen -W 'e l lb lt p t v vb vt x' -- "$cur" ));
        else
            _filedir rar;
        fi;
    fi
}
_upvar () 
{ 
    if unset -v "$1"; then
        if (( $# == 2 )); then
            eval $1=\"\$2\";
        else
            eval $1=\(\"\${@:2}\"\);
        fi;
    fi
}
_upvars () 
{ 
    if ! (( $# )); then
        echo "${FUNCNAME[0]}: usage: ${FUNCNAME[0]} [-v varname" "value] | [-aN varname [value ...]] ..." 1>&2;
        return 2;
    fi;
    while (( $# )); do
        case $1 in 
            -a*)
                [[ -n ${1#-a} ]] || { 
                    echo "bash: ${FUNCNAME[0]}: \`$1': missing" "number specifier" 1>&2;
                    return 1
                };
                printf %d "${1#-a}" &>/dev/null || { 
                    echo "bash:" "${FUNCNAME[0]}: \`$1': invalid number specifier" 1>&2;
                    return 1
                };
                [[ -n "$2" ]] && unset -v "$2" && eval $2=\(\"\${@:3:${1#-a}}\"\) && shift $((${1#-a} + 2)) || { 
                    echo "bash: ${FUNCNAME[0]}:" "\`$1${2+ }$2': missing argument(s)" 1>&2;
                    return 1
                }
            ;;
            -v)
                [[ -n "$2" ]] && unset -v "$2" && eval $2=\"\$3\" && shift 3 || { 
                    echo "bash: ${FUNCNAME[0]}: $1: missing" "argument(s)" 1>&2;
                    return 1
                }
            ;;
            *)
                echo "bash: ${FUNCNAME[0]}: $1: invalid option" 1>&2;
                return 1
            ;;
        esac;
    done
}
_usb_ids () 
{ 
    COMPREPLY=(${COMPREPLY[@]:-} $( compgen -W         "$( PATH="$PATH:/sbin" lsusb | awk '{print $6}' )" -- "$cur" ))
}
_user_at_host () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref -n : cur;
    if [[ $cur == *@* ]]; then
        _known_hosts_real "$cur";
    else
        COMPREPLY=($( compgen -u -- "$cur" ));
    fi;
    return 0
}
_useradd () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case $prev in 
        -c | --comment | -h | --help | -e | --expiredate | -f | --inactive | -k | --key | -p | --password | -u | --uid | -Z | --selinux-user)
            return 0
        ;;
        -b | --base-dir | -d | --home | -k | --skel)
            _filedir -d;
            return 0
        ;;
        -g | --gid)
            _gids;
            COMPREPLY=($( compgen -W '${COMPREPLY[@]} $( compgen -g )'                 -- "$cur" ));
            return 0
        ;;
        -G | --groups)
            COMPREPLY=($( compgen -g -- "$cur" ));
            return 0
        ;;
        -s | --shell)
            _shells;
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--base-dir --comment --home-dir --defaults \
            --expiredate --inactive --gid --groups --help --skel --key \
            --no-log-init --create-home --no-create-home --no-user-group \
            --non-unique --password --system --shell --uid --user-group \
            --selinux-user' -- "$cur" ));
        return 0;
    fi
}
_userdel () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--force --help --remove' -- "$cur" ));
        return 0;
    fi;
    COMPREPLY=($( compgen -u -- "$cur" ))
}
_usergroup () 
{ 
    if [[ $cur = *\\\\* || $cur = *:*:* ]]; then
        return;
    else
        if [[ $cur = *\\:* ]]; then
            local prefix;
            prefix=${cur%%*([^:])};
            prefix=${prefix//\\};
            local mycur="${cur#*[:]}";
            if [[ $1 == -u ]]; then
                _allowed_groups "$mycur";
            else
                local IFS='
';
                COMPREPLY=($( compgen -g -- "$mycur" ));
            fi;
            COMPREPLY=($( compgen -P "$prefix" -W "${COMPREPLY[@]}" ));
        else
            if [[ $cur = *:* ]]; then
                local mycur="${cur#*:}";
                if [[ $1 == -u ]]; then
                    _allowed_groups "$mycur";
                else
                    local IFS='
';
                    COMPREPLY=($( compgen -g -- "$mycur" ));
                fi;
            else
                if [[ $1 == -u ]]; then
                    _allowed_users "$cur";
                else
                    local IFS='
';
                    COMPREPLY=($( compgen -u -- "$cur" ));
                fi;
            fi;
        fi;
    fi
}
_usermod () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case $prev in 
        -c | --comment | -d | --home | -e | --expiredate | -f | --inactive | -h | --help | -l | --login | -p | --password | -u | --uid | -Z | --selinux-user)
            return 0
        ;;
        -g | --gid)
            _gids;
            COMPREPLY=($( compgen -W '${COMPREPLY[@]} $( compgen -g )'                 -- "$cur" ));
            return 0
        ;;
        -G | --groups)
            COMPREPLY=($( compgen -g -- "$cur" ));
            return 0
        ;;
        -s | --shell)
            _shells;
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--append --comment --home --expiredate \
            --inactive --gid --groups --help --login --lock --move-home \
            --non-unique --password --shell --uid --unlock --selinux-user'             -- "$cur" ));
        return 0;
    fi;
    COMPREPLY=($( compgen -u -- "$cur" ))
}
_vgcfgbackup () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -f | --file)
            _filedir;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--debug --file --help \
            --ignorelockingfailure --partial --verbose \
            --version' -- "$cur" ));
    else
        _volumegroups;
    fi
}
_vgcfgrestore () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -f | --file)
            _filedir;
            return 0
        ;;
        -M | --metadatatype)
            COMPREPLY=($( compgen -W '1 2' -- "$cur" ));
            return 0
        ;;
        -n | --name)
            _volumegroups;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--debug --file --list \
            --help --metadatatype --name --test \
            --verbose --version' -- "$cur" ));
    else
        _volumegroups;
    fi
}
_vgchange () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -a | -A | -x | --available | --autobackup | --resizeable)
            COMPREPLY=($( compgen -W 'y n' -- "$cur" ));
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--autobackup --alloc \
            --partial --debug --help --ignorelockingfailure \
            --test --uuid --verbose --version \
            --available --resizeable --logicalvolume \
            --addtag --deltag' -- "$cur" ));
    else
        _volumegroups;
    fi
}
_vgck () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--debug \
            --help --verbose --version' -- "$cur" ));
    else
        _volumegroups;
    fi
}
_vgconvert () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -M | --metadatatype)
            COMPREPLY=($( compgen -W '1 2' -- "$cur" ));
            return 0
        ;;
        --metadatacopies)
            COMPREPLY=($( compgen -W '0 1 2' -- "$cur" ));
            return 0
        ;;
        --metadatasize)
            _sizes;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--debug --help --labelsector \
            --metadatatype --metadatacopies --metadatasize \
            --test --verbose --version' -- "$cur" ));
    else
        _volumegroups;
    fi
}
_vgcreate () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -A | --autobackup)
            COMPREPLY=($( compgen -W 'y n' -- "$cur" ));
            return 0
        ;;
        -M | --metadatatype)
            COMPREPLY=($( compgen -W '1 2' -- "$cur" ));
            return 0
        ;;
        -s | --physicalextentsize)
            _sizes;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--autobackup --addtag --alloc \
            --debug --help --maxlogicalvolumes --metadatatype \
            --maxphysicalvolumes --physicalextentsize --test \
            --verbose --version' -- "$cur" ));
    else
        _args;
        if [ $args -eq 0 ]; then
            _volumegroups;
        else
            _physicalvolumes;
        fi;
    fi
}
_vgdisplay () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        --units)
            _units;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--colon --columns --units \
            --partial --activevolumegroups --verbose \
            --debug --help --version' -- "$cur" ));
    else
        _volumegroups;
    fi
}
_vgextend () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -A | --autobackup)
            COMPREPLY=($( compgen -W 'y n' -- "$cur" ));
            return 0
        ;;
        -L | --size)
            _sizes;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--autobackup --debug \
            --help --test --verbose --version' -- "$cur" ));
    else
        _args;
        if [ $args -eq 0 ]; then
            _volumegroups;
        else
            _physicalvolumes;
        fi;
    fi
}
_vgmerge () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -A | --autobackup)
            COMPREPLY=($( compgen -W 'y n' -- "$cur" ));
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--autobackup --debug --help \
            --list --test --verbose --version' -- "$cur" ));
    else
        _volumegroups;
    fi
}
_vgmknodes () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--debug --help --verbose \
            --version' -- "$cur" ));
    else
        _volumegroups;
    fi
}
_vgport () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--all --debug \
            --help --verbose --version' -- "$cur" ));
    else
        _volumegroups;
    fi
}
_vgreduce () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -A | --autobackup)
            COMPREPLY=($( compgen -W 'y n' -- "$cur" ));
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--all --autobackup \
            --debug --help --removemissing --test \
            --verbose --version' -- "$cur" ));
    else
        _args;
        if [ $args -eq 0 ]; then
            _volumegroups;
        else
            _physicalvolumes;
        fi;
    fi
}
_vgremove () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--debug --help --test \
            --verbose --version' -- "$cur" ));
    else
        _volumegroups;
    fi
}
_vgrename () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -A | --autobackup)
            COMPREPLY=($( compgen -W 'y n' -- "$cur" ));
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--autobackup --debug \
            --help --test --verbose --version' -- "$cur" ));
    else
        _volumegroups;
    fi
}
_vgs () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -o | -O | --options | --sort)
            COMPREPLY=($( compgen -W 'vg_fmt vg_uuid vg_name \
                vg_attr vg_size vg_free vg_sysid \
                vg_extent_size vg_extent_count vg_free_count \
                max_lv max_pv pv_count lv_count snap_count \
                vg_seqno' -- "$cur" ));
            return 0
        ;;
        --units)
            _units;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--aligned --debug \
            --help --ignorelockingfailure --noheadings \
            --nosuffix --options --sort --partial \
            --separator --unbuffered --units \
            --verbose --version' -- "$cur" ));
    else
        _volumegroups;
    fi
}
_vgscan () 
{ 
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--debug --help \
            --ignorelockingfailure --mknodes \
            --partial --verbose --version' -- "$cur" ));
    fi
}
_vgsplit () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -A | --autobackup)
            COMPREPLY=($( compgen -W 'y n' -- "$cur" ));
            return 0
        ;;
        -M | --metadatatype)
            COMPREPLY=($( compgen -W '1 2' -- "$cur" ));
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--autobackup --debug \
            --help --list --metadatatype --test \
            --verbose --version' -- "$cur" ));
    else
        _args;
        if [[ $args -eq 0 || $args -eq 1 ]]; then
            _volumegroups;
        else
            _physicalvolumes;
        fi;
    fi
}
_vipw () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -h | --help)
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--group --help --passwd \
            --quiet --shadow' -- "$cur" ));
        return 0;
    fi
}
_volumegroups () 
{ 
    COMPREPLY=($(compgen -W "$( vgscan 2>/dev/null |         sed -n -e 's|.*Found.*"\(.*\)".*$|\1|p' )" -- "$cur" ))
}
_xhost () 
{ 
    local cur;
    _get_comp_words_by_ref cur;
    case $cur in 
        +*)
            _known_hosts_real -p+ "${cur:1}"
        ;;
        -*)
            _known_hosts_real -p- "${cur:1}"
        ;;
        *)
            _known_hosts_real "$cur"
        ;;
    esac;
    return 0
}
_xmllint () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -o | --output)
            _filedir;
            return 0
        ;;
        --path | --dtdvalidfpi | --maxmem | --encode | --pattern)
            return 0
        ;;
        --dtdvalid)
            _filedir 'dtd?(.gz)';
            return 0
        ;;
        --relaxng)
            _filedir 'rng?(.gz)';
            return 0
        ;;
        --schema)
            _filedir 'xsd?(.gz)';
            return 0
        ;;
        --schematron)
            _filedir 'sch?(.gz)';
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '$( xmllint --help 2>&1 | \
            sed -ne "s/^[[:space:]]*\(--[^[:space:]:]*\).*/\1/p" ) \
            -o' -- "$cur" ));
        return 0;
    fi;
    _filedir '@(*ml|htm|svg|xs[dl]|rng|wsdl|jnlp)?(.gz)'
}
_xmlwf () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -d)
            _filedir -d;
            return 0
        ;;
        -e)
            COMPREPLY=($( compgen -W 'US-ASCII UTF-8 UTF-16 \
                ISO-8859-1' -- "$cur" ));
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-c -d -e -m -n -p -r -s -t -v -w \
            -x' -- "$cur" ));
        return 0;
    fi;
    _filedir '@(*ml|htm|svg|xs[dl]|rng|wsdl|jnlp)'
}
_xmodmap () 
{ 
    COMPREPLY=();
    local cur prev;
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -display | -e)
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-display -help -grammar -verbose -quiet -n
            -e -pm -pk -pke -pp' -- "$cur" ));
        return 0;
    fi;
    _filedir
}
_xrandr () 
{ 
    local cur prev output modes;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        --output)
            local outputs=$(xrandr|awk '/connected/ {print $1}');
            COMPREPLY=($(compgen -W "$outputs" -- "$cur"));
            return 0
        ;;
        --mode)
            for ((i = 1; i < COMP_CWORD; i++ ))
            do
                if [[ "${COMP_WORDS[i]}" == "--output" ]]; then
                    output=${COMP_WORDS[i+1]};
                    break;
                fi;
            done;
            modes=$(xrandr|sed -e "1,/$output/ d"                 -e "/connected/,$ d"|awk '{print $1}');
            COMPREPLY=($( compgen -W "$modes" -- "$cur"));
            return 0
        ;;
    esac;
    case $cur in 
        *)
            COMPREPLY=($(compgen -W '-display -help --orientation --query \
                --size --rate --version -x -y --screen --verbose --dryrun \
                --prop --fb --fbmm --dpi --output --auto --mode --preferred \
                --pos --reflect --rotate --left-of --right-of --above --below \
                --same-as --set --off --crtc --newmode --rmmode --addmode \
                --delmode' -- "$cur"));
            return 0
        ;;
    esac;
    return 0
}
_xrdb () 
{ 
    COMPREPLY=();
    local cur prev;
    _get_comp_words_by_ref cur prev;
    case $prev in 
        -backup | -display | -help)
            return 0
        ;;
        -cpp | -edit)
            _filedir;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-help -display -all -global -screen -screens
            -n -quiet -cpp -nocpp -symbols -query -load -override -merge
            -remove -retain -edit -backup' -- "$cur" ));
        return 0;
    fi;
    _filedir
}
_xsltproc () 
{ 
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in 
        --output | -o)
            _filedir;
            return 0
        ;;
        --maxdepth)
            return 0
        ;;
        --encoding)
            COMPREPLY=($( compgen -W "$( iconv -l | sed -e '/^UTF[1378]/d'                 -e '/^ISO[0-9_]/d' -e '/^8859/d' -e 's/\/.*//')" -- "$cur" ));
            return 0
        ;;
        --param | --stringparam)
            return 0
        ;;
        --path)
            _filedir -d;
            return 0
        ;;
        --writesubtree)
            _filedir -d;
            return 0
        ;;
    esac;
    [[ $COMP_CWORD -gt 2 && `_get_cword '' 2` == --?(string)param ]] && return 0;
    if [[ "$cur" == -* ]]; then
        _longopt xsltproc;
    else
        _filedir '@(xsl|xslt|xml)';
    fi
}
_xz () 
{ 
    COMPREPLY=();
    local cur prev;
    _get_comp_words_by_ref cur prev;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--compress --decompress --test --list \
            --keep --force --stdout --suffix --files --files0 --format --check \
            -0 -1 -2 -3 -4 -5 -6 -7 -8 -9 --fast --best --extreme --memory \
            --lzma1 --lzma2 --x86 --powerpc --ia64 --arm --armthumb --sparc \
            --delta --quiet --verbose --no-warn --help --long-help --version'             -- "$cur" ));
        return 0;
    fi;
    local split=false;
    _split_longopt && split=true;
    local xspec="*.@(xz|lzma|txz|tlz)";
    case $prev in 
        --decompress | --list | --test | -!(-*)[dlt]*)
            xspec="!"$xspec
        ;;
        --files | --files0)
            _filedir;
            return 0
        ;;
        -C | --check)
            COMPREPLY=($( compgen -W 'crc32 crc64 sha256' -- "$cur" ));
            return 0
        ;;
        -F | --format)
            COMPREPLY=($( compgen -W 'auto xz lzma raw' -- "$cur" ));
            return 0
        ;;
        -M | --memory | -S | --suffix | --delta | --lzma1 | --lzma2)
            return 0
        ;;
        -h | --help | -H | --long-help | -V | --version)
            return 0
        ;;
    esac;
    $split && return 0;
    _expand || return 0;
    local IFS='
';
    _compopt_o_filenames;
    COMPREPLY=($( compgen -f -X "$xspec" -- "$cur" ) $( compgen -d -- "$cur" ))
}
_xzdec () 
{ 
    COMPREPLY=();
    local cur prev;
    _get_comp_words_by_ref cur prev;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--memory --help --version' -- "$cur" ));
        return 0;
    fi;
    local split=false;
    _split_longopt && split=true;
    case $prev in 
        -M | --memory)
            return 0
        ;;
        -h | --help | -V | --version)
            return 0
        ;;
    esac;
    $split && return 0;
    _filedir xz
}
_yaourt () 
{ 
    local op cur o;
    COMPREPLY=();
    cur=$(_get_cword);
    if ((COMP_CWORD == 1)); then
        if [[ $cur != -* ]]; then
            _pacman_file;
            return 0;
        else
            _pacman &>/dev/null;
            _arch_compgen "${COMPREPLY[@]}" "-B --backup -C -G --getpkgbuild --stats";
            return 0;
        fi;
    fi;
    for o in 'D database' 'Q query' 'R remove' 'S sync' 'U upgrade' 'B backup' 'C' 'G getpkgbuild';
    do
        _arch_incomp "$o" && break;
    done;
    (($?)) && op="" || op="${o% *}";
    _arch_incomp 'backupfile' || [[ $op == "B" ]] || _pacman &>/dev/null;
    if [[ "$cur" == -* ]]; then
        case "$op" in 
            C)
                _arch_compgen "-c --clean"
            ;;
            Q)
                _arch_compgen "${COMPREPLY[@]}" "--backupfile --date"
            ;;
            S)
                _arch_compgen "${COMPREPLY[@]}" "-b --build -a --aur --devel --holdver"
            ;;
        esac;
    else
        case "$op" in 
            Q)
                _arch_incomp 'backupfile' && _yaourt_backup_file
            ;;
            B)
                _yaourt_backup_file
            ;;
            G)
                _pacman_pkg Slq
            ;;
        esac;
    fi
}
_yaourt_backup_file () 
{ 
    compopt -o filenames;
    _filedir 'tar.*'
}
bash_prompt_cmd () 
{ 
    local CY="\[\e[1;36m\]";
    local BL="\[\e[1;34m\]";
    local WH="\[\e[1;37m\]";
    local BR="\[\e[0;33m\]";
    local RE="\[\e[1;31m\]";
    local PROMPT="${CY}$";
    [ $UID -eq "0" ] && PROMPT="${RE}#";
    local PROMPT_PWD="";
    local PS1_T1="$BL.:[ $CY`whoami`@`hostname` $BL: $CY\t $BL:$CY ";
    local ps_len=$(( ${#PS1_T1} - 12 * 6 + 6 + 4 ));
    local PS1_T2=" $BL]:.\n${PROMPT} \[\e[0m\]";
    local startpos="";
    PROMPT_PWD="${PWD/#$HOME/~}";
    local overflow_prefix="...";
    local pwdlen=${#PROMPT_PWD};
    local maxpwdlen=$(( COLUMNS - ps_len ));
    [ $maxpwdlen -lt 0 ] && maxpwdlen=$(( 80 - ps_len ));
    if [ $pwdlen -gt $maxpwdlen ]; then
        startpos=$(( $pwdlen - maxpwdlen + ${#overflow_prefix} ));
        PROMPT_PWD="${overflow_prefix}${PROMPT_PWD:$startpos:$maxpwdlen}";
    fi;
    export PS1="${PS1_T1}${PROMPT_PWD}${PS1_T2}"
}
dequote () 
{ 
    eval echo "$1" 2> /dev/null
}
quote () 
{ 
    echo \'${1//\'/\'\\\'\'}\'
}
quote_readline () 
{ 
    local quoted;
    _quote_readline_by_ref "$1" ret;
    printf %s "$ret"
}
